import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField,
  __require,
  __toESM
} from "./chunk-UF6YC252.js";

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:crypto
var require_crypto = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:os
var require_os = __commonJS({
  "browser-external:os"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "os" has been externalized for browser compatibility. Cannot access "os.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/universalify/index.js
var require_universalify = __commonJS({
  "node_modules/universalify/index.js"(exports) {
    "use strict";
    exports.fromCallback = function(fn) {
      return Object.defineProperty(function(...args) {
        if (typeof args[args.length - 1] === "function")
          fn.apply(this, args);
        else {
          return new Promise((resolve, reject) => {
            args.push((err, res) => err != null ? reject(err) : resolve(res));
            fn.apply(this, args);
          });
        }
      }, "name", { value: fn.name });
    };
    exports.fromPromise = function(fn) {
      return Object.defineProperty(function(...args) {
        const cb = args[args.length - 1];
        if (typeof cb !== "function")
          return fn.apply(this, args);
        else {
          args.pop();
          fn.apply(this, args).then((r) => cb(null, r), cb);
        }
      }, "name", { value: fn.name });
    };
  }
});

// browser-external:fs
var require_fs = __commonJS({
  "browser-external:fs"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs" has been externalized for browser compatibility. Cannot access "fs.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:constants
var require_constants = __commonJS({
  "browser-external:constants"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "constants" has been externalized for browser compatibility. Cannot access "constants.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/polyfills.js
var require_polyfills = __commonJS({
  "node_modules/graceful-fs/polyfills.js"(exports, module) {
    var constants = require_constants();
    var origCwd = process.cwd;
    var cwd = null;
    var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
    process.cwd = function() {
      if (!cwd)
        cwd = origCwd.call(process);
      return cwd;
    };
    try {
      process.cwd();
    } catch (er) {
    }
    if (typeof process.chdir === "function") {
      chdir = process.chdir;
      process.chdir = function(d) {
        cwd = null;
        chdir.call(process, d);
      };
      if (Object.setPrototypeOf)
        Object.setPrototypeOf(process.chdir, chdir);
    }
    var chdir;
    module.exports = patch;
    function patch(fs10) {
      if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
        patchLchmod(fs10);
      }
      if (!fs10.lutimes) {
        patchLutimes(fs10);
      }
      fs10.chown = chownFix(fs10.chown);
      fs10.fchown = chownFix(fs10.fchown);
      fs10.lchown = chownFix(fs10.lchown);
      fs10.chmod = chmodFix(fs10.chmod);
      fs10.fchmod = chmodFix(fs10.fchmod);
      fs10.lchmod = chmodFix(fs10.lchmod);
      fs10.chownSync = chownFixSync(fs10.chownSync);
      fs10.fchownSync = chownFixSync(fs10.fchownSync);
      fs10.lchownSync = chownFixSync(fs10.lchownSync);
      fs10.chmodSync = chmodFixSync(fs10.chmodSync);
      fs10.fchmodSync = chmodFixSync(fs10.fchmodSync);
      fs10.lchmodSync = chmodFixSync(fs10.lchmodSync);
      fs10.stat = statFix(fs10.stat);
      fs10.fstat = statFix(fs10.fstat);
      fs10.lstat = statFix(fs10.lstat);
      fs10.statSync = statFixSync(fs10.statSync);
      fs10.fstatSync = statFixSync(fs10.fstatSync);
      fs10.lstatSync = statFixSync(fs10.lstatSync);
      if (fs10.chmod && !fs10.lchmod) {
        fs10.lchmod = function(path, mode, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs10.lchmodSync = function() {
        };
      }
      if (fs10.chown && !fs10.lchown) {
        fs10.lchown = function(path, uid, gid, cb) {
          if (cb)
            process.nextTick(cb);
        };
        fs10.lchownSync = function() {
        };
      }
      if (platform === "win32") {
        fs10.rename = typeof fs10.rename !== "function" ? fs10.rename : function(fs$rename) {
          function rename(from, to, cb) {
            var start = Date.now();
            var backoff = 0;
            fs$rename(from, to, function CB(er) {
              if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
                setTimeout(function() {
                  fs10.stat(to, function(stater, st) {
                    if (stater && stater.code === "ENOENT")
                      fs$rename(from, to, CB);
                    else
                      cb(er);
                  });
                }, backoff);
                if (backoff < 100)
                  backoff += 10;
                return;
              }
              if (cb)
                cb(er);
            });
          }
          if (Object.setPrototypeOf)
            Object.setPrototypeOf(rename, fs$rename);
          return rename;
        }(fs10.rename);
      }
      fs10.read = typeof fs10.read !== "function" ? fs10.read : function(fs$read) {
        function read(fd, buffer, offset, length, position, callback_) {
          var callback;
          if (callback_ && typeof callback_ === "function") {
            var eagCounter = 0;
            callback = function(er, _, __) {
              if (er && er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                return fs$read.call(fs10, fd, buffer, offset, length, position, callback);
              }
              callback_.apply(this, arguments);
            };
          }
          return fs$read.call(fs10, fd, buffer, offset, length, position, callback);
        }
        if (Object.setPrototypeOf)
          Object.setPrototypeOf(read, fs$read);
        return read;
      }(fs10.read);
      fs10.readSync = typeof fs10.readSync !== "function" ? fs10.readSync : /* @__PURE__ */ function(fs$readSync) {
        return function(fd, buffer, offset, length, position) {
          var eagCounter = 0;
          while (true) {
            try {
              return fs$readSync.call(fs10, fd, buffer, offset, length, position);
            } catch (er) {
              if (er.code === "EAGAIN" && eagCounter < 10) {
                eagCounter++;
                continue;
              }
              throw er;
            }
          }
        };
      }(fs10.readSync);
      function patchLchmod(fs11) {
        fs11.lchmod = function(path, mode, callback) {
          fs11.open(
            path,
            constants.O_WRONLY | constants.O_SYMLINK,
            mode,
            function(err, fd) {
              if (err) {
                if (callback)
                  callback(err);
                return;
              }
              fs11.fchmod(fd, mode, function(err2) {
                fs11.close(fd, function(err22) {
                  if (callback)
                    callback(err2 || err22);
                });
              });
            }
          );
        };
        fs11.lchmodSync = function(path, mode) {
          var fd = fs11.openSync(path, constants.O_WRONLY | constants.O_SYMLINK, mode);
          var threw = true;
          var ret;
          try {
            ret = fs11.fchmodSync(fd, mode);
            threw = false;
          } finally {
            if (threw) {
              try {
                fs11.closeSync(fd);
              } catch (er) {
              }
            } else {
              fs11.closeSync(fd);
            }
          }
          return ret;
        };
      }
      function patchLutimes(fs11) {
        if (constants.hasOwnProperty("O_SYMLINK") && fs11.futimes) {
          fs11.lutimes = function(path, at, mt, cb) {
            fs11.open(path, constants.O_SYMLINK, function(er, fd) {
              if (er) {
                if (cb)
                  cb(er);
                return;
              }
              fs11.futimes(fd, at, mt, function(er2) {
                fs11.close(fd, function(er22) {
                  if (cb)
                    cb(er2 || er22);
                });
              });
            });
          };
          fs11.lutimesSync = function(path, at, mt) {
            var fd = fs11.openSync(path, constants.O_SYMLINK);
            var ret;
            var threw = true;
            try {
              ret = fs11.futimesSync(fd, at, mt);
              threw = false;
            } finally {
              if (threw) {
                try {
                  fs11.closeSync(fd);
                } catch (er) {
                }
              } else {
                fs11.closeSync(fd);
              }
            }
            return ret;
          };
        } else if (fs11.futimes) {
          fs11.lutimes = function(_a, _b, _c, cb) {
            if (cb)
              process.nextTick(cb);
          };
          fs11.lutimesSync = function() {
          };
        }
      }
      function chmodFix(orig) {
        if (!orig)
          return orig;
        return function(target, mode, cb) {
          return orig.call(fs10, target, mode, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chmodFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, mode) {
          try {
            return orig.call(fs10, target, mode);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function chownFix(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid, cb) {
          return orig.call(fs10, target, uid, gid, function(er) {
            if (chownErOk(er))
              er = null;
            if (cb)
              cb.apply(this, arguments);
          });
        };
      }
      function chownFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, uid, gid) {
          try {
            return orig.call(fs10, target, uid, gid);
          } catch (er) {
            if (!chownErOk(er))
              throw er;
          }
        };
      }
      function statFix(orig) {
        if (!orig)
          return orig;
        return function(target, options, cb) {
          if (typeof options === "function") {
            cb = options;
            options = null;
          }
          function callback(er, stats) {
            if (stats) {
              if (stats.uid < 0)
                stats.uid += 4294967296;
              if (stats.gid < 0)
                stats.gid += 4294967296;
            }
            if (cb)
              cb.apply(this, arguments);
          }
          return options ? orig.call(fs10, target, options, callback) : orig.call(fs10, target, callback);
        };
      }
      function statFixSync(orig) {
        if (!orig)
          return orig;
        return function(target, options) {
          var stats = options ? orig.call(fs10, target, options) : orig.call(fs10, target);
          if (stats) {
            if (stats.uid < 0)
              stats.uid += 4294967296;
            if (stats.gid < 0)
              stats.gid += 4294967296;
          }
          return stats;
        };
      }
      function chownErOk(er) {
        if (!er)
          return true;
        if (er.code === "ENOSYS")
          return true;
        var nonroot = !process.getuid || process.getuid() !== 0;
        if (nonroot) {
          if (er.code === "EINVAL" || er.code === "EPERM")
            return true;
        }
        return false;
      }
    }
  }
});

// browser-external:stream
var require_stream = __commonJS({
  "browser-external:stream"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "stream" has been externalized for browser compatibility. Cannot access "stream.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/legacy-streams.js
var require_legacy_streams = __commonJS({
  "node_modules/graceful-fs/legacy-streams.js"(exports, module) {
    var Stream = require_stream().Stream;
    module.exports = legacy;
    function legacy(fs10) {
      return {
        ReadStream,
        WriteStream
      };
      function ReadStream(path, options) {
        if (!(this instanceof ReadStream))
          return new ReadStream(path, options);
        Stream.call(this);
        var self2 = this;
        this.path = path;
        this.fd = null;
        this.readable = true;
        this.paused = false;
        this.flags = "r";
        this.mode = 438;
        this.bufferSize = 64 * 1024;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.encoding)
          this.setEncoding(this.encoding);
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.end === void 0) {
            this.end = Infinity;
          } else if ("number" !== typeof this.end) {
            throw TypeError("end must be a Number");
          }
          if (this.start > this.end) {
            throw new Error("start must be <= end");
          }
          this.pos = this.start;
        }
        if (this.fd !== null) {
          process.nextTick(function() {
            self2._read();
          });
          return;
        }
        fs10.open(this.path, this.flags, this.mode, function(err, fd) {
          if (err) {
            self2.emit("error", err);
            self2.readable = false;
            return;
          }
          self2.fd = fd;
          self2.emit("open", fd);
          self2._read();
        });
      }
      function WriteStream(path, options) {
        if (!(this instanceof WriteStream))
          return new WriteStream(path, options);
        Stream.call(this);
        this.path = path;
        this.fd = null;
        this.writable = true;
        this.flags = "w";
        this.encoding = "binary";
        this.mode = 438;
        this.bytesWritten = 0;
        options = options || {};
        var keys = Object.keys(options);
        for (var index = 0, length = keys.length; index < length; index++) {
          var key = keys[index];
          this[key] = options[key];
        }
        if (this.start !== void 0) {
          if ("number" !== typeof this.start) {
            throw TypeError("start must be a Number");
          }
          if (this.start < 0) {
            throw new Error("start must be >= zero");
          }
          this.pos = this.start;
        }
        this.busy = false;
        this._queue = [];
        if (this.fd === null) {
          this._open = fs10.open;
          this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
          this.flush();
        }
      }
    }
  }
});

// node_modules/graceful-fs/clone.js
var require_clone = __commonJS({
  "node_modules/graceful-fs/clone.js"(exports, module) {
    "use strict";
    module.exports = clone;
    var getPrototypeOf = Object.getPrototypeOf || function(obj) {
      return obj.__proto__;
    };
    function clone(obj) {
      if (obj === null || typeof obj !== "object")
        return obj;
      if (obj instanceof Object)
        var copy = { __proto__: getPrototypeOf(obj) };
      else
        var copy = /* @__PURE__ */ Object.create(null);
      Object.getOwnPropertyNames(obj).forEach(function(key) {
        Object.defineProperty(copy, key, Object.getOwnPropertyDescriptor(obj, key));
      });
      return copy;
    }
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:assert
var require_assert = __commonJS({
  "browser-external:assert"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "assert" has been externalized for browser compatibility. Cannot access "assert.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/graceful-fs/graceful-fs.js
var require_graceful_fs = __commonJS({
  "node_modules/graceful-fs/graceful-fs.js"(exports, module) {
    var fs10 = require_fs();
    var polyfills = require_polyfills();
    var legacy = require_legacy_streams();
    var clone = require_clone();
    var util = require_util();
    var gracefulQueue;
    var previousSymbol;
    if (typeof Symbol === "function" && typeof Symbol.for === "function") {
      gracefulQueue = Symbol.for("graceful-fs.queue");
      previousSymbol = Symbol.for("graceful-fs.previous");
    } else {
      gracefulQueue = "___graceful-fs.queue";
      previousSymbol = "___graceful-fs.previous";
    }
    function noop() {
    }
    function publishQueue(context, queue2) {
      Object.defineProperty(context, gracefulQueue, {
        get: function() {
          return queue2;
        }
      });
    }
    var debug = noop;
    if (util.debuglog)
      debug = util.debuglog("gfs4");
    else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
      debug = function() {
        var m = util.format.apply(util, arguments);
        m = "GFS4: " + m.split(/\n/).join("\nGFS4: ");
        console.error(m);
      };
    if (!fs10[gracefulQueue]) {
      queue = global[gracefulQueue] || [];
      publishQueue(fs10, queue);
      fs10.close = function(fs$close) {
        function close(fd, cb) {
          return fs$close.call(fs10, fd, function(err) {
            if (!err) {
              resetQueue();
            }
            if (typeof cb === "function")
              cb.apply(this, arguments);
          });
        }
        Object.defineProperty(close, previousSymbol, {
          value: fs$close
        });
        return close;
      }(fs10.close);
      fs10.closeSync = function(fs$closeSync) {
        function closeSync(fd) {
          fs$closeSync.apply(fs10, arguments);
          resetQueue();
        }
        Object.defineProperty(closeSync, previousSymbol, {
          value: fs$closeSync
        });
        return closeSync;
      }(fs10.closeSync);
      if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
        process.on("exit", function() {
          debug(fs10[gracefulQueue]);
          require_assert().equal(fs10[gracefulQueue].length, 0);
        });
      }
    }
    var queue;
    if (!global[gracefulQueue]) {
      publishQueue(global, fs10[gracefulQueue]);
    }
    module.exports = patch(clone(fs10));
    if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs10.__patched) {
      module.exports = patch(fs10);
      fs10.__patched = true;
    }
    function patch(fs11) {
      polyfills(fs11);
      fs11.gracefulify = patch;
      fs11.createReadStream = createReadStream;
      fs11.createWriteStream = createWriteStream;
      var fs$readFile = fs11.readFile;
      fs11.readFile = readFile;
      function readFile(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$readFile(path, options, cb);
        function go$readFile(path2, options2, cb2, startTime) {
          return fs$readFile(path2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$readFile, [path2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$writeFile = fs11.writeFile;
      fs11.writeFile = writeFile;
      function writeFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$writeFile(path, data, options, cb);
        function go$writeFile(path2, data2, options2, cb2, startTime) {
          return fs$writeFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$writeFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$appendFile = fs11.appendFile;
      if (fs$appendFile)
        fs11.appendFile = appendFile;
      function appendFile(path, data, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        return go$appendFile(path, data, options, cb);
        function go$appendFile(path2, data2, options2, cb2, startTime) {
          return fs$appendFile(path2, data2, options2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$appendFile, [path2, data2, options2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$copyFile = fs11.copyFile;
      if (fs$copyFile)
        fs11.copyFile = copyFile;
      function copyFile(src, dest, flags, cb) {
        if (typeof flags === "function") {
          cb = flags;
          flags = 0;
        }
        return go$copyFile(src, dest, flags, cb);
        function go$copyFile(src2, dest2, flags2, cb2, startTime) {
          return fs$copyFile(src2, dest2, flags2, function(err) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$copyFile, [src2, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      var fs$readdir = fs11.readdir;
      fs11.readdir = readdir;
      var noReaddirOptionVersions = /^v[0-5]\./;
      function readdir(path, options, cb) {
        if (typeof options === "function")
          cb = options, options = null;
        var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        } : function go$readdir2(path2, options2, cb2, startTime) {
          return fs$readdir(path2, options2, fs$readdirCallback(
            path2,
            options2,
            cb2,
            startTime
          ));
        };
        return go$readdir(path, options, cb);
        function fs$readdirCallback(path2, options2, cb2, startTime) {
          return function(err, files) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([
                go$readdir,
                [path2, options2, cb2],
                err,
                startTime || Date.now(),
                Date.now()
              ]);
            else {
              if (files && files.sort)
                files.sort();
              if (typeof cb2 === "function")
                cb2.call(this, err, files);
            }
          };
        }
      }
      if (process.version.substr(0, 4) === "v0.8") {
        var legStreams = legacy(fs11);
        ReadStream = legStreams.ReadStream;
        WriteStream = legStreams.WriteStream;
      }
      var fs$ReadStream = fs11.ReadStream;
      if (fs$ReadStream) {
        ReadStream.prototype = Object.create(fs$ReadStream.prototype);
        ReadStream.prototype.open = ReadStream$open;
      }
      var fs$WriteStream = fs11.WriteStream;
      if (fs$WriteStream) {
        WriteStream.prototype = Object.create(fs$WriteStream.prototype);
        WriteStream.prototype.open = WriteStream$open;
      }
      Object.defineProperty(fs11, "ReadStream", {
        get: function() {
          return ReadStream;
        },
        set: function(val) {
          ReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(fs11, "WriteStream", {
        get: function() {
          return WriteStream;
        },
        set: function(val) {
          WriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileReadStream = ReadStream;
      Object.defineProperty(fs11, "FileReadStream", {
        get: function() {
          return FileReadStream;
        },
        set: function(val) {
          FileReadStream = val;
        },
        enumerable: true,
        configurable: true
      });
      var FileWriteStream = WriteStream;
      Object.defineProperty(fs11, "FileWriteStream", {
        get: function() {
          return FileWriteStream;
        },
        set: function(val) {
          FileWriteStream = val;
        },
        enumerable: true,
        configurable: true
      });
      function ReadStream(path, options) {
        if (this instanceof ReadStream)
          return fs$ReadStream.apply(this, arguments), this;
        else
          return ReadStream.apply(Object.create(ReadStream.prototype), arguments);
      }
      function ReadStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            if (that.autoClose)
              that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
            that.read();
          }
        });
      }
      function WriteStream(path, options) {
        if (this instanceof WriteStream)
          return fs$WriteStream.apply(this, arguments), this;
        else
          return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
      }
      function WriteStream$open() {
        var that = this;
        open(that.path, that.flags, that.mode, function(err, fd) {
          if (err) {
            that.destroy();
            that.emit("error", err);
          } else {
            that.fd = fd;
            that.emit("open", fd);
          }
        });
      }
      function createReadStream(path, options) {
        return new fs11.ReadStream(path, options);
      }
      function createWriteStream(path, options) {
        return new fs11.WriteStream(path, options);
      }
      var fs$open = fs11.open;
      fs11.open = open;
      function open(path, flags, mode, cb) {
        if (typeof mode === "function")
          cb = mode, mode = null;
        return go$open(path, flags, mode, cb);
        function go$open(path2, flags2, mode2, cb2, startTime) {
          return fs$open(path2, flags2, mode2, function(err, fd) {
            if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
              enqueue([go$open, [path2, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
            else {
              if (typeof cb2 === "function")
                cb2.apply(this, arguments);
            }
          });
        }
      }
      return fs11;
    }
    function enqueue(elem) {
      debug("ENQUEUE", elem[0].name, elem[1]);
      fs10[gracefulQueue].push(elem);
      retry();
    }
    var retryTimer;
    function resetQueue() {
      var now = Date.now();
      for (var i = 0; i < fs10[gracefulQueue].length; ++i) {
        if (fs10[gracefulQueue][i].length > 2) {
          fs10[gracefulQueue][i][3] = now;
          fs10[gracefulQueue][i][4] = now;
        }
      }
      retry();
    }
    function retry() {
      clearTimeout(retryTimer);
      retryTimer = void 0;
      if (fs10[gracefulQueue].length === 0)
        return;
      var elem = fs10[gracefulQueue].shift();
      var fn = elem[0];
      var args = elem[1];
      var err = elem[2];
      var startTime = elem[3];
      var lastTime = elem[4];
      if (startTime === void 0) {
        debug("RETRY", fn.name, args);
        fn.apply(null, args);
      } else if (Date.now() - startTime >= 6e4) {
        debug("TIMEOUT", fn.name, args);
        var cb = args.pop();
        if (typeof cb === "function")
          cb.call(null, err);
      } else {
        var sinceAttempt = Date.now() - lastTime;
        var sinceStart = Math.max(lastTime - startTime, 1);
        var desiredDelay = Math.min(sinceStart * 1.2, 100);
        if (sinceAttempt >= desiredDelay) {
          debug("RETRY", fn.name, args);
          fn.apply(null, args.concat([startTime]));
        } else {
          fs10[gracefulQueue].push(elem);
        }
      }
      if (retryTimer === void 0) {
        retryTimer = setTimeout(retry, 0);
      }
    }
  }
});

// node_modules/fs-extra/lib/fs/index.js
var require_fs2 = __commonJS({
  "node_modules/fs-extra/lib/fs/index.js"(exports) {
    "use strict";
    var u = require_universalify().fromCallback;
    var fs10 = require_graceful_fs();
    var api = [
      "access",
      "appendFile",
      "chmod",
      "chown",
      "close",
      "copyFile",
      "fchmod",
      "fchown",
      "fdatasync",
      "fstat",
      "fsync",
      "ftruncate",
      "futimes",
      "lchmod",
      "lchown",
      "link",
      "lstat",
      "mkdir",
      "mkdtemp",
      "open",
      "opendir",
      "readdir",
      "readFile",
      "readlink",
      "realpath",
      "rename",
      "rm",
      "rmdir",
      "stat",
      "symlink",
      "truncate",
      "unlink",
      "utimes",
      "writeFile"
    ].filter((key) => {
      return typeof fs10[key] === "function";
    });
    Object.assign(exports, fs10);
    api.forEach((method) => {
      exports[method] = u(fs10[method]);
    });
    exports.exists = function(filename, callback) {
      if (typeof callback === "function") {
        return fs10.exists(filename, callback);
      }
      return new Promise((resolve) => {
        return fs10.exists(filename, resolve);
      });
    };
    exports.read = function(fd, buffer, offset, length, position, callback) {
      if (typeof callback === "function") {
        return fs10.read(fd, buffer, offset, length, position, callback);
      }
      return new Promise((resolve, reject) => {
        fs10.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffer: buffer2 });
        });
      });
    };
    exports.write = function(fd, buffer, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs10.write(fd, buffer, ...args);
      }
      return new Promise((resolve, reject) => {
        fs10.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffer: buffer2 });
        });
      });
    };
    exports.readv = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs10.readv(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs10.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesRead, buffers: buffers2 });
        });
      });
    };
    exports.writev = function(fd, buffers, ...args) {
      if (typeof args[args.length - 1] === "function") {
        return fs10.writev(fd, buffers, ...args);
      }
      return new Promise((resolve, reject) => {
        fs10.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
          if (err)
            return reject(err);
          resolve({ bytesWritten, buffers: buffers2 });
        });
      });
    };
    if (typeof fs10.realpath.native === "function") {
      exports.realpath.native = u(fs10.realpath.native);
    } else {
      process.emitWarning(
        "fs.realpath.native is not a function. Is fs being monkey-patched?",
        "Warning",
        "fs-extra-WARN0003"
      );
    }
  }
});

// node_modules/fs-extra/lib/mkdirs/utils.js
var require_utils = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/utils.js"(exports, module) {
    "use strict";
    var path = require_path();
    module.exports.checkPath = function checkPath(pth) {
      if (process.platform === "win32") {
        const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path.parse(pth).root, ""));
        if (pathHasInvalidWinCharacters) {
          const error = new Error(`Path contains invalid characters: ${pth}`);
          error.code = "EINVAL";
          throw error;
        }
      }
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/make-dir.js
var require_make_dir = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/make-dir.js"(exports, module) {
    "use strict";
    var fs10 = require_fs2();
    var { checkPath } = require_utils();
    var getMode = (options) => {
      const defaults = { mode: 511 };
      if (typeof options === "number")
        return options;
      return { ...defaults, ...options }.mode;
    };
    module.exports.makeDir = async (dir, options) => {
      checkPath(dir);
      return fs10.mkdir(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
    module.exports.makeDirSync = (dir, options) => {
      checkPath(dir);
      return fs10.mkdirSync(dir, {
        mode: getMode(options),
        recursive: true
      });
    };
  }
});

// node_modules/fs-extra/lib/mkdirs/index.js
var require_mkdirs = __commonJS({
  "node_modules/fs-extra/lib/mkdirs/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var { makeDir: _makeDir, makeDirSync } = require_make_dir();
    var makeDir = u(_makeDir);
    module.exports = {
      mkdirs: makeDir,
      mkdirsSync: makeDirSync,
      // alias
      mkdirp: makeDir,
      mkdirpSync: makeDirSync,
      ensureDir: makeDir,
      ensureDirSync: makeDirSync
    };
  }
});

// node_modules/fs-extra/lib/path-exists/index.js
var require_path_exists = __commonJS({
  "node_modules/fs-extra/lib/path-exists/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs10 = require_fs2();
    function pathExists(path) {
      return fs10.access(path).then(() => true).catch(() => false);
    }
    module.exports = {
      pathExists: u(pathExists),
      pathExistsSync: fs10.existsSync
    };
  }
});

// node_modules/fs-extra/lib/util/utimes.js
var require_utimes = __commonJS({
  "node_modules/fs-extra/lib/util/utimes.js"(exports, module) {
    "use strict";
    var fs10 = require_fs2();
    var u = require_universalify().fromPromise;
    async function utimesMillis(path, atime, mtime) {
      const fd = await fs10.open(path, "r+");
      let closeErr = null;
      try {
        await fs10.futimes(fd, atime, mtime);
      } finally {
        try {
          await fs10.close(fd);
        } catch (e) {
          closeErr = e;
        }
      }
      if (closeErr) {
        throw closeErr;
      }
    }
    function utimesMillisSync(path, atime, mtime) {
      const fd = fs10.openSync(path, "r+");
      fs10.futimesSync(fd, atime, mtime);
      return fs10.closeSync(fd);
    }
    module.exports = {
      utimesMillis: u(utimesMillis),
      utimesMillisSync
    };
  }
});

// node_modules/fs-extra/lib/util/stat.js
var require_stat = __commonJS({
  "node_modules/fs-extra/lib/util/stat.js"(exports, module) {
    "use strict";
    var fs10 = require_fs2();
    var path = require_path();
    var u = require_universalify().fromPromise;
    function getStats(src, dest, opts) {
      const statFunc = opts.dereference ? (file) => fs10.stat(file, { bigint: true }) : (file) => fs10.lstat(file, { bigint: true });
      return Promise.all([
        statFunc(src),
        statFunc(dest).catch((err) => {
          if (err.code === "ENOENT")
            return null;
          throw err;
        })
      ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
    }
    function getStatsSync(src, dest, opts) {
      let destStat;
      const statFunc = opts.dereference ? (file) => fs10.statSync(file, { bigint: true }) : (file) => fs10.lstatSync(file, { bigint: true });
      const srcStat = statFunc(src);
      try {
        destStat = statFunc(dest);
      } catch (err) {
        if (err.code === "ENOENT")
          return { srcStat, destStat: null };
        throw err;
      }
      return { srcStat, destStat };
    }
    async function checkPaths(src, dest, funcName, opts) {
      const { srcStat, destStat } = await getStats(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    function checkPathsSync(src, dest, funcName, opts) {
      const { srcStat, destStat } = getStatsSync(src, dest, opts);
      if (destStat) {
        if (areIdentical(srcStat, destStat)) {
          const srcBaseName = path.basename(src);
          const destBaseName = path.basename(dest);
          if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
            return { srcStat, destStat, isChangingCase: true };
          }
          throw new Error("Source and destination must not be the same.");
        }
        if (srcStat.isDirectory() && !destStat.isDirectory()) {
          throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src}'.`);
        }
        if (!srcStat.isDirectory() && destStat.isDirectory()) {
          throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src}'.`);
        }
      }
      if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return { srcStat, destStat };
    }
    async function checkParentPaths(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (destParent === srcParent || destParent === path.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = await fs10.stat(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPaths(src, srcStat, destParent, funcName);
    }
    function checkParentPathsSync(src, srcStat, dest, funcName) {
      const srcParent = path.resolve(path.dirname(src));
      const destParent = path.resolve(path.dirname(dest));
      if (destParent === srcParent || destParent === path.parse(destParent).root)
        return;
      let destStat;
      try {
        destStat = fs10.statSync(destParent, { bigint: true });
      } catch (err) {
        if (err.code === "ENOENT")
          return;
        throw err;
      }
      if (areIdentical(srcStat, destStat)) {
        throw new Error(errMsg(src, dest, funcName));
      }
      return checkParentPathsSync(src, srcStat, destParent, funcName);
    }
    function areIdentical(srcStat, destStat) {
      return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
    }
    function isSrcSubdir(src, dest) {
      const srcArr = path.resolve(src).split(path.sep).filter((i) => i);
      const destArr = path.resolve(dest).split(path.sep).filter((i) => i);
      return srcArr.every((cur, i) => destArr[i] === cur);
    }
    function errMsg(src, dest, funcName) {
      return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;
    }
    module.exports = {
      // checkPaths
      checkPaths: u(checkPaths),
      checkPathsSync,
      // checkParent
      checkParentPaths: u(checkParentPaths),
      checkParentPathsSync,
      // Misc
      isSrcSubdir,
      areIdentical
    };
  }
});

// node_modules/fs-extra/lib/copy/copy.js
var require_copy = __commonJS({
  "node_modules/fs-extra/lib/copy/copy.js"(exports, module) {
    "use strict";
    var fs10 = require_fs2();
    var path = require_path();
    var { mkdirs } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { utimesMillis } = require_utimes();
    var stat = require_stat();
    async function copy(src, dest, opts = {}) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0001"
        );
      }
      const { srcStat, destStat } = await stat.checkPaths(src, dest, "copy", opts);
      await stat.checkParentPaths(src, srcStat, dest, "copy");
      const include = await runFilter(src, dest, opts);
      if (!include)
        return;
      const destParent = path.dirname(dest);
      const dirExists = await pathExists(destParent);
      if (!dirExists) {
        await mkdirs(destParent);
      }
      await getStatsAndPerformCopy(destStat, src, dest, opts);
    }
    async function runFilter(src, dest, opts) {
      if (!opts.filter)
        return true;
      return opts.filter(src, dest);
    }
    async function getStatsAndPerformCopy(destStat, src, dest, opts) {
      const statFn = opts.dereference ? fs10.stat : fs10.lstat;
      const srcStat = await statFn(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    async function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      if (opts.overwrite) {
        await fs10.unlink(dest);
        return copyFile(srcStat, src, dest, opts);
      }
      if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    async function copyFile(srcStat, src, dest, opts) {
      await fs10.copyFile(src, dest);
      if (opts.preserveTimestamps) {
        if (fileIsNotWritable(srcStat.mode)) {
          await makeFileWritable(dest, srcStat.mode);
        }
        const updatedSrcStat = await fs10.stat(src);
        await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
      }
      return fs10.chmod(dest, srcStat.mode);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return fs10.chmod(dest, srcMode | 128);
    }
    async function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat) {
        await fs10.mkdir(dest);
      }
      const items = await fs10.readdir(src);
      await Promise.all(items.map(async (item) => {
        const srcItem = path.join(src, item);
        const destItem = path.join(dest, item);
        const include = await runFilter(srcItem, destItem, opts);
        if (!include)
          return;
        const { destStat: destStat2 } = await stat.checkPaths(srcItem, destItem, "copy", opts);
        return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
      }));
      if (!destStat) {
        await fs10.chmod(dest, srcStat.mode);
      }
    }
    async function onLink(destStat, src, dest, opts) {
      let resolvedSrc = await fs10.readlink(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs10.symlink(resolvedSrc, dest);
      }
      let resolvedDest = null;
      try {
        resolvedDest = await fs10.readlink(dest);
      } catch (e) {
        if (e.code === "EINVAL" || e.code === "UNKNOWN")
          return fs10.symlink(resolvedSrc, dest);
        throw e;
      }
      if (opts.dereference) {
        resolvedDest = path.resolve(process.cwd(), resolvedDest);
      }
      if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
        throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
      }
      if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
        throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
      }
      await fs10.unlink(dest);
      return fs10.symlink(resolvedSrc, dest);
    }
    module.exports = copy;
  }
});

// node_modules/fs-extra/lib/copy/copy-sync.js
var require_copy_sync = __commonJS({
  "node_modules/fs-extra/lib/copy/copy-sync.js"(exports, module) {
    "use strict";
    var fs10 = require_graceful_fs();
    var path = require_path();
    var mkdirsSync = require_mkdirs().mkdirsSync;
    var utimesMillisSync = require_utimes().utimesMillisSync;
    var stat = require_stat();
    function copySync(src, dest, opts) {
      if (typeof opts === "function") {
        opts = { filter: opts };
      }
      opts = opts || {};
      opts.clobber = "clobber" in opts ? !!opts.clobber : true;
      opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
      if (opts.preserveTimestamps && process.arch === "ia32") {
        process.emitWarning(
          "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
          "Warning",
          "fs-extra-WARN0002"
        );
      }
      const { srcStat, destStat } = stat.checkPathsSync(src, dest, "copy", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "copy");
      if (opts.filter && !opts.filter(src, dest))
        return;
      const destParent = path.dirname(dest);
      if (!fs10.existsSync(destParent))
        mkdirsSync(destParent);
      return getStats(destStat, src, dest, opts);
    }
    function getStats(destStat, src, dest, opts) {
      const statSync = opts.dereference ? fs10.statSync : fs10.lstatSync;
      const srcStat = statSync(src);
      if (srcStat.isDirectory())
        return onDir(srcStat, destStat, src, dest, opts);
      else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice())
        return onFile(srcStat, destStat, src, dest, opts);
      else if (srcStat.isSymbolicLink())
        return onLink(destStat, src, dest, opts);
      else if (srcStat.isSocket())
        throw new Error(`Cannot copy a socket file: ${src}`);
      else if (srcStat.isFIFO())
        throw new Error(`Cannot copy a FIFO pipe: ${src}`);
      throw new Error(`Unknown file: ${src}`);
    }
    function onFile(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return copyFile(srcStat, src, dest, opts);
      return mayCopyFile(srcStat, src, dest, opts);
    }
    function mayCopyFile(srcStat, src, dest, opts) {
      if (opts.overwrite) {
        fs10.unlinkSync(dest);
        return copyFile(srcStat, src, dest, opts);
      } else if (opts.errorOnExist) {
        throw new Error(`'${dest}' already exists`);
      }
    }
    function copyFile(srcStat, src, dest, opts) {
      fs10.copyFileSync(src, dest);
      if (opts.preserveTimestamps)
        handleTimestamps(srcStat.mode, src, dest);
      return setDestMode(dest, srcStat.mode);
    }
    function handleTimestamps(srcMode, src, dest) {
      if (fileIsNotWritable(srcMode))
        makeFileWritable(dest, srcMode);
      return setDestTimestamps(src, dest);
    }
    function fileIsNotWritable(srcMode) {
      return (srcMode & 128) === 0;
    }
    function makeFileWritable(dest, srcMode) {
      return setDestMode(dest, srcMode | 128);
    }
    function setDestMode(dest, srcMode) {
      return fs10.chmodSync(dest, srcMode);
    }
    function setDestTimestamps(src, dest) {
      const updatedSrcStat = fs10.statSync(src);
      return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
    }
    function onDir(srcStat, destStat, src, dest, opts) {
      if (!destStat)
        return mkDirAndCopy(srcStat.mode, src, dest, opts);
      return copyDir(src, dest, opts);
    }
    function mkDirAndCopy(srcMode, src, dest, opts) {
      fs10.mkdirSync(dest);
      copyDir(src, dest, opts);
      return setDestMode(dest, srcMode);
    }
    function copyDir(src, dest, opts) {
      fs10.readdirSync(src).forEach((item) => copyDirItem(item, src, dest, opts));
    }
    function copyDirItem(item, src, dest, opts) {
      const srcItem = path.join(src, item);
      const destItem = path.join(dest, item);
      if (opts.filter && !opts.filter(srcItem, destItem))
        return;
      const { destStat } = stat.checkPathsSync(srcItem, destItem, "copy", opts);
      return getStats(destStat, srcItem, destItem, opts);
    }
    function onLink(destStat, src, dest, opts) {
      let resolvedSrc = fs10.readlinkSync(src);
      if (opts.dereference) {
        resolvedSrc = path.resolve(process.cwd(), resolvedSrc);
      }
      if (!destStat) {
        return fs10.symlinkSync(resolvedSrc, dest);
      } else {
        let resolvedDest;
        try {
          resolvedDest = fs10.readlinkSync(dest);
        } catch (err) {
          if (err.code === "EINVAL" || err.code === "UNKNOWN")
            return fs10.symlinkSync(resolvedSrc, dest);
          throw err;
        }
        if (opts.dereference) {
          resolvedDest = path.resolve(process.cwd(), resolvedDest);
        }
        if (stat.isSrcSubdir(resolvedSrc, resolvedDest)) {
          throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
        }
        if (stat.isSrcSubdir(resolvedDest, resolvedSrc)) {
          throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
        }
        return copyLink(resolvedSrc, dest);
      }
    }
    function copyLink(resolvedSrc, dest) {
      fs10.unlinkSync(dest);
      return fs10.symlinkSync(resolvedSrc, dest);
    }
    module.exports = copySync;
  }
});

// node_modules/fs-extra/lib/copy/index.js
var require_copy2 = __commonJS({
  "node_modules/fs-extra/lib/copy/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      copy: u(require_copy()),
      copySync: require_copy_sync()
    };
  }
});

// node_modules/fs-extra/lib/remove/index.js
var require_remove = __commonJS({
  "node_modules/fs-extra/lib/remove/index.js"(exports, module) {
    "use strict";
    var fs10 = require_graceful_fs();
    var u = require_universalify().fromCallback;
    function remove(path, callback) {
      fs10.rm(path, { recursive: true, force: true }, callback);
    }
    function removeSync(path) {
      fs10.rmSync(path, { recursive: true, force: true });
    }
    module.exports = {
      remove: u(remove),
      removeSync
    };
  }
});

// node_modules/fs-extra/lib/empty/index.js
var require_empty = __commonJS({
  "node_modules/fs-extra/lib/empty/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs10 = require_fs2();
    var path = require_path();
    var mkdir = require_mkdirs();
    var remove = require_remove();
    var emptyDir = u(async function emptyDir2(dir) {
      let items;
      try {
        items = await fs10.readdir(dir);
      } catch {
        return mkdir.mkdirs(dir);
      }
      return Promise.all(items.map((item) => remove.remove(path.join(dir, item))));
    });
    function emptyDirSync(dir) {
      let items;
      try {
        items = fs10.readdirSync(dir);
      } catch {
        return mkdir.mkdirsSync(dir);
      }
      items.forEach((item) => {
        item = path.join(dir, item);
        remove.removeSync(item);
      });
    }
    module.exports = {
      emptyDirSync,
      emptydirSync: emptyDirSync,
      emptyDir,
      emptydir: emptyDir
    };
  }
});

// node_modules/fs-extra/lib/ensure/file.js
var require_file = __commonJS({
  "node_modules/fs-extra/lib/ensure/file.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path = require_path();
    var fs10 = require_fs2();
    var mkdir = require_mkdirs();
    async function createFile(file) {
      let stats;
      try {
        stats = await fs10.stat(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path.dirname(file);
      let dirStats = null;
      try {
        dirStats = await fs10.stat(dir);
      } catch (err) {
        if (err.code === "ENOENT") {
          await mkdir.mkdirs(dir);
          await fs10.writeFile(file, "");
          return;
        } else {
          throw err;
        }
      }
      if (dirStats.isDirectory()) {
        await fs10.writeFile(file, "");
      } else {
        await fs10.readdir(dir);
      }
    }
    function createFileSync(file) {
      let stats;
      try {
        stats = fs10.statSync(file);
      } catch {
      }
      if (stats && stats.isFile())
        return;
      const dir = path.dirname(file);
      try {
        if (!fs10.statSync(dir).isDirectory()) {
          fs10.readdirSync(dir);
        }
      } catch (err) {
        if (err && err.code === "ENOENT")
          mkdir.mkdirsSync(dir);
        else
          throw err;
      }
      fs10.writeFileSync(file, "");
    }
    module.exports = {
      createFile: u(createFile),
      createFileSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/link.js
var require_link = __commonJS({
  "node_modules/fs-extra/lib/ensure/link.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path = require_path();
    var fs10 = require_fs2();
    var mkdir = require_mkdirs();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createLink(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = await fs10.lstat(dstpath);
      } catch {
      }
      let srcStat;
      try {
        srcStat = await fs10.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      if (dstStat && areIdentical(srcStat, dstStat))
        return;
      const dir = path.dirname(dstpath);
      const dirExists = await pathExists(dir);
      if (!dirExists) {
        await mkdir.mkdirs(dir);
      }
      await fs10.link(srcpath, dstpath);
    }
    function createLinkSync(srcpath, dstpath) {
      let dstStat;
      try {
        dstStat = fs10.lstatSync(dstpath);
      } catch {
      }
      try {
        const srcStat = fs10.lstatSync(srcpath);
        if (dstStat && areIdentical(srcStat, dstStat))
          return;
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureLink");
        throw err;
      }
      const dir = path.dirname(dstpath);
      const dirExists = fs10.existsSync(dir);
      if (dirExists)
        return fs10.linkSync(srcpath, dstpath);
      mkdir.mkdirsSync(dir);
      return fs10.linkSync(srcpath, dstpath);
    }
    module.exports = {
      createLink: u(createLink),
      createLinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-paths.js
var require_symlink_paths = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-paths.js"(exports, module) {
    "use strict";
    var path = require_path();
    var fs10 = require_fs2();
    var { pathExists } = require_path_exists();
    var u = require_universalify().fromPromise;
    async function symlinkPaths(srcpath, dstpath) {
      if (path.isAbsolute(srcpath)) {
        try {
          await fs10.lstat(srcpath);
        } catch (err) {
          err.message = err.message.replace("lstat", "ensureSymlink");
          throw err;
        }
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      const exists = await pathExists(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      try {
        await fs10.lstat(srcpath);
      } catch (err) {
        err.message = err.message.replace("lstat", "ensureSymlink");
        throw err;
      }
      return {
        toCwd: srcpath,
        toDst: path.relative(dstdir, srcpath)
      };
    }
    function symlinkPathsSync(srcpath, dstpath) {
      if (path.isAbsolute(srcpath)) {
        const exists2 = fs10.existsSync(srcpath);
        if (!exists2)
          throw new Error("absolute srcpath does not exist");
        return {
          toCwd: srcpath,
          toDst: srcpath
        };
      }
      const dstdir = path.dirname(dstpath);
      const relativeToDst = path.join(dstdir, srcpath);
      const exists = fs10.existsSync(relativeToDst);
      if (exists) {
        return {
          toCwd: relativeToDst,
          toDst: srcpath
        };
      }
      const srcExists = fs10.existsSync(srcpath);
      if (!srcExists)
        throw new Error("relative srcpath does not exist");
      return {
        toCwd: srcpath,
        toDst: path.relative(dstdir, srcpath)
      };
    }
    module.exports = {
      symlinkPaths: u(symlinkPaths),
      symlinkPathsSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink-type.js
var require_symlink_type = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink-type.js"(exports, module) {
    "use strict";
    var fs10 = require_fs2();
    var u = require_universalify().fromPromise;
    async function symlinkType(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = await fs10.lstat(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    function symlinkTypeSync(srcpath, type) {
      if (type)
        return type;
      let stats;
      try {
        stats = fs10.lstatSync(srcpath);
      } catch {
        return "file";
      }
      return stats && stats.isDirectory() ? "dir" : "file";
    }
    module.exports = {
      symlinkType: u(symlinkType),
      symlinkTypeSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/symlink.js
var require_symlink = __commonJS({
  "node_modules/fs-extra/lib/ensure/symlink.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var path = require_path();
    var fs10 = require_fs2();
    var { mkdirs, mkdirsSync } = require_mkdirs();
    var { symlinkPaths, symlinkPathsSync } = require_symlink_paths();
    var { symlinkType, symlinkTypeSync } = require_symlink_type();
    var { pathExists } = require_path_exists();
    var { areIdentical } = require_stat();
    async function createSymlink(srcpath, dstpath, type) {
      let stats;
      try {
        stats = await fs10.lstat(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const [srcStat, dstStat] = await Promise.all([
          fs10.stat(srcpath),
          fs10.stat(dstpath)
        ]);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = await symlinkPaths(srcpath, dstpath);
      srcpath = relative.toDst;
      const toType = await symlinkType(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      if (!await pathExists(dir)) {
        await mkdirs(dir);
      }
      return fs10.symlink(srcpath, dstpath, toType);
    }
    function createSymlinkSync(srcpath, dstpath, type) {
      let stats;
      try {
        stats = fs10.lstatSync(dstpath);
      } catch {
      }
      if (stats && stats.isSymbolicLink()) {
        const srcStat = fs10.statSync(srcpath);
        const dstStat = fs10.statSync(dstpath);
        if (areIdentical(srcStat, dstStat))
          return;
      }
      const relative = symlinkPathsSync(srcpath, dstpath);
      srcpath = relative.toDst;
      type = symlinkTypeSync(relative.toCwd, type);
      const dir = path.dirname(dstpath);
      const exists = fs10.existsSync(dir);
      if (exists)
        return fs10.symlinkSync(srcpath, dstpath, type);
      mkdirsSync(dir);
      return fs10.symlinkSync(srcpath, dstpath, type);
    }
    module.exports = {
      createSymlink: u(createSymlink),
      createSymlinkSync
    };
  }
});

// node_modules/fs-extra/lib/ensure/index.js
var require_ensure = __commonJS({
  "node_modules/fs-extra/lib/ensure/index.js"(exports, module) {
    "use strict";
    var { createFile, createFileSync } = require_file();
    var { createLink, createLinkSync } = require_link();
    var { createSymlink, createSymlinkSync } = require_symlink();
    module.exports = {
      // file
      createFile,
      createFileSync,
      ensureFile: createFile,
      ensureFileSync: createFileSync,
      // link
      createLink,
      createLinkSync,
      ensureLink: createLink,
      ensureLinkSync: createLinkSync,
      // symlink
      createSymlink,
      createSymlinkSync,
      ensureSymlink: createSymlink,
      ensureSymlinkSync: createSymlinkSync
    };
  }
});

// node_modules/jsonfile/utils.js
var require_utils2 = __commonJS({
  "node_modules/jsonfile/utils.js"(exports, module) {
    function stringify(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
      const EOF = finalEOL ? EOL : "";
      const str = JSON.stringify(obj, replacer, spaces);
      return str.replace(/\n/g, EOL) + EOF;
    }
    function stripBom(content) {
      if (Buffer.isBuffer(content))
        content = content.toString("utf8");
      return content.replace(/^\uFEFF/, "");
    }
    module.exports = { stringify, stripBom };
  }
});

// node_modules/jsonfile/index.js
var require_jsonfile = __commonJS({
  "node_modules/jsonfile/index.js"(exports, module) {
    var _fs;
    try {
      _fs = require_graceful_fs();
    } catch (_) {
      _fs = require_fs();
    }
    var universalify = require_universalify();
    var { stringify, stripBom } = require_utils2();
    async function _readFile(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs10 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      let data = await universalify.fromCallback(fs10.readFile)(file, options);
      data = stripBom(data);
      let obj;
      try {
        obj = JSON.parse(data, options ? options.reviver : null);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
      return obj;
    }
    var readFile = universalify.fromPromise(_readFile);
    function readFileSync(file, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      const fs10 = options.fs || _fs;
      const shouldThrow = "throws" in options ? options.throws : true;
      try {
        let content = fs10.readFileSync(file, options);
        content = stripBom(content);
        return JSON.parse(content, options.reviver);
      } catch (err) {
        if (shouldThrow) {
          err.message = `${file}: ${err.message}`;
          throw err;
        } else {
          return null;
        }
      }
    }
    async function _writeFile(file, obj, options = {}) {
      const fs10 = options.fs || _fs;
      const str = stringify(obj, options);
      await universalify.fromCallback(fs10.writeFile)(file, str, options);
    }
    var writeFile = universalify.fromPromise(_writeFile);
    function writeFileSync(file, obj, options = {}) {
      const fs10 = options.fs || _fs;
      const str = stringify(obj, options);
      return fs10.writeFileSync(file, str, options);
    }
    var jsonfile = {
      readFile,
      readFileSync,
      writeFile,
      writeFileSync
    };
    module.exports = jsonfile;
  }
});

// node_modules/fs-extra/lib/json/jsonfile.js
var require_jsonfile2 = __commonJS({
  "node_modules/fs-extra/lib/json/jsonfile.js"(exports, module) {
    "use strict";
    var jsonFile = require_jsonfile();
    module.exports = {
      // jsonfile exports
      readJson: jsonFile.readFile,
      readJsonSync: jsonFile.readFileSync,
      writeJson: jsonFile.writeFile,
      writeJsonSync: jsonFile.writeFileSync
    };
  }
});

// node_modules/fs-extra/lib/output-file/index.js
var require_output_file = __commonJS({
  "node_modules/fs-extra/lib/output-file/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var fs10 = require_fs2();
    var path = require_path();
    var mkdir = require_mkdirs();
    var pathExists = require_path_exists().pathExists;
    async function outputFile(file, data, encoding = "utf-8") {
      const dir = path.dirname(file);
      if (!await pathExists(dir)) {
        await mkdir.mkdirs(dir);
      }
      return fs10.writeFile(file, data, encoding);
    }
    function outputFileSync(file, ...args) {
      const dir = path.dirname(file);
      if (!fs10.existsSync(dir)) {
        mkdir.mkdirsSync(dir);
      }
      fs10.writeFileSync(file, ...args);
    }
    module.exports = {
      outputFile: u(outputFile),
      outputFileSync
    };
  }
});

// node_modules/fs-extra/lib/json/output-json.js
var require_output_json = __commonJS({
  "node_modules/fs-extra/lib/json/output-json.js"(exports, module) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFile } = require_output_file();
    async function outputJson(file, data, options = {}) {
      const str = stringify(data, options);
      await outputFile(file, str, options);
    }
    module.exports = outputJson;
  }
});

// node_modules/fs-extra/lib/json/output-json-sync.js
var require_output_json_sync = __commonJS({
  "node_modules/fs-extra/lib/json/output-json-sync.js"(exports, module) {
    "use strict";
    var { stringify } = require_utils2();
    var { outputFileSync } = require_output_file();
    function outputJsonSync(file, data, options) {
      const str = stringify(data, options);
      outputFileSync(file, str, options);
    }
    module.exports = outputJsonSync;
  }
});

// node_modules/fs-extra/lib/json/index.js
var require_json = __commonJS({
  "node_modules/fs-extra/lib/json/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    var jsonFile = require_jsonfile2();
    jsonFile.outputJson = u(require_output_json());
    jsonFile.outputJsonSync = require_output_json_sync();
    jsonFile.outputJSON = jsonFile.outputJson;
    jsonFile.outputJSONSync = jsonFile.outputJsonSync;
    jsonFile.writeJSON = jsonFile.writeJson;
    jsonFile.writeJSONSync = jsonFile.writeJsonSync;
    jsonFile.readJSON = jsonFile.readJson;
    jsonFile.readJSONSync = jsonFile.readJsonSync;
    module.exports = jsonFile;
  }
});

// node_modules/fs-extra/lib/move/move.js
var require_move = __commonJS({
  "node_modules/fs-extra/lib/move/move.js"(exports, module) {
    "use strict";
    var fs10 = require_fs2();
    var path = require_path();
    var { copy } = require_copy2();
    var { remove } = require_remove();
    var { mkdirp } = require_mkdirs();
    var { pathExists } = require_path_exists();
    var stat = require_stat();
    async function move(src, dest, opts = {}) {
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = await stat.checkPaths(src, dest, "move", opts);
      await stat.checkParentPaths(src, srcStat, dest, "move");
      const destParent = path.dirname(dest);
      const parsedParentPath = path.parse(destParent);
      if (parsedParentPath.root !== destParent) {
        await mkdirp(destParent);
      }
      return doRename(src, dest, overwrite, isChangingCase);
    }
    async function doRename(src, dest, overwrite, isChangingCase) {
      if (!isChangingCase) {
        if (overwrite) {
          await remove(dest);
        } else if (await pathExists(dest)) {
          throw new Error("dest already exists.");
        }
      }
      try {
        await fs10.rename(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV") {
          throw err;
        }
        await moveAcrossDevice(src, dest, overwrite);
      }
    }
    async function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      await copy(src, dest, opts);
      return remove(src);
    }
    module.exports = move;
  }
});

// node_modules/fs-extra/lib/move/move-sync.js
var require_move_sync = __commonJS({
  "node_modules/fs-extra/lib/move/move-sync.js"(exports, module) {
    "use strict";
    var fs10 = require_graceful_fs();
    var path = require_path();
    var copySync = require_copy2().copySync;
    var removeSync = require_remove().removeSync;
    var mkdirpSync = require_mkdirs().mkdirpSync;
    var stat = require_stat();
    function moveSync(src, dest, opts) {
      opts = opts || {};
      const overwrite = opts.overwrite || opts.clobber || false;
      const { srcStat, isChangingCase = false } = stat.checkPathsSync(src, dest, "move", opts);
      stat.checkParentPathsSync(src, srcStat, dest, "move");
      if (!isParentRoot(dest))
        mkdirpSync(path.dirname(dest));
      return doRename(src, dest, overwrite, isChangingCase);
    }
    function isParentRoot(dest) {
      const parent = path.dirname(dest);
      const parsedPath = path.parse(parent);
      return parsedPath.root === parent;
    }
    function doRename(src, dest, overwrite, isChangingCase) {
      if (isChangingCase)
        return rename(src, dest, overwrite);
      if (overwrite) {
        removeSync(dest);
        return rename(src, dest, overwrite);
      }
      if (fs10.existsSync(dest))
        throw new Error("dest already exists.");
      return rename(src, dest, overwrite);
    }
    function rename(src, dest, overwrite) {
      try {
        fs10.renameSync(src, dest);
      } catch (err) {
        if (err.code !== "EXDEV")
          throw err;
        return moveAcrossDevice(src, dest, overwrite);
      }
    }
    function moveAcrossDevice(src, dest, overwrite) {
      const opts = {
        overwrite,
        errorOnExist: true,
        preserveTimestamps: true
      };
      copySync(src, dest, opts);
      return removeSync(src);
    }
    module.exports = moveSync;
  }
});

// node_modules/fs-extra/lib/move/index.js
var require_move2 = __commonJS({
  "node_modules/fs-extra/lib/move/index.js"(exports, module) {
    "use strict";
    var u = require_universalify().fromPromise;
    module.exports = {
      move: u(require_move()),
      moveSync: require_move_sync()
    };
  }
});

// node_modules/fs-extra/lib/index.js
var require_lib = __commonJS({
  "node_modules/fs-extra/lib/index.js"(exports, module) {
    "use strict";
    module.exports = {
      // Export promiseified graceful-fs:
      ...require_fs2(),
      // Export extra methods:
      ...require_copy2(),
      ...require_empty(),
      ...require_ensure(),
      ...require_json(),
      ...require_mkdirs(),
      ...require_move2(),
      ...require_output_file(),
      ...require_path_exists(),
      ...require_remove()
    };
  }
});

// browser-external:https
var require_https = __commonJS({
  "browser-external:https"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "https" has been externalized for browser compatibility. Cannot access "https.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// browser-external:url
var require_url = __commonJS({
  "browser-external:url"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "url" has been externalized for browser compatibility. Cannot access "url.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports, module) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module.exports = { nextTick };
    } else {
      module.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/through2/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/through2/node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports, module) {
    module.exports = require_events().EventEmitter;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer2;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function Buffer2(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer2.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer2.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer2.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer2.alloc(+length);
    }
    Buffer2.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer2.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer2.isBuffer(buf))
              buf = Buffer2.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer2.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer2.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer2.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining)
        length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1)
                bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length)
          break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/through2/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/through2/node_modules/safe-buffer/index.js"(exports, module) {
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports.isObject = isObject;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports.isError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports.isPrimitive = isPrimitive;
    exports.isBuffer = require_buffer().Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports, module) {
    if (typeof Object.create === "function") {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports, module) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require_util();
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push(v) {
        var entry = { data: v, next: null };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb) {
          cb(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports, module) {
    module.exports = deprecate;
    function deprecate(fn, msg) {
      if (config("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config("throwDeprecation")) {
            throw new Error(msg);
          } else if (config("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config(name) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name];
      if (null == val)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/_stream_writable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Writable2;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable2.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var internalUtil = {
      deprecate: require_browser()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable2, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0))
        this.highWaterMark = writableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable2, Symbol.hasInstance, {
        value: function(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable2)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object) {
        return object instanceof this;
      };
    }
    function Writable2(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable2, this) && !(this instanceof Duplex)) {
        return new Writable2(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable2.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var valid = true;
      var er = false;
      if (chunk === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb, er);
        valid = false;
      }
      return valid;
    }
    Writable2.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ended)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable2.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable2.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable2.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable2.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable2.prototype._write = function(chunk, encoding, cb) {
      cb(new Error("_write() is not implemented"));
    };
    Writable2.prototype._writev = null;
    Writable2.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          pna.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable2.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable2.prototype.destroy = destroyImpl.destroy;
    Writable2.prototype._undestroy = destroyImpl.undestroy;
    Writable2.prototype._destroy = function(err, cb) {
      this.end();
      cb(err);
    };
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/_stream_duplex.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var Readable3 = require_stream_readable();
    var Writable2 = require_stream_writable();
    util.inherits(Duplex, Readable3);
    {
      keys = objectKeys(Writable2.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable2.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable3.call(this, options);
      Writable2.call(this, options);
      if (options && options.readable === false)
        this.readable = false;
      if (options && options.writable === false)
        this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false)
        this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended)
        return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb) {
      this.push(null);
      this.end();
      pna.nextTick(cb, err);
    };
  }
});

// node_modules/through2/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/through2/node_modules/string_decoder/lib/string_decoder.js"(exports) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length)
        return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed)
        return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + "";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0)
        return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/_stream_readable.js"(exports, module) {
    "use strict";
    var pna = require_process_nextick_args();
    module.exports = Readable3;
    var isArray = require_isarray();
    var Duplex;
    Readable3.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    var debugUtil = require_util();
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable3, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0)
        this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0))
        this.highWaterMark = readableHwm;
      else
        this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable3(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable3))
        return new Readable3(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable3.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable3.prototype.destroy = destroyImpl.destroy;
    Readable3.prototype._undestroy = destroyImpl.undestroy;
    Readable3.prototype._destroy = function(err, cb) {
      this.push(null);
      cb(err);
    };
    Readable3.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable3.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              stream.emit("error", new Error("stream.unshift() after end event"));
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable3.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable3.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable3.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync)
          pna.nextTick(emitReadable_, stream);
        else
          emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else
          len = state.length;
      }
      state.readingMore = false;
    }
    Readable3.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable3.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        pna.nextTick(endFn);
      else
        src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable3.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable3.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable3.prototype.addListener = Readable3.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable3.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable3.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable3.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable3.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable3._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.head.data;
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length)
          ret += str;
        else
          ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next)
              list.head = p.next;
            else
              list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0)
        throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/_stream_transform.js"(exports, module) {
    "use strict";
    module.exports = Transform4;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    util.inherits(Transform4, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (!cb) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform4(options) {
      if (!(this instanceof Transform4))
        return new Transform4(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform4.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform4.prototype._transform = function(chunk, encoding, cb) {
      throw new Error("_transform() is not implemented");
    };
    Transform4.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform4.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform4.prototype._destroy = function(err, cb) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming)
        throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/through2/node_modules/readable-stream/lib/_stream_passthrough.js"(exports, module) {
    "use strict";
    module.exports = PassThrough;
    var Transform4 = require_stream_transform();
    var util = Object.create(require_util2());
    util.inherits = require_inherits_browser();
    util.inherits(PassThrough, Transform4);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform4.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/through2/node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/through2/node_modules/readable-stream/readable-browser.js"(exports, module) {
    exports = module.exports = require_stream_readable();
    exports.Stream = exports;
    exports.Readable = exports;
    exports.Writable = require_stream_writable();
    exports.Duplex = require_stream_duplex();
    exports.Transform = require_stream_transform();
    exports.PassThrough = require_stream_passthrough();
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
  "node_modules/xtend/immutable.js"(exports, module) {
    module.exports = extend;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    function extend() {
      var target = {};
      for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    }
  }
});

// node_modules/through2/through2.js
var require_through2 = __commonJS({
  "node_modules/through2/through2.js"(exports, module) {
    var Transform4 = require_readable_browser().Transform;
    var inherits = require_util().inherits;
    var xtend = require_immutable();
    function DestroyableTransform(opts) {
      Transform4.call(this, opts);
      this._destroyed = false;
    }
    inherits(DestroyableTransform, Transform4);
    DestroyableTransform.prototype.destroy = function(err) {
      if (this._destroyed)
        return;
      this._destroyed = true;
      var self2 = this;
      process.nextTick(function() {
        if (err)
          self2.emit("error", err);
        self2.emit("close");
      });
    };
    function noop(chunk, enc, callback) {
      callback(null, chunk);
    }
    function through2(construct) {
      return function(options, transform, flush) {
        if (typeof options == "function") {
          flush = transform;
          transform = options;
          options = {};
        }
        if (typeof transform != "function")
          transform = noop;
        if (typeof flush != "function")
          flush = null;
        return construct(options, transform, flush);
      };
    }
    module.exports = through2(function(options, transform, flush) {
      var t2 = new DestroyableTransform(options);
      t2._transform = transform;
      if (flush)
        t2._flush = flush;
      return t2;
    });
    module.exports.ctor = through2(function(options, transform, flush) {
      function Through2(override) {
        if (!(this instanceof Through2))
          return new Through2(override);
        this.options = xtend(options, override);
        DestroyableTransform.call(this, this.options);
      }
      inherits(Through2, DestroyableTransform);
      Through2.prototype._transform = transform;
      if (flush)
        Through2.prototype._flush = flush;
      return Through2;
    });
    module.exports.obj = through2(function(options, transform, flush) {
      var t2 = new DestroyableTransform(xtend({ objectMode: true, highWaterMark: 16 }, options));
      t2._transform = transform;
      if (flush)
        t2._flush = flush;
      return t2;
    });
  }
});

// node_modules/speedometer/index.js
var require_speedometer = __commonJS({
  "node_modules/speedometer/index.js"(exports, module) {
    var tick = 1;
    var maxTick = 65535;
    var resolution = 4;
    var inc = function() {
      tick = tick + 1 & maxTick;
    };
    var timer = setInterval(inc, 1e3 / resolution | 0);
    if (timer.unref)
      timer.unref();
    module.exports = function(seconds) {
      var size = resolution * (seconds || 5);
      var buffer = [0];
      var pointer = 1;
      var last = tick - 1 & maxTick;
      return function(delta) {
        var dist = tick - last & maxTick;
        if (dist > size)
          dist = size;
        last = tick;
        while (dist--) {
          if (pointer === size)
            pointer = 0;
          buffer[pointer] = buffer[pointer === 0 ? size - 1 : pointer - 1];
          pointer++;
        }
        if (delta)
          buffer[pointer - 1] += delta;
        var top = buffer[pointer - 1];
        var btm = buffer.length < size ? 0 : buffer[pointer === size ? 0 : pointer];
        return buffer.length < resolution ? top : (top - btm) * resolution / buffer.length;
      };
    };
  }
});

// node_modules/progress-stream/index.js
var require_progress_stream = __commonJS({
  "node_modules/progress-stream/index.js"(exports, module) {
    var through = require_through2();
    var speedometer = require_speedometer();
    module.exports = function(options, onprogress) {
      if (typeof options === "function")
        return module.exports(null, options);
      options = options || {};
      var length = options.length || 0;
      var time = options.time || 0;
      var drain = options.drain || false;
      var transferred = options.transferred || 0;
      var nextUpdate = Date.now() + time;
      var delta = 0;
      var speed = speedometer(options.speed || 5e3);
      var startTime = Date.now();
      var update = {
        percentage: 0,
        transferred,
        length,
        remaining: length,
        eta: 0,
        runtime: 0
      };
      var emit = function(ended) {
        update.delta = delta;
        update.percentage = ended ? 100 : length ? transferred / length * 100 : 0;
        update.speed = speed(delta);
        update.eta = Math.round(update.remaining / update.speed);
        update.runtime = parseInt((Date.now() - startTime) / 1e3);
        nextUpdate = Date.now() + time;
        delta = 0;
        tr.emit("progress", update);
      };
      var write = function(chunk, enc, callback) {
        var len = options.objectMode ? 1 : chunk.length;
        transferred += len;
        delta += len;
        update.transferred = transferred;
        update.remaining = length >= transferred ? length - transferred : 0;
        if (Date.now() >= nextUpdate)
          emit(false);
        callback(null, chunk);
      };
      var end = function(callback) {
        emit(true);
        callback();
      };
      var tr = through(options.objectMode ? { objectMode: true, highWaterMark: 16 } : {}, write, end);
      var onlength = function(newLength) {
        length = newLength;
        update.length = length;
        update.remaining = length - update.transferred;
        tr.emit("length", length);
      };
      tr.setLength = onlength;
      tr.on("pipe", function(stream) {
        if (typeof length === "number")
          return;
        if (stream.readable && !stream.writable && stream.headers) {
          return onlength(parseInt(stream.headers["content-length"] || 0));
        }
        if (typeof stream.length === "number") {
          return onlength(stream.length);
        }
        stream.on("response", function(res) {
          if (!res || !res.headers)
            return;
          if (res.headers["content-encoding"] === "gzip")
            return;
          if (res.headers["content-length"]) {
            return onlength(parseInt(res.headers["content-length"]));
          }
        });
      });
      if (drain)
        tr.resume();
      if (onprogress)
        tr.on("progress", onprogress);
      tr.progress = function() {
        update.speed = speed(0);
        update.eta = Math.round(update.remaining / update.speed);
        return update;
      };
      return tr;
    };
  }
});

// node_modules/agentkeepalive/browser.js
var require_browser2 = __commonJS({
  "node_modules/agentkeepalive/browser.js"(exports, module) {
    module.exports = noop;
    module.exports.HttpsAgent = noop;
    function noop() {
    }
  }
});

// node_modules/crypto-api-v1/index.js
var require_crypto_api_v1 = __commonJS({
  "node_modules/crypto-api-v1/index.js"(exports, module) {
    var CryptoApi = (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId]) {
            return installedModules[moduleId].exports;
          }
          var module2 = installedModules[moduleId] = {
            /******/
            i: moduleId,
            /******/
            l: false,
            /******/
            exports: {}
            /******/
          };
          modules[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
          module2.l = true;
          return module2.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.d = function(exports2, name, getter) {
          if (!__webpack_require__.o(exports2, name)) {
            Object.defineProperty(exports2, name, { enumerable: true, get: getter });
          }
        };
        __webpack_require__.r = function(exports2) {
          if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
            Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
          }
          Object.defineProperty(exports2, "__esModule", { value: true });
        };
        __webpack_require__.t = function(value, mode) {
          if (mode & 1)
            value = __webpack_require__(value);
          if (mode & 8)
            return value;
          if (mode & 4 && typeof value === "object" && value && value.__esModule)
            return value;
          var ns = /* @__PURE__ */ Object.create(null);
          __webpack_require__.r(ns);
          Object.defineProperty(ns, "default", { enumerable: true, value });
          if (mode & 2 && typeof value != "string")
            for (var key in value)
              __webpack_require__.d(ns, key, (function(key2) {
                return value[key2];
              }).bind(null, key));
          return ns;
        };
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? (
            /******/
            function getDefault() {
              return module2["default"];
            }
          ) : (
            /******/
            function getModuleExports() {
              return module2;
            }
          );
          __webpack_require__.d(getter, "a", getter);
          return getter;
        };
        __webpack_require__.o = function(object, property) {
          return Object.prototype.hasOwnProperty.call(object, property);
        };
        __webpack_require__.p = "";
        return __webpack_require__(__webpack_require__.s = 40);
      }([
        /* 0 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return rotateLeft;
          });
          __webpack_require__.d(__webpack_exports__, "b", function() {
            return rotateRight;
          });
          __webpack_require__.d(__webpack_exports__, "d", function() {
            return rotateRight64lo;
          });
          __webpack_require__.d(__webpack_exports__, "c", function() {
            return rotateRight64hi;
          });
          function rotateLeft(x, n) {
            return x << n | x >>> 32 - n | 0;
          }
          function rotateRight(x, n) {
            return x >>> n | x << 32 - n | 0;
          }
          function rotateRight64hi(hi, lo, n) {
            if (n === 32) {
              return lo;
            }
            if (n > 32) {
              return rotateRight64hi(lo, hi, n - 32);
            }
            return (hi >>> n | lo << 32 - n) & 4294967295;
          }
          function rotateRight64lo(hi, lo, n) {
            if (n === 32) {
              return hi;
            }
            if (n > 32) {
              return rotateRight64lo(lo, hi, n - 32);
            }
            return (lo >>> n | hi << 32 - n) & 4294967295;
          }
        },
        /* 1 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromUtf;
          });
          function fromUtf(message) {
            var raw = "";
            for (var i = 0, msgLen = message.length; i < msgLen; i++) {
              var charCode = message.charCodeAt(i);
              if (charCode < 128) {
                raw += String.fromCharCode(charCode);
              } else if (charCode < 2048) {
                raw += String.fromCharCode(192 | charCode >> 6);
                raw += String.fromCharCode(128 | charCode & 63);
              } else if (charCode < 55296 || charCode >= 57344) {
                raw += String.fromCharCode(224 | charCode >> 12);
                raw += String.fromCharCode(128 | charCode >> 6 & 63);
                raw += String.fromCharCode(128 | charCode & 63);
              } else {
                i++;
                charCode = 65536 + ((charCode & 1023) << 10 | message.charCodeAt(i) & 1023);
                raw += String.fromCharCode(240 | charCode >> 18);
                raw += String.fromCharCode(128 | charCode >> 12 & 63);
                raw += String.fromCharCode(128 | charCode >> 6 & 63);
                raw += String.fromCharCode(128 | charCode & 63);
              }
            }
            return raw;
          }
        },
        /* 2 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return toHex;
          });
          function toHex(raw) {
            var str = "";
            for (var i = 0, l = raw.length; i < l; i++) {
              str += (raw.charCodeAt(i) < 16 ? "0" : "") + raw.charCodeAt(i).toString(16);
            }
            return str;
          }
        },
        /* 3 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var Hasher32be = function(_Hasher) {
            _inherits(Hasher32be2, _Hasher);
            var _super = _createSuper(Hasher32be2);
            function Hasher32be2(options) {
              var _this;
              _classCallCheck(this, Hasher32be2);
              _this = _super.call(this, options);
              _this.unitOrder = 1;
              _this.blockUnits = [];
              return _this;
            }
            _createClass(Hasher32be2, [{
              key: "process",
              value: function process2() {
                while (this.state.message.length >= this.blockSizeInBytes) {
                  this.blockUnits = [];
                  for (var b = 0; b < this.blockSizeInBytes; b += 4) {
                    this.blockUnits.push(this.state.message.charCodeAt(b) << 24 | this.state.message.charCodeAt(b + 1) << 16 | this.state.message.charCodeAt(b + 2) << 8 | this.state.message.charCodeAt(b + 3));
                  }
                  this.state.message = this.state.message.substr(this.blockSizeInBytes);
                  this.processBlock(this.blockUnits);
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @param {number[]} M
               */
            }, {
              key: "processBlock",
              value: function processBlock(M) {
              }
              /**
               * Get hash from state
               *
               * @protected
               * @param {number} [size=this.state.hash.length] - Limit hash size (in chunks)
               * @returns {string}
               */
            }, {
              key: "getStateHash",
              value: function getStateHash(size) {
                size = size || this.state.hash.length;
                var hash = "";
                for (var i = 0; i < size; i++) {
                  hash += String.fromCharCode(this.state.hash[i] >> 24 & 255) + String.fromCharCode(this.state.hash[i] >> 16 & 255) + String.fromCharCode(this.state.hash[i] >> 8 & 255) + String.fromCharCode(this.state.hash[i] & 255);
                }
                return hash;
              }
              /**
               * Add to message cumulative size of message in bits
               *
               * @protected
               */
            }, {
              key: "addLengthBits",
              value: function addLengthBits() {
                this.state.message += "\0\0\0" + String.fromCharCode(this.state.length >> 29 & 255) + String.fromCharCode(this.state.length >> 21 & 255) + String.fromCharCode(this.state.length >> 13 & 255) + String.fromCharCode(this.state.length >> 5 & 255) + String.fromCharCode(this.state.length << 3 & 255);
              }
            }]);
            return Hasher32be2;
          }(_hasher__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Hasher32be;
        },
        /* 4 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          var Hasher = function() {
            function Hasher2(options) {
              _classCallCheck(this, Hasher2);
              this.unitSize = 4;
              this.unitOrder = 0;
              this.blockSize = 16;
              this.blockSizeInBytes = this.blockSize * this.unitSize;
              this.options = options || {};
              this.reset();
            }
            _createClass(Hasher2, [{
              key: "reset",
              value: function reset() {
                this.state = {};
                this.state.message = "";
                this.state.length = 0;
              }
              /**
               * Return current state
               *
               * @returns {Object}
               */
            }, {
              key: "getState",
              value: function getState() {
                return JSON.parse(JSON.stringify(this.state));
              }
              /**
               * Set current state
               *
               * @param {Object} state
               */
            }, {
              key: "setState",
              value: function setState(state) {
                this.state = state;
              }
              /**
               * Update message from binary string
               *
               * @param {string} message
               */
            }, {
              key: "update",
              value: function update(message) {
                this.state.message += message;
                this.state.length += message.length;
                this.process();
              }
              /**
               * Process ready blocks
               *
               * @protected
               */
            }, {
              key: "process",
              value: function process2() {
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                return "";
              }
              /**
               * Get hash from state
               *
               * @protected
               * @param {number} [size=this.state.hash.length] - Limit hash size (in chunks)
               * @returns {string}
               */
            }, {
              key: "getStateHash",
              value: function getStateHash(size) {
                return "";
              }
              /**
               * Add PKCS7 padding to message
               * Pad with bytes all of the same value as the number of padding bytes
               *
               * @protected
               * @param {number} length
               */
            }, {
              key: "addPaddingPKCS7",
              value: function addPaddingPKCS7(length) {
                this.state.message += new Array(length + 1).join(String.fromCharCode(length));
              }
              /**
               * Add ISO7816-4 padding to message
               * Pad with 0x80 followed by zero bytes
               *
               * @protected
               * @param {number} length
               */
            }, {
              key: "addPaddingISO7816",
              value: function addPaddingISO7816(length) {
                this.state.message += "" + new Array(length).join("\0");
              }
              /**
               * Add zero padding to message
               * Pad with 0x00 characters
               *
               * @protected
               * @param {number} length
               */
            }, {
              key: "addPaddingZero",
              value: function addPaddingZero(length) {
                this.state.message += new Array(length + 1).join("\0");
              }
            }]);
            return Hasher2;
          }();
          __webpack_exports__["a"] = Hasher;
        },
        /* 5 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var Hasher32le = function(_Hasher) {
            _inherits(Hasher32le2, _Hasher);
            var _super = _createSuper(Hasher32le2);
            function Hasher32le2(options) {
              var _this;
              _classCallCheck(this, Hasher32le2);
              _this = _super.call(this, options);
              _this.blockUnits = [];
              return _this;
            }
            _createClass(Hasher32le2, [{
              key: "process",
              value: function process2() {
                while (this.state.message.length >= this.blockSizeInBytes) {
                  this.blockUnits = [];
                  for (var b = 0; b < this.blockSizeInBytes; b += 4) {
                    this.blockUnits.push(this.state.message.charCodeAt(b) | this.state.message.charCodeAt(b + 1) << 8 | this.state.message.charCodeAt(b + 2) << 16 | this.state.message.charCodeAt(b + 3) << 24);
                  }
                  this.state.message = this.state.message.substr(this.blockSizeInBytes);
                  this.processBlock(this.blockUnits);
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @param {number[]} M
               */
            }, {
              key: "processBlock",
              value: function processBlock(M) {
              }
              /**
               * Get hash from state
               *
               * @protected
               * @param {number} [size=this.state.hash.length] - Limit hash size (in chunks)
               * @returns {string}
               */
            }, {
              key: "getStateHash",
              value: function getStateHash(size) {
                size = size || this.state.hash.length;
                var hash = "";
                for (var i = 0; i < size; i++) {
                  hash += String.fromCharCode(this.state.hash[i] & 255) + String.fromCharCode(this.state.hash[i] >> 8 & 255) + String.fromCharCode(this.state.hash[i] >> 16 & 255) + String.fromCharCode(this.state.hash[i] >> 24 & 255);
                }
                return hash;
              }
              /**
               * Add to message cumulative size of message in bits
               *
               * @protected
               */
            }, {
              key: "addLengthBits",
              value: function addLengthBits() {
                this.state.message += String.fromCharCode(this.state.length << 3 & 255) + String.fromCharCode(this.state.length >> 5 & 255) + String.fromCharCode(this.state.length >> 13 & 255) + String.fromCharCode(this.state.length >> 21 & 255) + String.fromCharCode(this.state.length >> 29 & 255) + "\0\0\0";
              }
            }]);
            return Hasher32le2;
          }(_hasher__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Hasher32le;
        },
        /* 6 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var K = [1116352408, 3609767458, 1899447441, 602891725, 3049323471, 3964484399, 3921009573, 2173295548, 961987163, 4081628472, 1508970993, 3053834265, 2453635748, 2937671579, 2870763221, 3664609560, 3624381080, 2734883394, 310598401, 1164996542, 607225278, 1323610764, 1426881987, 3590304994, 1925078388, 4068182383, 2162078206, 991336113, 2614888103, 633803317, 3248222580, 3479774868, 3835390401, 2666613458, 4022224774, 944711139, 264347078, 2341262773, 604807628, 2007800933, 770255983, 1495990901, 1249150122, 1856431235, 1555081692, 3175218132, 1996064986, 2198950837, 2554220882, 3999719339, 2821834349, 766784016, 2952996808, 2566594879, 3210313671, 3203337956, 3336571891, 1034457026, 3584528711, 2466948901, 113926993, 3758326383, 338241895, 168717936, 666307205, 1188179964, 773529912, 1546045734, 1294757372, 1522805485, 1396182291, 2643833823, 1695183700, 2343527390, 1986661051, 1014477480, 2177026350, 1206759142, 2456956037, 344077627, 2730485921, 1290863460, 2820302411, 3158454273, 3259730800, 3505952657, 3345764771, 106217008, 3516065817, 3606008344, 3600352804, 1432725776, 4094571909, 1467031594, 275423344, 851169720, 430227734, 3100823752, 506948616, 1363258195, 659060556, 3750685593, 883997877, 3785050280, 958139571, 3318307427, 1322822218, 3812723403, 1537002063, 2003034995, 1747873779, 3602036899, 1955562222, 1575990012, 2024104815, 1125592928, 2227730452, 2716904306, 2361852424, 442776044, 2428436474, 593698344, 2756734187, 3733110249, 3204031479, 2999351573, 3329325298, 3815920427, 3391569614, 3928383900, 3515267271, 566280711, 3940187606, 3454069534, 4118630271, 4000239992, 116418474, 1914138554, 174292421, 2731055270, 289380356, 3203993006, 460393269, 320620315, 685471733, 587496836, 852142971, 1086792851, 1017036298, 365543100, 1126000580, 2618297676, 1288033470, 3409855158, 1501505948, 4234509866, 1607167915, 987167468, 1816402316, 1246189591];
          var Sha512 = function(_Hasher32be) {
            _inherits(Sha5122, _Hasher32be);
            var _super = _createSuper(Sha5122);
            function Sha5122(options) {
              var _this;
              _classCallCheck(this, Sha5122);
              options = options || {};
              options.length = options.length || 512;
              options.rounds = options.rounds || 160;
              _this = _super.call(this, options);
              _this.blockSize = 32;
              _this.blockSizeInBytes = _this.blockSize * _this.unitSize;
              _this.W = new Array(160);
              return _this;
            }
            _createClass(Sha5122, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Sha5122.prototype), "reset", this).call(this);
                switch (this.options.length) {
                  case 384:
                    this.state.hash = [3418070365 | 0, 3238371032 | 0, 1654270250 | 0, 914150663 | 0, 2438529370 | 0, 812702999 | 0, 355462360 | 0, 4144912697 | 0, 1731405415 | 0, 4290775857 | 0, 2394180231 | 0, 1750603025 | 0, 3675008525 | 0, 1694076839 | 0, 1203062813 | 0, 3204075428 | 0];
                    break;
                  case 512:
                    this.state.hash = [1779033703 | 0, 4089235720 | 0, 3144134277 | 0, 2227873595 | 0, 1013904242 | 0, 4271175723 | 0, 2773480762 | 0, 1595750129 | 0, 1359893119 | 0, 2917565137 | 0, 2600822924 | 0, 725511199 | 0, 528734635 | 0, 4215389547 | 0, 1541459225 | 0, 327033209 | 0];
                    break;
                  default:
                    var hasher = new Sha5122();
                    for (var i = 0; i < 16; i++) {
                      hasher.state.hash[i] = hasher.state.hash[i] ^ 2779096485;
                    }
                    hasher.update("SHA-512/" + this.options.length);
                    var hash = hasher.finalize();
                    this.state.hash = [];
                    for (var b = 0; b < 64; b += 4) {
                      this.state.hash.push(hash.charCodeAt(b) << 24 | hash.charCodeAt(b + 1) << 16 | hash.charCodeAt(b + 2) << 8 | hash.charCodeAt(b + 3));
                    }
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                var ah = this.state.hash[0];
                var al = this.state.hash[1];
                var bh = this.state.hash[2];
                var bl = this.state.hash[3];
                var ch = this.state.hash[4];
                var cl = this.state.hash[5];
                var dh = this.state.hash[6];
                var dl = this.state.hash[7];
                var eh = this.state.hash[8];
                var el = this.state.hash[9];
                var fh = this.state.hash[10];
                var fl = this.state.hash[11];
                var gh = this.state.hash[12];
                var gl = this.state.hash[13];
                var hh = this.state.hash[14];
                var hl = this.state.hash[15];
                var s0h, s0l, s1h, s1l;
                for (var i = 0; i < this.options.rounds; i += 2) {
                  if (i < 32) {
                    this.W[i] = block[i];
                    this.W[i + 1] = block[i + 1];
                  } else {
                    s0h = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64hi */
                      "c"
                    ])(this.W[i - 30], this.W[i - 29], 1) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64hi */
                      "c"
                    ])(this.W[i - 30], this.W[i - 29], 8) ^ this.W[i - 30] >>> 7;
                    s0l = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64lo */
                      "d"
                    ])(this.W[i - 30], this.W[i - 29], 1) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64lo */
                      "d"
                    ])(this.W[i - 30], this.W[i - 29], 8) ^ (this.W[i - 29] >>> 7 | this.W[i - 30] << 25);
                    s1h = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64hi */
                      "c"
                    ])(this.W[i - 4], this.W[i - 3], 19) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64hi */
                      "c"
                    ])(this.W[i - 4], this.W[i - 3], 61) ^ this.W[i - 4] >>> 6;
                    s1l = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64lo */
                      "d"
                    ])(this.W[i - 4], this.W[i - 3], 19) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight64lo */
                      "d"
                    ])(this.W[i - 4], this.W[i - 3], 61) ^ (this.W[i - 3] >>> 6 | this.W[i - 4] << 26);
                    var c1 = (this.W[i - 13] & 65535) + (this.W[i - 31] & 65535) + (s0l & 65535) + (s1l & 65535) | 0;
                    var c2 = (this.W[i - 13] >>> 16) + (this.W[i - 31] >>> 16) + (s0l >>> 16) + (s1l >>> 16) + (c1 >>> 16) | 0;
                    var c3 = (this.W[i - 14] & 65535) + (this.W[i - 32] & 65535) + (s0h & 65535) + (s1h & 65535) + (c2 >>> 16) | 0;
                    var c4 = (this.W[i - 14] >>> 16) + (this.W[i - 32] >>> 16) + (s0h >>> 16) + (s1h >>> 16) + (c3 >>> 16) | 0;
                    this.W[i] = (c4 << 16 | c3 & 65535) & 4294967295;
                    this.W[i + 1] = (c2 << 16 | c1 & 65535) & 4294967295;
                  }
                  s0h = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64hi */
                    "c"
                  ])(ah, al, 28) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64hi */
                    "c"
                  ])(ah, al, 34) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64hi */
                    "c"
                  ])(ah, al, 39);
                  s0l = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64lo */
                    "d"
                  ])(ah, al, 28) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64lo */
                    "d"
                  ])(ah, al, 34) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64lo */
                    "d"
                  ])(ah, al, 39);
                  s1h = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64hi */
                    "c"
                  ])(eh, el, 14) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64hi */
                    "c"
                  ])(eh, el, 18) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64hi */
                    "c"
                  ])(eh, el, 41);
                  s1l = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64lo */
                    "d"
                  ])(eh, el, 14) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64lo */
                    "d"
                  ])(eh, el, 18) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight64lo */
                    "d"
                  ])(eh, el, 41);
                  var chh = eh & fh ^ ~eh & gh;
                  var chl = el & fl ^ ~el & gl;
                  var majh = ah & bh ^ ah & ch ^ bh & ch;
                  var majl = al & bl ^ al & cl ^ bl & cl;
                  var t1l = hl + s1l | 0;
                  var t1h = hh + s1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0) | 0;
                  t1l = t1l + chl | 0;
                  t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0) | 0;
                  t1l = t1l + K[i + 1] | 0;
                  t1h = t1h + K[i] + (t1l >>> 0 < K[i + 1] >>> 0 ? 1 : 0) | 0;
                  t1l = t1l + this.W[i + 1] | 0;
                  t1h = t1h + this.W[i] + (t1l >>> 0 < this.W[i + 1] >>> 0 ? 1 : 0) | 0;
                  var t2l = s0l + majl | 0;
                  var t2h = s0h + majh + (t2l >>> 0 < s0l >>> 0 ? 1 : 0) | 0;
                  hh = gh;
                  hl = gl;
                  gh = fh;
                  gl = fl;
                  fh = eh;
                  fl = el;
                  el = dl + t1l | 0;
                  eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                  dh = ch;
                  dl = cl;
                  ch = bh;
                  cl = bl;
                  bh = ah;
                  bl = al;
                  al = t1l + t2l | 0;
                  ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                }
                this.state.hash[1] = this.state.hash[1] + al | 0;
                this.state.hash[0] = this.state.hash[0] + ah + (this.state.hash[1] >>> 0 < al >>> 0 ? 1 : 0) | 0;
                this.state.hash[3] = this.state.hash[3] + bl | 0;
                this.state.hash[2] = this.state.hash[2] + bh + (this.state.hash[3] >>> 0 < bl >>> 0 ? 1 : 0) | 0;
                this.state.hash[5] = this.state.hash[5] + cl | 0;
                this.state.hash[4] = this.state.hash[4] + ch + (this.state.hash[5] >>> 0 < cl >>> 0 ? 1 : 0) | 0;
                this.state.hash[7] = this.state.hash[7] + dl | 0;
                this.state.hash[6] = this.state.hash[6] + dh + (this.state.hash[7] >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                this.state.hash[9] = this.state.hash[9] + el | 0;
                this.state.hash[8] = this.state.hash[8] + eh + (this.state.hash[9] >>> 0 < el >>> 0 ? 1 : 0) | 0;
                this.state.hash[11] = this.state.hash[11] + fl | 0;
                this.state.hash[10] = this.state.hash[10] + fh + (this.state.hash[11] >>> 0 < fl >>> 0 ? 1 : 0) | 0;
                this.state.hash[13] = this.state.hash[13] + gl | 0;
                this.state.hash[12] = this.state.hash[12] + gh + (this.state.hash[13] >>> 0 < gl >>> 0 ? 1 : 0) | 0;
                this.state.hash[15] = this.state.hash[15] + hl | 0;
                this.state.hash[14] = this.state.hash[14] + hh + (this.state.hash[15] >>> 0 < hl >>> 0 ? 1 : 0) | 0;
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 112 ? 112 - this.state.message.length | 0 : 240 - this.state.message.length | 0);
                this.state.message += "\0\0\0\0\0\0\0\0";
                this.addLengthBits();
                this.process();
                return this.getStateHash(this.options.length / 32 | 0);
              }
            }]);
            return Sha5122;
          }(_hasher32be__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Sha512;
        },
        /* 7 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var K = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298];
          var Sha256 = function(_Hasher32be) {
            _inherits(Sha2562, _Hasher32be);
            var _super = _createSuper(Sha2562);
            function Sha2562(options) {
              var _this;
              _classCallCheck(this, Sha2562);
              options = options || {};
              options.length = options.length || 256;
              options.rounds = options.rounds || 64;
              _this = _super.call(this, options);
              _this.W = new Array(64);
              return _this;
            }
            _createClass(Sha2562, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Sha2562.prototype), "reset", this).call(this);
                switch (this.options.length) {
                  case 224:
                    this.state.hash = [3238371032 | 0, 914150663 | 0, 812702999 | 0, 4144912697 | 0, 4290775857 | 0, 1750603025 | 0, 1694076839 | 0, 3204075428 | 0];
                    break;
                  default:
                    this.state.hash = [1779033703 | 0, 3144134277 | 0, 1013904242 | 0, 2773480762 | 0, 1359893119 | 0, 2600822924 | 0, 528734635 | 0, 1541459225 | 0];
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                var a = this.state.hash[0] | 0;
                var b = this.state.hash[1] | 0;
                var c = this.state.hash[2] | 0;
                var d = this.state.hash[3] | 0;
                var e = this.state.hash[4] | 0;
                var f2 = this.state.hash[5] | 0;
                var g = this.state.hash[6] | 0;
                var h = this.state.hash[7] | 0;
                for (var i = 0; i < this.options.rounds; i++) {
                  if (i < 16) {
                    this.W[i] = block[i] | 0;
                  } else {
                    this.W[i] = this.W[i - 16] + (Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight */
                      "b"
                    ])(this.W[i - 15], 7) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight */
                      "b"
                    ])(this.W[i - 15], 18) ^ this.W[i - 15] >>> 3) + this.W[i - 7] + (Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight */
                      "b"
                    ])(this.W[i - 2], 17) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateRight */
                      "b"
                    ])(this.W[i - 2], 19) ^ this.W[i - 2] >>> 10) | 0;
                  }
                  var t1 = h + (Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight */
                    "b"
                  ])(e, 6) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight */
                    "b"
                  ])(e, 11) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight */
                    "b"
                  ])(e, 25)) + (e & f2 ^ ~e & g) + K[i] + this.W[i] | 0;
                  var t2 = (Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight */
                    "b"
                  ])(a, 2) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight */
                    "b"
                  ])(a, 13) ^ Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateRight */
                    "b"
                  ])(a, 22)) + (a & b ^ a & c ^ b & c) | 0;
                  h = g;
                  g = f2;
                  f2 = e;
                  e = d + t1 | 0;
                  d = c;
                  c = b;
                  b = a;
                  a = t1 + t2 | 0;
                }
                this.state.hash[0] = this.state.hash[0] + a | 0;
                this.state.hash[1] = this.state.hash[1] + b | 0;
                this.state.hash[2] = this.state.hash[2] + c | 0;
                this.state.hash[3] = this.state.hash[3] + d | 0;
                this.state.hash[4] = this.state.hash[4] + e | 0;
                this.state.hash[5] = this.state.hash[5] + f2 | 0;
                this.state.hash[6] = this.state.hash[6] + g | 0;
                this.state.hash[7] = this.state.hash[7] + h | 0;
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash(this.options.length / 32 | 0);
              }
            }]);
            return Sha2562;
          }(_hasher32be__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Sha256;
        },
        /* 8 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32le__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var ZL = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13];
          var ZR = [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11];
          var SL = [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6];
          var SR = [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11];
          var Ripemd = function(_Hasher32le) {
            _inherits(Ripemd2, _Hasher32le);
            var _super = _createSuper(Ripemd2);
            function Ripemd2(options) {
              _classCallCheck(this, Ripemd2);
              options = options || {};
              options.length = options.length || 160;
              return _super.call(this, options);
            }
            _createClass(Ripemd2, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Ripemd2.prototype), "reset", this).call(this);
                switch (this.options.length) {
                  case 128:
                    this.state.hash = [1732584193, 4023233417, 2562383102, 271733878];
                    this.processBlock = this.processBlock128;
                    break;
                  case 256:
                    this.state.hash = [1732584193, 4023233417, 2562383102, 271733878, 1985229328, 4275878552, 2309737967, 19088743];
                    this.processBlock = this.processBlock256;
                    break;
                  case 320:
                    this.state.hash = [1732584193, 4023233417, 2562383102, 271733878, 3285377520, 1985229328, 4275878552, 2309737967, 19088743, 1009589775];
                    this.processBlock = this.processBlock320;
                    break;
                  default:
                    this.state.hash = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
                    this.processBlock = this.processBlock160;
                }
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "processBlock128",
              value: (
                /**
                 * Process ready blocks
                 *
                 * @protected
                 * @ignore
                 * @param {number[]} block - Block
                 */
                function processBlock128(block) {
                  var al = this.state.hash[0] | 0;
                  var bl = this.state.hash[1] | 0;
                  var cl = this.state.hash[2] | 0;
                  var dl = this.state.hash[3] | 0;
                  var ar = al;
                  var br = bl;
                  var cr = cl;
                  var dr = dl;
                  for (var i = 0; i < 64; i++) {
                    var _t = al + block[ZL[i]] | 0;
                    _t = _t + Ripemd2.T(i, bl, cl, dl) | 0;
                    _t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateLeft */
                      "a"
                    ])(_t, SL[i]);
                    al = dl;
                    dl = cl;
                    cl = bl;
                    bl = _t;
                    _t = ar + block[ZR[i]] | 0;
                    _t = _t + Ripemd2.T64(i, br, cr, dr) | 0;
                    _t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateLeft */
                      "a"
                    ])(_t, SR[i]);
                    ar = dr;
                    dr = cr;
                    cr = br;
                    br = _t;
                  }
                  var t = this.state.hash[1] + cl + dr | 0;
                  this.state.hash[1] = this.state.hash[2] + dl + ar | 0;
                  this.state.hash[2] = this.state.hash[3] + al + br | 0;
                  this.state.hash[3] = this.state.hash[0] + bl + cr | 0;
                  this.state.hash[0] = t;
                }
              )
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock160",
              value: function processBlock160(block) {
                var al = this.state.hash[0] | 0;
                var bl = this.state.hash[1] | 0;
                var cl = this.state.hash[2] | 0;
                var dl = this.state.hash[3] | 0;
                var el = this.state.hash[4] | 0;
                var ar = al;
                var br = bl;
                var cr = cl;
                var dr = dl;
                var er = el;
                for (var i = 0; i < 80; i++) {
                  var _t2 = al + block[ZL[i]] | 0;
                  _t2 = _t2 + Ripemd2.T(i, bl, cl, dl) | 0;
                  _t2 = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(_t2, SL[i]);
                  _t2 = _t2 + el | 0;
                  al = el;
                  el = dl;
                  dl = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(cl, 10);
                  cl = bl;
                  bl = _t2;
                  _t2 = ar + block[ZR[i]] | 0;
                  _t2 = _t2 + Ripemd2.T80(i, br, cr, dr) | 0;
                  _t2 = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(_t2, SR[i]);
                  _t2 = _t2 + er | 0;
                  ar = er;
                  er = dr;
                  dr = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(cr, 10);
                  cr = br;
                  br = _t2;
                }
                var t = this.state.hash[1] + cl + dr | 0;
                this.state.hash[1] = this.state.hash[2] + dl + er | 0;
                this.state.hash[2] = this.state.hash[3] + el + ar | 0;
                this.state.hash[3] = this.state.hash[4] + al + br | 0;
                this.state.hash[4] = this.state.hash[0] + bl + cr | 0;
                this.state.hash[0] = t;
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock256",
              value: function processBlock256(block) {
                var al = this.state.hash[0] | 0;
                var bl = this.state.hash[1] | 0;
                var cl = this.state.hash[2] | 0;
                var dl = this.state.hash[3] | 0;
                var ar = this.state.hash[4] | 0;
                var br = this.state.hash[5] | 0;
                var cr = this.state.hash[6] | 0;
                var dr = this.state.hash[7] | 0;
                for (var i = 0; i < 64; i += 1) {
                  var t = al + block[ZL[i]] | 0;
                  t = t + Ripemd2.T(i, bl, cl, dl) | 0;
                  t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(t, SL[i]);
                  al = dl;
                  dl = cl;
                  cl = bl;
                  bl = t;
                  t = ar + block[ZR[i]] | 0;
                  t = t + Ripemd2.T64(i, br, cr, dr) | 0;
                  t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(t, SR[i]);
                  ar = dr;
                  dr = cr;
                  cr = br;
                  br = t;
                  switch (i) {
                    case 15:
                      t = al;
                      al = ar;
                      ar = t;
                      break;
                    case 31:
                      t = bl;
                      bl = br;
                      br = t;
                      break;
                    case 47:
                      t = cl;
                      cl = cr;
                      cr = t;
                      break;
                    case 63:
                      t = dl;
                      dl = dr;
                      dr = t;
                      break;
                  }
                }
                this.state.hash[0] = this.state.hash[0] + al | 0;
                this.state.hash[1] = this.state.hash[1] + bl | 0;
                this.state.hash[2] = this.state.hash[2] + cl | 0;
                this.state.hash[3] = this.state.hash[3] + dl | 0;
                this.state.hash[4] = this.state.hash[4] + ar | 0;
                this.state.hash[5] = this.state.hash[5] + br | 0;
                this.state.hash[6] = this.state.hash[6] + cr | 0;
                this.state.hash[7] = this.state.hash[7] + dr | 0;
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock320",
              value: function processBlock320(block) {
                var al = this.state.hash[0] | 0;
                var bl = this.state.hash[1] | 0;
                var cl = this.state.hash[2] | 0;
                var dl = this.state.hash[3] | 0;
                var el = this.state.hash[4] | 0;
                var ar = this.state.hash[5] | 0;
                var br = this.state.hash[6] | 0;
                var cr = this.state.hash[7] | 0;
                var dr = this.state.hash[8] | 0;
                var er = this.state.hash[9] | 0;
                for (var i = 0; i < 80; i += 1) {
                  var t = al + block[ZL[i]] | 0;
                  t = t + Ripemd2.T(i, bl, cl, dl) | 0;
                  t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(t, SL[i]);
                  t = t + el | 0;
                  al = el;
                  el = dl;
                  dl = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(cl, 10);
                  cl = bl;
                  bl = t;
                  t = ar + block[ZR[i]] | 0;
                  t = t + Ripemd2.T80(i, br, cr, dr) | 0;
                  t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(t, SR[i]);
                  t = t + er | 0;
                  ar = er;
                  er = dr;
                  dr = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(cr, 10);
                  cr = br;
                  br = t;
                  switch (i) {
                    case 15:
                      t = bl;
                      bl = br;
                      br = t;
                      break;
                    case 31:
                      t = dl;
                      dl = dr;
                      dr = t;
                      break;
                    case 47:
                      t = al;
                      al = ar;
                      ar = t;
                      break;
                    case 63:
                      t = cl;
                      cl = cr;
                      cr = t;
                      break;
                    case 79:
                      t = el;
                      el = er;
                      er = t;
                      break;
                  }
                }
                this.state.hash[0] = this.state.hash[0] + al | 0;
                this.state.hash[1] = this.state.hash[1] + bl | 0;
                this.state.hash[2] = this.state.hash[2] + cl | 0;
                this.state.hash[3] = this.state.hash[3] + dl | 0;
                this.state.hash[4] = this.state.hash[4] + el | 0;
                this.state.hash[5] = this.state.hash[5] + ar | 0;
                this.state.hash[6] = this.state.hash[6] + br | 0;
                this.state.hash[7] = this.state.hash[7] + cr | 0;
                this.state.hash[8] = this.state.hash[8] + dr | 0;
                this.state.hash[9] = this.state.hash[9] + er | 0;
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }], [{
              key: "F",
              value: function F(x, y, z) {
                return x ^ y ^ z;
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "G",
              value: function G(x, y, z) {
                return x & y | ~x & z;
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "H",
              value: function H(x, y, z) {
                return (x | ~y) ^ z;
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "I",
              value: function I(x, y, z) {
                return x & z | y & ~z;
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "J",
              value: function J(x, y, z) {
                return x ^ (y | ~z);
              }
              /**
               * @private
               * @ignore
               * @param {number} i
               * @param {number} bl
               * @param {number} cl
               * @param {number} dl
               * @returns {number}
               */
            }, {
              key: "T",
              value: function T(i, bl, cl, dl) {
                if (i < 16) {
                  return this.F(bl, cl, dl);
                }
                if (i < 32) {
                  return this.G(bl, cl, dl) + 1518500249 | 0;
                }
                if (i < 48) {
                  return this.H(bl, cl, dl) + 1859775393 | 0;
                }
                if (i < 64) {
                  return this.I(bl, cl, dl) + 2400959708 | 0;
                }
                return this.J(bl, cl, dl) + 2840853838 | 0;
              }
              /**
               * @private
               * @ignore
               * @param {number} i
               * @param {number} br
               * @param {number} cr
               * @param {number} dr
               * @returns {number}
               */
            }, {
              key: "T64",
              value: function T64(i, br, cr, dr) {
                if (i < 16) {
                  return this.I(br, cr, dr) + 1352829926 | 0;
                }
                if (i < 32) {
                  return this.H(br, cr, dr) + 1548603684 | 0;
                }
                if (i < 48) {
                  return this.G(br, cr, dr) + 1836072691 | 0;
                }
                return this.F(br, cr, dr);
              }
              /**
               * @private
               * @ignore
               * @param {number} i
               * @param {number} br
               * @param {number} cr
               * @param {number} dr
               * @returns {number}
               */
            }, {
              key: "T80",
              value: function T80(i, br, cr, dr) {
                if (i < 16) {
                  return this.J(br, cr, dr) + 1352829926 | 0;
                }
                if (i < 32) {
                  return this.I(br, cr, dr) + 1548603684 | 0;
                }
                if (i < 48) {
                  return this.H(br, cr, dr) + 1836072691 | 0;
                }
                if (i < 64) {
                  return this.G(br, cr, dr) + 2053994217 | 0;
                }
                return this.F(br, cr, dr);
              }
            }]);
            return Ripemd2;
          }(_hasher32le__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Ripemd;
        },
        /* 9 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var randTable = [10097, 32533, 76520, 13586, 34673, 54876, 80959, 9117, 39292, 74945, 37542, 4805, 64894, 74296, 24805, 24037, 20636, 10402, 822, 91665, 8422, 68953, 19645, 9303, 23209, 2560, 15953, 34764, 35080, 33606, 99019, 2529, 9376, 70715, 38311, 31165, 88676, 74397, 4436, 27659, 12807, 99970, 80157, 36147, 64032, 36653, 98951, 16877, 12171, 76833, 66065, 74717, 34072, 76850, 36697, 36170, 65813, 39885, 11199, 29170, 31060, 10805, 45571, 82406, 35303, 42614, 86799, 7439, 23403, 9732, 85269, 77602, 2051, 65692, 68665, 74818, 73053, 85247, 18623, 88579, 63573, 32135, 5325, 47048, 90553, 57548, 28468, 28709, 83491, 25624, 73796, 45753, 3529, 64778, 35808, 34282, 60935, 20344, 35273, 88435, 98520, 17767, 14905, 68607, 22109, 40558, 60970, 93433, 50500, 73998, 11805, 5431, 39808, 27732, 50725, 68248, 29405, 24201, 52775, 67851, 83452, 99634, 6288, 98083, 13746, 70078, 18475, 40610, 68711, 77817, 88685, 40200, 86507, 58401, 36766, 67951, 90364, 76493, 29609, 11062, 99594, 67348, 87517, 64969, 91826, 8928, 93785, 61368, 23478, 34113, 65481, 17674, 17468, 50950, 58047, 76974, 73039, 57186, 40218, 16544, 80124, 35635, 17727, 8015, 45318, 22374, 21115, 78253, 14385, 53763, 74350, 99817, 77402, 77214, 43236, 210, 45521, 64237, 96286, 2655, 69916, 26803, 66252, 29148, 36936, 87203, 76621, 13990, 94400, 56418, 9893, 20505, 14225, 68514, 46427, 56788, 96297, 78822, 54382, 14598, 91499, 14523, 68479, 27686, 46162, 83554, 94750, 89923, 37089, 20048, 80336, 94598, 26940, 36858, 70297, 34135, 53140, 33340, 42050, 82341, 44104, 81949, 85157, 47954, 32979, 26575, 57600, 40881, 22222, 6413, 12550, 73742, 11100, 2040, 12860, 74697, 96644, 89439, 28707, 25815, 63606, 49329, 16505, 34484, 40219, 52563, 43651, 77082, 7207, 31790, 61196, 90446, 26457, 47774, 51924, 33729, 65394, 59593, 42582, 60527, 15474, 45266, 95270, 79953, 59367, 83848, 82396, 10118, 33211, 59466, 94557, 28573, 67897, 54387, 54622, 44431, 91190, 42592, 92927, 45973, 42481, 16213, 97344, 8721, 16868, 48767, 3071, 12059, 25701, 46670, 23523, 78317, 73208, 89837, 68935, 91416, 26252, 29663, 5522, 82562, 4493, 52494, 75246, 33824, 45862, 51025, 61962, 79335, 65337, 12472, 549, 97654, 64051, 88159, 96119, 63896, 54692, 82391, 23287, 29529, 35963, 15307, 26898, 9354, 33351, 35462, 77974, 50024, 90103, 39333, 59808, 8391, 45427, 26842, 83609, 49700, 13021, 24892, 78565, 20106, 46058, 85236, 1390, 92286, 77281, 44077, 93910, 83647, 70617, 42941, 32179, 597, 87379, 25241, 5567, 7007, 86743, 17157, 85394, 11838, 69234, 61406, 20117, 45204, 15956, 6e4, 18743, 92423, 97118, 96338, 19565, 41430, 1758, 75379, 40419, 21585, 66674, 36806, 84962, 85207, 45155, 14938, 19476, 7246, 43667, 94543, 59047, 90033, 20826, 69541, 94864, 31994, 36168, 10851, 34888, 81553, 1540, 35456, 5014, 51176, 98086, 24826, 45240, 28404, 44999, 8896, 39094, 73407, 35441, 31880, 33185, 16232, 41941, 50949, 89435, 48581, 88695, 41994, 37548, 73043, 80951, 406, 96382, 70774, 20151, 23387, 25016, 25298, 94624, 61171, 79752, 49140, 71961, 28296, 69861, 2591, 74852, 20539, 387, 59579, 18633, 32537, 98145, 6571, 31010, 24674, 5455, 61427, 77938, 91936, 74029, 43902, 77557, 32270, 97790, 17119, 52527, 58021, 80814, 51748, 54178, 45611, 80993, 37143, 5335, 12969, 56127, 19255, 36040, 90324, 11664, 49883, 52079, 84827, 59381, 71539, 9973, 33440, 88461, 23356, 48324, 77928, 31249, 64710, 2295, 36870, 32307, 57546, 15020, 9994, 69074, 94138, 87637, 91976, 35584, 4401, 10518, 21615, 1848, 76938, 9188, 20097, 32825, 39527, 4220, 86304, 83389, 87374, 64278, 58044, 90045, 85497, 51981, 50654, 94938, 81997, 91870, 76150, 68476, 64659, 73189, 50207, 47677, 26269, 62290, 64464, 27124, 67018, 41361, 82760, 75768, 76490, 20971, 87749, 90429, 12272, 95375, 5871, 93823, 43178, 54016, 44056, 66281, 31003, 682, 27398, 20714, 53295, 7706, 17813, 8358, 69910, 78542, 42785, 13661, 58873, 4618, 97553, 31223, 8420, 28306, 3264, 81333, 10591, 40510, 7893, 32604, 60475, 94119, 1840, 53840, 86233, 81594, 13628, 51215, 90290, 28466, 68795, 77762, 20791, 91757, 53741, 61613, 62269, 50263, 90212, 55781, 76514, 83483, 47055, 89415, 92694, 397, 58391, 12607, 17646, 48949, 72306, 94541, 37408, 77513, 3820, 86864, 29901, 68414, 82774, 51908, 13980, 72893, 55507, 19502, 37174, 69979, 20288, 55210, 29773, 74287, 75251, 65344, 67415, 21818, 59313, 93278, 81757, 5686, 73156, 7082, 85046, 31853, 38452, 51474, 66499, 68107, 23621, 94049, 91345, 42836, 9191, 8007, 45449, 99559, 68331, 62535, 24170, 69777, 12830, 74819, 78142, 43860, 72834, 33713, 48007, 93584, 72869, 51926, 64721, 58303, 29822, 93174, 93972, 85274, 86893, 11303, 22970, 28834, 34137, 73515, 90400, 71148, 43643, 84133, 89640, 44035, 52166, 73852, 70091, 61222, 60561, 62327, 18423, 56732, 16234, 17395, 96131, 10123, 91622, 85496, 57560, 81604, 18880, 65138, 56806, 87648, 85261, 34313, 65861, 45875, 21069, 85644, 47277, 38001, 2176, 81719, 11711, 71602, 92937, 74219, 64049, 65584, 49698, 37402, 96397, 1304, 77586, 56271, 10086, 47324, 62605, 40030, 37438, 97125, 40348, 87083, 31417, 21815, 39250, 75237, 62047, 15501, 29578, 21826, 41134, 47143, 34072, 64638, 85902, 49139, 6441, 3856, 54552, 73135, 42742, 95719, 9035, 85794, 74296, 8789, 88156, 64691, 19202, 7638, 77929, 3061, 18072, 96207, 44156, 23821, 99538, 4713, 66994, 60528, 83441, 7954, 19814, 59175, 20695, 5533, 52139, 61212, 6455, 83596, 35655, 6958, 92983, 5128, 9719, 77433, 53783, 92301, 50498, 10850, 62746, 99599, 10507, 13499, 6319, 53075, 71839, 6410, 19362, 39820, 98952, 43622, 63147, 64421, 80814, 43800, 9351, 31024, 73167, 59580, 6478, 75569, 78800, 88835, 54486, 23768, 6156, 4111, 8408, 38508, 7341, 23793, 48763, 90822, 97022, 17719, 4207, 95954, 49953, 30692, 70668, 94688, 16127, 56196, 80091, 82067, 63400, 5462, 69200, 65443, 95659, 18288, 27437, 49632, 24041, 8337, 65676, 96299, 90836, 27267, 50264, 13192, 72294, 7477, 44606, 17985, 48911, 97341, 30358, 91307, 6991, 19072, 24210, 36699, 53728, 28825, 35793, 28976, 66252, 68434, 94688, 84473, 13622, 62126, 98408, 12843, 82590, 9815, 93146, 48908, 15877, 54745, 24591, 35700, 4754, 83824, 52692, 54130, 55160, 6913, 45197, 42672, 78601, 11883, 9528, 63011, 98901, 14974, 40344, 10455, 16019, 14210, 33712, 91342, 37821, 88325, 80851, 43667, 70883, 12883, 97343, 65027, 61184, 4285, 1392, 17974, 15077, 90712, 26769, 21778, 30976, 38807, 36961, 31649, 42096, 63281, 2023, 8816, 47449, 19523, 59515, 65122, 59659, 86283, 68258, 69572, 13798, 16435, 91529, 67245, 52670, 35583, 16563, 79246, 86686, 76463, 34222, 26655, 90802, 60584, 47377, 7500, 37992, 45134, 26529, 26760, 83637, 41326, 44344, 53853, 41377, 36066, 94850, 58838, 73859, 49364, 73331, 96240, 43642, 24637, 38736, 74384, 89342, 52623, 7992, 12369, 18601, 3742, 83873, 83080, 12451, 38992, 22815, 7759, 51777, 97377, 27585, 51972, 37867, 16444, 24334, 36151, 99073, 27493, 70939, 85130, 32552, 54846, 54759, 60790, 18157, 57178, 65762, 11161, 78576, 45819, 52979, 65130, 4860, 3991, 10461, 93716, 16894, 66083, 24653, 84609, 58232, 88618, 19161, 38555, 95554, 32886, 59780, 8355, 60860, 29735, 47762, 71299, 23853, 17546, 73704, 92052, 46215, 55121, 29281, 59076, 7936, 27954, 58909, 32643, 52861, 95819, 6831, 911, 98936, 76355, 93779, 80863, 514, 69572, 68777, 39510, 35905, 14060, 40619, 29549, 69616, 33564, 60780, 24122, 66591, 27699, 6494, 14845, 46672, 61958, 77100, 90899, 75754, 61196, 30231, 92962, 61773, 41839, 55382, 17267, 70943, 78038, 70267, 30532, 21704, 10274, 12202, 39685, 23309, 10061, 68829, 55986, 66485, 3788, 97599, 75867, 20717, 74416, 53166, 35208, 33374, 87539, 8823, 48228, 63379, 85783, 47619, 53152, 67433, 35663, 52972, 16818, 60311, 60365, 94653, 35075, 33949, 42614, 29297, 1918, 28316, 98953, 73231, 83799, 42402, 56623, 34442, 34994, 41374, 70071, 14736, 9958, 18065, 32960, 7405, 36409, 83232, 99385, 41600, 11133, 7586, 15917, 6253, 19322, 53845, 57620, 52606, 66497, 68646, 78138, 66559, 19640, 99413, 11220, 94747, 7399, 37408, 48509, 23929, 27482, 45476, 85244, 35159, 31751, 57260, 68980, 5339, 15470, 48355, 88651, 22596, 3152, 19121, 88492, 99382, 14454, 4504, 20094, 98977, 74843, 93413, 22109, 78508, 30934, 47744, 7481, 83828, 73788, 6533, 28597, 20405, 94205, 20380, 22888, 48893, 27499, 98748, 60530, 45128, 74022, 84617, 82037, 10268, 78212, 16993, 35902, 91386, 44372, 15486, 65741, 14014, 87481, 37220, 41849, 84547, 46850, 52326, 34677, 58300, 74910, 64345, 19325, 81549, 46352, 33049, 69248, 93460, 45305, 7521, 61318, 31855, 14413, 70951, 11087, 96294, 14013, 31792, 59747, 67277, 76503, 34513, 39663, 77544, 52701, 8337, 56303, 87315, 16520, 69676, 11654, 99893, 2181, 68161, 57275, 36898, 81304, 48585, 68652, 27376, 92852, 55866, 88448, 3584, 20857, 73156, 70284, 24326, 79375, 95220, 1159, 63267, 10622, 48391, 15633, 84924, 90415, 93614, 33521, 26665, 55823, 47641, 86225, 31704, 92694, 48297, 39904, 2115, 59589, 49067, 66821, 41575, 49767, 4037, 77613, 19019, 88152, 80, 20554, 91409, 96277, 48257, 50816, 97616, 38688, 32486, 45134, 63545, 59404, 72059, 43947, 51680, 43852, 59693, 25163, 1889, 70014, 15021, 41290, 67312, 71857, 15957, 68971, 11403, 65251, 7629, 37239, 33295, 5870, 1119, 92784, 26340, 18477, 65622, 36815, 43625, 18637, 37509, 82444, 99005, 4921, 73701, 14707, 93997, 64397, 11692, 5327, 82162, 20247, 81759, 45197, 25332, 83745, 22567, 4515, 25624, 95096, 67946, 48460, 85558, 15191, 18782, 16930, 33361, 83761, 60873, 43253, 84145, 60833, 25983, 1291, 41349, 20368, 7126, 14387, 6345, 80854, 9279, 43529, 6318, 38384, 74761, 41196, 37480, 51321, 92246, 80088, 77074, 88722, 56736, 66164, 49431, 66919, 31678, 72472, 8, 80890, 18002, 94813, 31900, 54155, 83436, 35352, 54131, 5466, 55306, 93128, 18464, 74457, 90561, 72848, 11834, 79982, 68416, 39528, 72484, 82474, 25593, 48545, 35247, 18619, 13674, 18611, 19241, 81616, 18711, 53342, 44276, 75122, 11724, 74627, 73707, 58319, 15997, 7586, 16120, 82641, 22820, 92904, 13141, 32392, 19763, 61199, 67940, 90767, 4235, 13574, 17200, 69902, 63742, 78464, 22501, 18627, 90872, 40188, 28193, 29593, 88627, 94972, 11598, 62095, 36787, 441, 58997, 34414, 82157, 86887, 55087, 19152, 23, 12302, 80783, 32624, 68691, 63439, 75363, 44989, 16822, 36024, 867, 76378, 41605, 65961, 73488, 67049, 9070, 93399, 45547, 94458, 74284, 5041, 49807, 20288, 34060, 79495, 4146, 52162, 90286, 54158, 34243, 46978, 35482, 59362, 95938, 91704, 30552, 4737, 21031, 75051, 93029, 47665, 64382, 99782, 93478, 94015, 46874, 32444, 48277, 59820, 96163, 64654, 25843, 41145, 42820, 74108, 88222, 88570, 74015, 25704, 91035, 1755, 14750, 48968, 38603, 62880, 87873, 95160, 59221, 22304, 90314, 72877, 17334, 39283, 4149, 11748, 12102, 80580, 41867, 17710, 59621, 6554, 7850, 73950, 79552, 17944, 5600, 60478, 3343, 25852, 58905, 57216, 39618, 49856, 99326, 66067, 42792, 95043, 52680, 46780, 56487, 9971, 59481, 37006, 22186, 54244, 91030, 45547, 70818, 59849, 96169, 61459, 21647, 87417, 17198, 30945, 57589, 31732, 57260, 47670, 7654, 46376, 25366, 94746, 49580, 69170, 37403, 86995, 90307, 94304, 71803, 26825, 5511, 12459, 91314, 8345, 88975, 35841, 85771, 8105, 59987, 87112, 21476, 14713, 71181, 27767, 43584, 85301, 88977, 29490, 69714, 73035, 41207, 74699, 9310, 13025, 14338, 54066, 15243, 47724, 66733, 47431, 43905, 31048, 56699, 80217, 36292, 98525, 24335, 24432, 24896, 43277, 58874, 11466, 16082, 10875, 62004, 90391, 61105, 57411, 6368, 53856, 30743, 8670, 84741, 54127, 57326, 26629, 19087, 24472, 88779, 30540, 27886, 61732, 75454, 60311, 42824, 37301, 42678, 45990, 43242, 17374, 52003, 70707, 70214, 49739, 71484, 92003, 98086, 76668, 73209, 59202, 11973, 2902, 33250, 78626, 51594, 16453, 94614, 39014, 97066, 83012, 9832, 25571, 77628, 66692, 13986, 99837, 582, 81232, 44987, 9504, 96412, 90193, 79568, 44071, 28091, 7362, 97703, 76447, 42537, 98524, 97831, 65704, 9514, 41468, 85149, 49554, 17994, 14924, 39650, 95294, 556, 70481, 6905, 94559, 37559, 49678, 53119, 70312, 5682, 66986, 34099, 74474, 20740, 41615, 70360, 64114, 58660, 90850, 64618, 80620, 51790, 11436, 38072, 50273, 93113, 41794, 86861, 24781, 89683, 55411, 85667, 77535, 99892, 41396, 80504, 90670, 8289, 40902, 5069, 95083, 6783, 28102, 57816, 25807, 24260, 71529, 78920, 72682, 7385, 90726, 57166, 98884, 8583, 6170, 97965, 88302, 98041, 21443, 41808, 68984, 83620, 89747, 98882, 60808, 54444, 74412, 81105, 1176, 28838, 36421, 16489, 18059, 51061, 80940, 44893, 10408, 36222, 80582, 71944, 92638, 40333, 67054, 16067, 19516, 90120, 46759, 71643, 13177, 55292, 21036, 82808, 77501, 97427, 49386, 54480, 23604, 23554, 21785, 41101, 91178, 10174, 29420, 90438, 6312, 88940, 15995, 69321, 47458, 64809, 98189, 81851, 29651, 84215, 60942, 307, 11897, 92674, 40405, 68032, 96717, 54244, 10701, 41393, 92329, 98932, 78284, 46347, 71209, 92061, 39448, 93136, 25722, 8564, 77936, 63574, 31384, 51924, 85561, 29671, 58137, 17820, 22751, 36518, 38101, 77756, 11657, 13897, 95889, 57067, 47648, 13885, 70669, 93406, 39641, 69457, 91339, 22502, 92613, 89719, 11947, 56203, 19324, 20504, 84054, 40455, 99396, 63680, 67667, 60631, 69181, 96845, 38525, 11600, 47468, 3577, 57649, 63266, 24700, 71594, 14004, 23153, 69249, 5747, 43321, 31370, 28977, 23896, 76479, 68562, 62342, 7589, 8899, 5985, 64281, 61826, 18555, 64937, 13173, 33365, 78851, 16499, 87064, 13075, 66847, 70495, 32350, 2985, 86716, 38746, 26313, 77463, 55387, 72681, 72461, 33230, 21529, 53424, 92581, 2262, 78438, 66276, 18396, 73538, 21032, 91050, 13058, 16218, 12470, 56500, 15292, 76139, 59526, 52113, 95362, 67011, 6651, 16136, 1016, 857, 55018, 56374, 35824, 71708, 49712, 97380, 10404, 55452, 34030, 60726, 75211, 10271, 36633, 68424, 58275, 61764, 97586, 54716, 50259, 46345, 87195, 46092, 26787, 60939, 89514, 11788, 68224, 23417, 73959, 76145, 30342, 40277, 11049, 72049, 15472, 50669, 48139, 36732, 46874, 37088, 73465, 9819, 58869, 35220, 12120, 86124, 51247, 44302, 60883, 52109, 21437, 36786, 49226, 77837, 19612, 78430, 11661, 94770, 77603, 65669, 86868, 12665, 30012, 75989, 39141, 77400, 28e3, 64238, 73258, 71794, 31340, 26256, 66453, 37016, 64756, 80457, 8747, 12836, 3469, 50678, 3274, 43423, 66677, 82556, 92901, 51878, 56441, 22998, 29718, 38447, 6453, 25311, 7565, 53771, 3551, 90070, 9483, 94050, 45938, 18135, 36908, 43321, 11073, 51803, 98884, 66209, 6830, 53656, 14663, 56346, 71430, 4909, 19818, 5707, 27369, 86882, 53473, 7541, 53633, 70863, 3748, 12822, 19360, 49088, 59066, 75974, 63335, 20483, 43514, 37481, 58278, 26967, 49325, 43951, 91647, 93783, 64169, 49022, 98588, 9495, 49829, 59068, 38831, 4838, 83605, 92419, 39542, 7772, 71568, 75673, 35185, 89759, 44901, 74291, 24895, 88530, 70774, 35439, 46758, 70472, 70207, 92675, 91623, 61275, 35720, 26556, 95596, 20094, 73750, 85788, 34264, 1703, 46833, 65248, 14141, 53410, 38649, 6343, 57256, 61342, 72709, 75318, 90379, 37562, 27416, 75670, 92176, 72535, 93119, 56077, 6886, 18244, 92344, 31374, 82071, 7429, 81007, 47749, 40744, 56974, 23336, 88821, 53841, 10536, 21445, 82793, 24831, 93241, 14199, 76268, 70883, 68002, 3829, 17443, 72513, 76400, 52225, 92348, 62308, 98481, 29744, 33165, 33141, 61020, 71479, 45027, 76160, 57411, 13780, 13632, 52308, 77762, 88874, 33697, 83210, 51466, 9088, 50395, 26743, 5306, 21706, 70001, 99439, 80767, 68749, 95148, 94897, 78636, 96750, 9024, 94538, 91143, 96693, 61886, 5184, 75763, 47075, 88158, 5313, 53439, 14908, 8830, 60096, 21551, 13651, 62546, 96892, 25240, 47511, 58483, 87342, 78818, 7855, 39269, 566, 21220, 292, 24069, 25072, 29519, 52548, 54091, 21282, 21296, 50958, 17695, 58072, 68990, 60329, 95955, 71586, 63417, 35947, 67807, 57621, 64547, 46850, 37981, 38527, 9037, 64756, 3324, 4986, 83666, 9282, 25844, 79139, 78435, 35428, 43561, 69799, 63314, 12991, 93516, 23394, 94206, 93432, 37836, 94919, 26846, 2555, 74410, 94915, 48199, 5280, 37470, 93622, 4345, 15092, 19510, 18094, 16613, 78234, 50001, 95491, 97976, 38306, 32192, 82639, 54624, 72434, 92606, 23191, 74693, 78521, 104, 18248, 75583, 90326, 50785, 54034, 66251, 35774, 14692, 96345, 44579, 85932, 44053, 75704, 20840, 86583, 83944, 52456, 73766, 77963, 31151, 32364, 91691, 47357, 40338, 23435, 24065, 8458, 95366, 7520, 11294, 23238, 1748, 41690, 67328, 54814, 37777, 10057, 42332, 38423, 2309, 70703, 85736, 46148, 14258, 29236, 12152, 5088, 65825, 2463, 65533, 21199, 60555, 33928, 1817, 7396, 89215, 30722, 22102, 15880, 92261, 17292, 88190, 61781, 48898, 92525, 21283, 88581, 60098, 71926, 819, 59144, 224, 30570, 90194, 18329, 6999, 26857, 19238, 64425, 28108, 16554, 16016, 42, 83229, 10333, 36168, 65617, 94834, 79782, 23924, 49440, 30432, 81077, 31543, 95216, 64865, 13658, 51081, 35337, 74538, 44553, 64672, 90960, 41849, 93865, 44608, 93176, 34851, 5249, 29329, 19715, 94082, 14738, 86667, 43708, 66354, 93692, 25527, 56463, 99380, 38793, 85774, 19056, 13939, 46062, 27647, 66146, 63210, 96296, 33121, 54196, 34108, 75814, 85986, 71171, 15102, 28992, 63165, 98380, 36269, 60014, 7201, 62448, 46385, 42175, 88350, 46182, 49126, 52567, 64350, 16315, 53969, 80395, 81114, 54358, 64578, 47269, 15747, 78498, 90830, 25955, 99236, 43286, 91064, 99969, 95144, 64424, 77377, 49553, 24241, 8150, 89535, 8703, 91041, 77323, 81079, 45127, 93686, 32151, 7075, 83155, 10252, 73100, 88618, 23891, 87418, 45417, 20268, 11314, 50363, 26860, 27799, 49416, 83534, 19187, 8059, 76677, 2110, 12364, 71210, 87052, 50241, 90785, 97889, 81399, 58130, 64439, 5614, 59467, 58309, 87834, 57213, 37510, 33689, 1259, 62486, 56320, 46265, 73452, 17619, 56421, 40725, 23439, 41701, 93223, 41682, 45026, 47505, 27635, 56293, 91700, 4391, 67317, 89604, 73020, 69853, 61517, 51207, 86040, 2596, 1655, 9918, 45161, 222, 54577, 74821, 47335, 8582, 52403, 94255, 26351, 46527, 68224, 90183, 85057, 72310, 34963, 83462, 49465, 46581, 61499, 4844, 94626, 2963, 41482, 83879, 44942, 63915, 94365, 92560, 12363, 30246, 2086, 75036, 88620, 91088, 67691, 67762, 34261, 8769, 91830, 23313, 18256, 28850, 37639, 92748, 57791, 71328, 37110, 66538, 39318, 15626, 44324, 82827, 8782, 65960, 58167, 1305, 83950, 45424, 72453, 19444, 68219, 64733, 94088, 62006, 89985, 36936, 61630, 97966, 76537, 46467, 30942, 7479, 67971, 14558, 22458, 35148, 1929, 17165, 12037, 74558, 16250, 71750, 55546, 29693, 94984, 37782, 41659, 39098, 23982, 29899, 71594, 77979, 54477, 13764, 17315, 72893, 32031, 39608, 75992, 73445, 1317, 50525, 87313, 45191, 30214, 19769, 90043, 93478, 58044, 6949, 31176, 88370, 50274, 83987, 45316, 38551, 79418, 14322, 91065, 7841, 36130, 86602, 10659, 40859, 964, 71577, 85447, 61079, 96910, 72906, 7361, 84338, 34114, 52096, 66715, 51091, 86219, 81115, 49625, 48799, 89485, 24855, 13684, 68433, 70595, 70102, 71712, 88559, 92476, 32903, 68009, 58417, 87962, 11787, 16644, 72964, 29776, 63075, 13270, 84758, 49560, 10317, 28778, 23006, 31036, 84906, 81488, 17340, 74154, 42801, 27917, 89792, 62604, 62234, 13124, 76471, 51667, 37589, 87147, 24743, 48023, 6325, 79794, 35889, 13255, 4925, 99004, 70322, 60832, 76636, 56907, 56534, 72615, 46288, 36788, 93196, 68656, 66492, 35933, 52293, 47953, 95495, 95304, 50009, 83464, 28608, 38074, 74083, 9337, 7965, 65047, 36871, 59015, 21769, 30398, 44855, 1020, 80680, 59328, 8712, 48190, 45332, 27284, 31287, 66011, 9376, 86379, 74508, 33579, 77114, 92955, 23085, 92824, 3054, 25242, 16322, 48498, 9938, 44420, 13484, 52319, 58875, 2012, 88591, 52500, 95795, 41800, 95363, 54142, 17482, 32705, 60564, 12505, 40954, 46174, 64130, 63026, 96712, 79883, 39225, 52653, 69549, 36693, 59822, 22684, 31661, 88298, 15489, 16030, 42480, 15372, 38781, 71995, 77438, 91161, 10192, 7839, 62735, 99218, 25624, 2547, 27445, 69187, 55749, 32322, 15504, 73298, 51108, 48717, 92926, 75705, 89787, 96114, 99902, 37749, 96305, 12829, 70474, 838, 50385, 91711, 80370, 56504, 56857, 80906, 9018, 76569, 61072, 48568, 36491, 22587, 44363, 39592, 61546, 90181, 37348, 41665, 41339, 62106, 44203, 6732, 76111, 79840, 67999, 32231, 76869, 58652, 49983, 1669, 27464, 79553, 52855, 25988, 18087, 38052, 17529, 13607, 657, 76173, 43357, 77334, 24140, 53860, 2906, 89863, 44651, 55715, 26203, 65933, 51087, 98234, 40625, 45545, 63563, 89148, 82581, 4110, 66683, 99001, 9796, 47349, 65003, 66524, 81970, 71262, 14479, 31300, 8681, 58068, 44115, 40064, 77879, 23965, 69019, 73985, 19453, 26225, 97543, 37044, 7494, 85778, 35345, 61115, 92498, 49737, 64599, 7158, 82763, 25072, 38478, 57782, 75291, 62155, 52056, 4786, 11585, 71251, 25572, 79771, 93328, 66927, 54069, 58752, 26624, 50463, 77361, 29991, 96526, 2820, 91659, 12818, 96356, 49499, 1507, 40223, 9171, 83642, 21057, 2677, 9367, 38097, 16100, 19355, 6120, 15378, 56559, 69167, 30235, 6767, 66323, 78294, 14916, 19124, 88044, 16673, 66102, 86018, 29406, 75415, 22038, 27056, 26906, 25867, 14751, 92380, 30434, 44114, 6026, 79553, 55091, 95385, 41212, 37882, 46864, 54717, 97038, 53805, 64150, 70915, 63127, 63695, 41288, 38192, 72437, 75075, 18570, 52065, 8853, 30104, 79937, 66913, 53200, 84570, 78079, 28970, 53859, 37632, 80274, 35240, 32960, 74859, 7359, 55176, 3930, 38984, 35151, 82576, 82805, 94031, 12779, 90879, 24109, 25367, 77861, 9541, 85739, 69023, 64971, 99321, 7521, 95909, 43897, 71724, 92581, 5471, 64337, 98949, 3606, 78236, 78985, 29212, 57369, 34857, 67757, 58019, 58872, 96526, 28749, 56592, 37871, 72905, 70198, 57319, 54116, 47014, 18285, 33692, 72111, 60958, 96848, 17893, 40993, 50445, 14186, 76877, 87867, 50335, 9513, 44346, 26439, 55293, 6449, 44301, 63740, 40158, 72703, 88321, 85062, 57345, 66231, 15409, 3451, 95261, 43561, 15673, 28956, 90303, 62469, 82517, 43035, 36850, 15592, 64098, 59022, 31752, 4370, 50486, 11885, 23085, 41712, 80692, 48492, 16495, 99721, 36912, 28267, 27882, 16269, 64483, 11273, 2680, 1616, 46138, 54606, 14761, 5134, 45144, 63213, 49666, 27441, 86989, 29884, 54334, 6740, 8368, 80051, 81020, 17882, 74973, 74531, 94994, 24927, 64894, 22667, 20466, 82948, 66831, 47427, 76033, 31197, 59817, 20064, 61135, 28556, 29695, 80179, 74058, 18293, 9963, 35278, 13062, 83094, 23373, 90287, 33477, 48865, 30348, 70174, 11468, 25994, 25343, 22317, 1587, 30682, 1, 67814, 59557, 23362, 13746, 82244, 42093, 24671, 79458, 93730, 45488, 60234, 67098, 9899, 25775, 332, 36636, 57594, 19958, 85564, 58977, 12247, 60774, 66371, 69442, 20385, 14486, 91330, 50332, 46023, 75768, 59877, 60081, 92936, 72302, 75064, 85727, 52987, 5750, 19384, 33684, 78859, 80458, 69902, 34870, 88684, 49762, 40801, 86291, 18194, 90366, 82639, 53844, 96326, 65728, 48563, 26027, 52692, 62406, 76294, 41848, 63010, 69841, 29451, 36170, 21529, 16525, 64326, 22086, 24469, 57407, 96033, 37771, 31002, 18311, 93285, 31948, 14331, 58335, 15977, 80336, 81667, 27286, 24361, 61638, 57580, 95270, 46180, 76990, 53031, 94366, 2727, 49944, 19278, 5756, 51875, 53445, 33342, 1965, 7937, 10054, 97712, 87693, 58124, 46064, 39133, 77385, 9605, 65359, 70113, 90563, 86637, 94282, 12025, 31926, 24541, 23854, 58407, 32131, 92845, 20714, 27898, 26917, 50326, 35145, 50859, 72119, 95094, 29441, 42301, 62460, 75252, 94267, 38422, 73047, 24200, 85349, 72049, 91723, 97802, 98496, 12734, 73432, 10371, 57213, 53300, 80847, 46229, 7099, 72961, 13767, 65654, 31102, 82119, 96946, 65919, 81083, 3819, 57888, 57908, 16849, 77111, 41429, 92261, 45263, 1172, 55926, 78835, 27697, 48420, 58865, 41207, 21406, 8582, 10785, 36233, 12237, 7866, 13706, 92551, 11021, 63813, 71512, 65206, 37768, 94325, 14721, 20990, 54235, 71986, 5345, 56239, 52028, 1419, 7215, 55067, 11669, 21738, 66605, 69621, 69827, 8537, 18638, 60982, 28151, 98885, 76431, 25566, 3085, 23639, 30849, 63986, 73287, 26201, 36174, 14106, 54102, 57041, 16141, 64174, 3591, 90024, 73332, 31254, 17288, 59809, 25061, 51612, 47951, 16570, 43330, 79213, 11354, 55585, 19646, 99246, 37564, 32660, 20632, 21124, 60597, 69315, 31312, 57741, 85108, 21615, 24365, 27684, 16124, 33888, 14966, 35303, 69921, 15795, 4020, 67672, 86816, 63027, 84470, 45605, 44887, 26222, 79888, 58982, 22466, 98844, 48353, 60666, 58256, 31140, 93507, 69561, 6256, 88526, 18655, 865, 75247, 264, 65957, 98261, 72706, 36396, 46065, 85700, 32121, 99975, 73627, 78812, 89638, 86602, 96758, 65099, 52777, 46792, 13790, 55240, 52002, 10313, 91933, 71231, 10053, 78416, 54563, 96004, 42215, 30094, 45958, 48437, 49591, 50483, 13422, 69108, 59952, 27896, 40450, 79327, 31962, 46456, 39260, 51479, 61882, 48181, 50691, 64709, 32902, 10676, 12083, 35771, 79656, 56667, 76783, 3937, 99859, 10362, 57411, 40986, 35045, 2838, 29255, 64230, 84418, 34988, 77644, 39892, 77327, 74129, 53444, 35487, 95803, 38640, 20383, 55402, 25793, 14213, 87082, 42837, 95030, 97198, 61608, 97723, 79390, 35290, 34683, 81419, 87133, 70447, 53127, 97146, 28299, 56763, 12868, 1145, 12147, 58158, 92124, 60934, 18414, 97510, 7056, 54488, 20719, 53743, 91037, 44797, 52110, 8512, 18991, 20129, 31441, 51449, 14661, 71126, 23180, 68124, 18807, 70997, 21913, 19594, 70355, 73637, 68266, 60775, 43164, 52643, 96363, 77989, 79332, 39890, 65379, 20405, 52935, 43816, 92740, 95319, 4538, 60660, 28982, 15328, 80475, 34690, 2293, 19646, 46524, 96627, 33159, 42081, 8816, 74931, 20674, 8697, 66169, 46460, 46326, 39923, 60625, 28386, 22919, 19415, 75766, 43668, 31626, 70301, 67053, 3949, 70082, 2303, 48642, 38429, 94053, 38770, 68137, 68441, 52928, 70244, 91954, 17401, 92693, 98342, 21451, 84988, 80487, 33807, 73797, 49494, 41878, 76635, 83227, 76618, 11946, 13451, 87591, 78381, 21407, 90038, 72638, 69692, 51599, 86413, 32019, 64856, 74730, 41531, 11064, 1790, 58817, 86400, 66213, 92599, 70905, 78324, 54326, 43659, 34206, 63132, 38837, 40210, 96346, 16967, 81619, 96503, 14881, 89405, 32205, 49508, 98425, 2451, 35423, 56072, 36810, 30332, 85998, 49358, 92748, 84147, 79835, 94867, 41224, 61794, 35066, 82220, 66684, 20096, 2754, 41731, 37068, 32753, 91059, 13407, 5607, 69384, 53329, 95909, 44968, 11397, 92973, 50014, 92997, 80968, 93761, 57598, 74703, 7768, 37978, 73873, 33475, 9720, 97852, 98449, 48722, 84977, 11271, 11728, 68318, 22312, 78792, 87508, 88466, 72976, 47099, 84126, 38595, 85124, 64405, 90020, 7492, 52413, 95111, 34455, 86311, 68892, 1074, 60274, 28136, 19328, 38161, 57475, 13771, 63562, 84207, 94121, 18901, 52768, 33801, 82087, 86091, 59969, 90398, 56870, 55756, 78841, 98450, 54165, 55106, 50343, 70519, 14567, 36780, 55450, 19606, 83749, 67562, 64765, 38543, 16585, 86841, 73742, 8766, 39252, 75678, 75379, 78760, 37279, 15280, 13558, 95916, 89759, 76686, 76467, 67147, 63110, 94008, 8037, 35263, 53710, 16667, 79008, 11231, 29397, 67136, 18601, 64502, 90228, 89109, 72849, 22711, 65547, 34542, 26686, 81678, 87765, 77654, 23664, 96352, 14106, 32938, 28083, 18633, 80286, 65507, 46197, 52722, 75476, 77816, 47204, 34876, 45963, 79262, 90181, 84041, 3745, 90041, 30780, 27226, 92847, 85572, 15308, 80688, 5761, 82638, 13464, 23683, 81015, 54214, 64175, 43701, 86845, 15569, 50687, 52679, 87696, 8285, 97444, 47599, 94472, 64150, 87753, 68652, 60726, 26213, 17320, 64553, 81285, 98126, 12158, 52095, 64833, 492, 35817, 55571, 91300, 97812, 37507, 4209, 53515, 64342, 21223, 16662, 43265, 68219, 3529, 43636, 68417, 53640, 95326, 93381, 37113, 80751, 76469, 96677, 43054, 22937, 31954, 13266, 34140, 27253, 2734, 99070, 60077, 57988, 93211, 92795, 83795, 57477, 3941, 39007, 14619, 38320, 93449, 31336, 25279, 97030, 26245, 47394, 39475, 90621, 23820, 29344, 94859, 91604, 14033, 41868, 14816, 4075, 66644, 87803, 97815, 99552, 78666, 3942, 8175, 22345, 19983, 76783, 99044, 20851, 84981, 59052, 77178, 72109, 76475, 21619, 73017, 6812, 56633, 50612, 55289, 4671, 84419, 94072, 94446, 80603, 32188, 93415, 23464, 43947, 43728, 74284, 67177, 57105, 31059, 10642, 13803, 69602, 46961, 66567, 19359, 84676, 63918, 40650, 12923, 15974, 79732, 20225, 92525, 71179, 4859, 91208, 60430, 5239, 61458, 24089, 68852, 60171, 29603, 42535, 86365, 93905, 28237, 45317, 60718, 82001, 41679, 20679, 56304, 70043, 87568, 21386, 59049, 78353, 48696, 77379, 55309, 23780, 28391, 5940, 55583, 81256, 59418, 97521, 32846, 70761, 90115, 45325, 5490, 65974, 11186, 15357, 3568, 450, 96644, 58976, 36211, 88240, 92457, 89200, 94696, 11370, 91157, 48487, 59501, 56983, 89795, 42789, 69758, 79701, 29511, 55968, 41472, 89474, 84344, 80517, 7485, 97523, 17264, 82840, 59556, 37119, 30985, 48866, 60605, 95719, 70417, 59083, 95137, 76538, 44155, 67286, 57897, 28262, 4052, 919, 86207, 79932, 44236, 10089, 44373, 65670, 44285, 6903, 20834, 49701, 95735, 21149, 3425, 17594, 31427, 14262, 32252, 68540, 39427, 44026, 47257, 45055, 95091, 8367, 28381, 57375, 41562, 83883, 27715, 10122, 67745, 46497, 28626, 87297, 36568, 39483, 11385, 63292, 92305, 78683, 6146, 81905, 15038, 38338, 51206, 65749, 34119, 71516, 74068, 51094, 6665, 91884, 66762, 11428, 70908, 21506, 480, 94183, 78484, 66507, 75901, 25728, 52539, 86806, 69944, 65036, 27882, 2530, 4918, 74351, 65737, 89178, 8791, 39342, 94963, 22581, 56917, 17541, 83578, 75376, 65202, 30935, 79270, 91986, 99286, 45236, 44720, 81915, 70881, 45886, 43213, 49789, 97081, 16075, 20517, 69980, 25310, 91953, 1759, 67635, 88933, 54558, 18395, 73375, 62251, 58871, 9870, 70538, 48936, 7757, 90374, 56631, 88862, 30487, 38794, 36079, 32712, 11130, 55451, 25137, 38785, 83558, 31960, 69473, 45950, 18225, 9871, 88502, 75179, 11551, 75664, 74321, 67351, 27703, 83717, 18913, 42470, 8816, 37627, 14288, 62831, 44047, 67612, 72738, 26995, 50933, 63758, 50003, 43693, 52661, 55852, 52372, 59042, 37595, 4931, 73622, 68387, 86478, 40997, 5245, 75300, 24902, 59609, 35653, 15970, 37681, 69365, 22236, 86374, 65550, 343, 98377, 35354, 65770, 15365, 41422, 71356, 16630, 40044, 19290, 66449, 53629, 79452, 71674, 30260, 97303, 6487, 62789, 13005, 70152, 22501, 49867, 89294, 59232, 31776, 54919, 99851, 5438, 1096, 72269, 50486, 16719, 6144, 82041, 38332, 64452, 31840, 99287, 59928, 25503, 8407, 46970, 45907, 99238, 74547, 19704, 72035, 26542, 54600, 79172, 58779, 35747, 78956, 11478, 41195, 58135, 63856, 33037, 45753, 60159, 25193, 71838, 7526, 7985, 60714, 88627, 75790, 38454, 96110, 39237, 19792, 34534, 70169, 24805, 63215, 38175, 38784, 38855, 24826, 50917, 25147, 17082, 26997, 32295, 10894, 21805, 65245, 85407, 37926, 69214, 38579, 84721, 23544, 88548, 65626, 75517, 69737, 55626, 52175, 21697, 19453, 16908, 82841, 24060, 40285, 19195, 80281, 89322, 15232, 70043, 60691, 86370, 91949, 19017, 83846, 77869, 14321, 95102, 87073, 71467, 31305, 64677, 80358, 52629, 79419, 22359, 87867, 48296, 50141, 46807, 82184, 95812, 84665, 74511, 59914, 4146, 90417, 58508, 62875, 17630, 21868, 9199, 30322, 33352, 43374, 25473, 4119, 63086, 14147, 14863, 38020, 44757, 98628, 57916, 22199, 11865, 42911, 62651, 78290, 9392, 77294, 63168, 21043, 17409, 13786, 27475, 75979, 89668, 43596, 74316, 84489, 54941, 95992, 45445, 41059, 55142, 15214, 42903, 16799, 88254, 95984, 48575, 77822, 21067, 57238, 35352, 96779, 89564, 23797, 99937, 46379, 27119, 16060, 30302, 95327, 12849, 38111, 97090, 7598, 78473, 63079, 18570, 72803, 70040, 91385, 96436, 96263, 17368, 56188, 85999, 50026, 36050, 73736, 13351, 48321, 28357, 51718, 65636, 72903, 21584, 21060, 39829, 15564, 4716, 14594, 22363, 97639, 65937, 17802, 31535, 42767, 98761, 30987, 57657, 33398, 63053, 25926, 20944, 19306, 81727, 2695, 97479, 79172, 72764, 66446, 78864, 12698, 15812, 97209, 38827, 91016, 91281, 57875, 45228, 49211, 69755, 99224, 43999, 62879, 8879, 80015, 74396, 57146, 64665, 31159, 6980, 79069, 37409, 75037, 69977, 85919, 42826, 6974, 61063, 97640, 13433, 92528, 91311, 8440, 38840, 22362, 93929, 1836, 36590, 75052, 89475, 15437, 65648, 99012, 70236, 12307, 83585, 414, 62851, 48787, 28447, 21702, 57033, 29633, 44760, 34165, 27548, 37516, 24343, 63046, 2081, 20378, 19510, 42226, 97134, 68739, 32982, 56455, 53129, 77693, 25022, 55534, 99375, 30086, 98001, 7432, 67126, 76656, 29347, 28492, 43108, 64736, 32278, 84816, 80440, 30461, 818, 9136, 1952, 48442, 91058, 92590, 10443, 5195, 34009, 32141, 62209, 43740, 54102, 76895, 98172, 31583, 4155, 66492, 58981, 16591, 11331, 6838, 3818, 77063, 12523, 45570, 68970, 70055, 77751, 73743, 71732, 4704, 61384, 57343, 66682, 44500, 89745, 10436, 67202, 36455, 42467, 88801, 91280, 1056, 27534, 81619, 79004, 25824, 66362, 33280, 20706, 31929, 57422, 18730, 96197, 22101, 47592, 2180, 18287, 82310, 60430, 59627, 26471, 7794, 60475, 76713, 45427, 89654, 14370, 81674, 41246, 98416, 8669, 48883, 77154, 9806, 94015, 60347, 20027, 8405, 33150, 27368, 53375, 70171, 59431, 14534, 34018, 85665, 77797, 17944, 49602, 74391, 48830, 55029, 10371, 94261, 16658, 68400, 44148, 28150, 40364, 90913, 73151, 64463, 50058, 78191, 84439, 82478, 62398, 3113, 17578, 12830, 6571, 95934, 9132, 25287, 78731, 80683, 67207, 76597, 42096, 34934, 76609, 52553, 47508, 71561, 8038, 83011, 72577, 95790, 40076, 20292, 32138, 61197, 95476, 23123, 26648, 13611, 48452, 39963, 85857, 4855, 27029, 1542, 72443, 53688, 82635, 56264, 7977, 23090, 93553, 65434, 12124, 91087, 87800, 95675, 99419, 44659, 30382, 55263, 82514, 86800, 16781, 65977, 65946, 13033, 93895, 4056, 75895, 47878, 91309, 51233, 81409, 46773, 69135, 56906, 84493, 34530, 84534, 38312, 54574, 92933, 77341, 20839, 36126, 1143, 35356, 35459, 7959, 98335, 53266, 36146, 78047, 50607, 22486, 63308, 8996, 96056, 39085, 26567, 6779, 62663, 30523, 47881, 41279, 49864, 82248, 78333, 29466, 48151, 41957, 93235, 53308, 22682, 90722, 54478, 7235, 34306, 15827, 20121, 96837, 6283, 80172, 66109, 92592, 48238, 76428, 94546, 45430, 16288, 74839, 740, 25553, 83767, 35900, 5998, 7493, 46755, 11449, 88824, 44906, 33143, 7454, 56652, 34755, 63992, 59674, 65131, 46358, 12799, 96988, 51158, 73176, 1184, 49925, 63519, 11785, 29073, 72850, 47997, 75172, 55187, 15313, 40725, 33225, 56643, 10465, 38583, 86440, 97967, 26401, 17078, 38765, 33454, 19136, 57712, 48446, 98790, 27315, 71074, 10157, 57946, 35582, 49383, 61324, 26572, 84503, 3496, 60449, 17962, 26017, 65651, 40400, 83246, 80056, 75306, 75147, 41863, 25581, 87530, 33193, 43294, 5065, 99644, 62771, 75986, 79005, 44924, 18703, 40889, 4403, 5862, 2571, 82500, 74200, 36170, 46836, 74642, 65471, 26815, 30937, 64946, 10160, 15544, 31962, 54015, 28853, 66533, 14573, 79398, 47391, 73165, 47805, 77589, 16881, 13423, 89452, 76992, 62509, 9796, 57540, 13486, 48855, 25546, 47589, 21012, 47388, 78428, 70196, 84413, 81026, 87597, 22445, 83769, 85937, 38321, 85485, 87359, 9839, 67228, 71179, 94372, 4446, 62801, 50775, 96179, 40646, 44272, 12417, 47199, 39701, 30665, 32775, 66525, 53558, 78882, 31939, 67209, 38906, 34533, 99914, 27719, 216, 99225, 96537, 3843, 90564, 91110, 51838, 30300, 9559, 37795, 94880, 11325, 44979, 89696, 28129, 29931, 89971, 46292, 92710, 11036, 74760, 75307, 12291, 49618, 16293, 92408, 67928, 80823, 32872, 25460, 66819, 35374, 4035, 99087, 61129, 11341, 39118, 10891, 37217, 63638, 75477, 30068, 42334, 57570, 6890, 59353, 89939, 37692, 15232, 20033, 32202, 22348, 2766, 96791, 58448, 92248, 5769, 96684, 67885, 99295, 47271, 38655, 59513, 96960, 31718, 8974, 16122, 20535, 52380, 29769, 70660, 57425, 50891, 75044, 84257, 73315, 38181, 28673, 93140, 26307, 82265, 78382, 19681, 56585, 8975, 76764, 39956, 83450, 84663, 89963, 71584, 57696, 30829, 60527, 64947, 34899, 28805, 28397, 91830, 51842, 99838, 39839, 66971, 67177, 74219, 35637, 35634, 93581, 81746, 29991, 81096, 94279, 2968, 62561, 2479, 82126, 25702, 67953, 88088, 50293, 83423, 86206, 39935, 23253, 43041, 48941, 85787, 8388, 6671, 43574, 84908, 67295, 33623, 55060, 28174, 48415, 2529, 22009, 24524, 5283, 30460, 32399, 80423, 56929, 40852, 69969, 88541, 5979, 91496, 64730, 57198, 83145, 39750, 3568, 54669, 98679, 4297, 51047, 31492, 47734, 31343, 31180, 232, 19707, 24823, 75079, 73943, 17997, 8446, 91252, 39879, 58682, 82972, 18417, 39203, 36681, 42895, 8459, 15618, 17941, 52594, 43277, 16530, 40052, 91100, 87422, 47230, 95699, 49794, 50492, 87439, 86354, 4546, 65333, 11057, 77727, 19748, 38722, 91821, 18107, 42125, 89239, 28847, 54623, 38783, 47803, 31414, 38450, 3697, 89186, 30579, 44188, 26532, 8420, 80723, 48100, 60748, 76330, 45832, 8311, 16051, 4475, 13400, 48527, 46073, 17439, 56498, 94632, 9021, 16871, 83366, 14896, 4219, 38375, 87890, 90217, 42370, 61028, 85101, 76771, 83715, 94737, 69973, 74187, 1958, 59691, 86712, 86570, 60984, 76342, 13648, 85250, 28323, 48379, 45141, 36277, 51845, 29039, 3553, 5128, 59866, 51281, 68124, 17007, 24729, 29710, 41439, 40574, 11774, 86746, 89698, 56020, 37810, 88972, 11361, 95583, 70786, 589, 74473, 87513, 17690, 61427, 72914, 32517, 1804, 97910, 6327, 30246, 33049, 2622, 41026, 80875, 41293, 16752, 84225, 84414, 37137, 68956, 8095, 64981, 28180, 38629, 76962, 23840, 17477, 75268, 48297, 70340, 57888, 13938, 38554, 86836, 2195, 30270, 55484, 53364, 54705, 41380, 56316, 37723, 234, 21424, 26664, 63804, 75139, 36534, 18579, 9833, 98849, 72762, 59767, 52497, 24227, 83152, 71794, 21398, 99456, 89215, 51632, 54799, 27973, 68568, 68465, 98500, 28681, 18369, 24279, 96335, 12874, 82160, 67202, 85199, 27908, 67022, 49810, 77929, 96212, 81153, 77884, 7032, 1671, 53362, 28119, 56786, 30883, 28540, 76029, 3774, 64611, 19736, 25589, 46569, 45206, 48215, 69523, 17423, 91807, 90039, 30393, 58319, 85098, 66519, 57571, 24541, 3562, 14400, 62731, 82534, 61477, 89731, 18421, 29861, 52829, 838, 78040, 43350, 74323, 82892, 84746, 28302, 13264, 7595, 134, 12933, 46831, 24864, 47275, 20527, 9110, 28485, 30326, 99826, 64005, 99308, 65779, 42760, 90066, 3974, 38688, 39968, 32604, 11694, 46262, 73262, 45405, 43923, 67397, 88228, 56405, 17839, 92073, 57622, 93328, 15442, 50186, 7570, 58001, 31e3, 8915, 11467, 14793, 82691, 51238, 12485, 51745, 18192, 5985, 36826, 89434, 38669, 91592, 88799, 65621, 67237, 59541, 19657, 93402, 58705, 73553, 78280, 69125, 95591, 81168, 91927, 25976, 89077, 71690, 19404, 64603, 59752, 74698, 44233, 67602, 38615, 31303, 28650, 53700, 89819, 7783, 4351, 77451, 47350, 21234, 16016, 41532, 76508, 23063, 44993, 43983, 33356, 61715, 96485, 22121, 78004, 6316, 87896, 99289, 93981, 37850, 66128, 92735, 45064, 50924, 24204, 58816, 65290, 34392, 55567, 66416, 72353, 45775, 68590, 85685, 72683, 60090, 37149, 85347, 57414, 72336, 12979, 5720, 92754, 76911, 96883, 74420, 5220, 85815, 23557, 80567, 44365, 70254, 50864, 36619, 51479, 23281, 76428, 18580, 34240, 59289, 49076, 18439, 29522, 42541, 4024, 84446, 92434, 90407, 77241, 19690, 78143, 65919, 13699, 91844, 91241, 38361, 67171, 90551, 5709, 3474, 76025, 97043, 33834, 44638, 54040, 82797, 545, 38159, 16089, 35870, 89158, 55864, 98078, 50563, 36492, 10994, 85909, 9018, 19252, 73887, 67928, 60045, 70782, 11937, 4074, 53814, 46621, 52577, 94853, 45968, 73667, 65062, 73306, 76045, 78649, 91654, 53958, 96537, 95542, 67622, 54579, 17279, 67440, 56441, 20681, 64011, 52226, 96618, 32831, 60664, 67547, 39523, 2043, 59748, 1887, 69229, 94653, 99271, 98164, 62155, 9234, 47367, 13047, 6364, 35064, 10073, 6793, 80248, 29009, 44969, 11129, 17139, 79630, 89772, 26921, 56949, 23465, 30036, 17173, 82459, 96218, 60768, 76417, 24405, 18710, 68887, 82394, 69729, 82503, 40873, 41590, 67255, 30757, 9657, 91881, 34578, 9511, 5417, 58953, 18532, 10721, 22029, 48524, 47778, 881, 83489, 3464, 57462, 97459, 86689, 39755, 39547, 740, 36666, 7993, 31671, 86304, 12970, 73402, 52849, 31652, 79655, 11250, 18463, 57518, 20306, 25301, 1374, 51208, 33298, 87662, 61849, 60923, 68685, 69411, 39266, 80320, 34844, 89416, 81569, 83651, 35795, 40168, 33501, 1042, 58931, 3892, 85188, 74740, 85476, 23790, 33842, 89565, 53359, 25579, 59049, 62394, 72435, 12457, 21904, 18370, 97035, 57905, 9581, 91227, 92754, 37760, 1411, 7440, 87175, 88318, 63242, 85960, 56690, 12618, 30493, 11569, 73723, 7448, 58830, 157, 65814, 21118, 22140, 73793, 57855, 81830, 6795, 13183, 12625, 30635, 56429, 73216, 12342, 36722, 83886, 96828, 82870, 90954, 97614, 2370, 42160, 73370, 11944, 49067, 59452, 80495, 43911, 46712, 17033, 68037, 41963, 3874, 44856, 82985, 57453, 84358, 16120, 4454, 76624, 405, 62369, 55080, 61880, 51270, 87807, 10653, 36894, 70850, 35660, 234, 14705, 93418, 94084, 82856, 25384, 71555, 56754, 78315, 18291, 91656, 98079, 52384, 43306, 65205, 75903, 58701, 99496, 50048, 33557, 87793, 90857, 10143, 46726, 84284, 43635, 41213, 83845, 70986, 91408, 80220, 5728, 68890, 46577, 21152, 43759, 43301, 93661, 97252, 50106, 10099, 13722, 18572, 44024, 351, 18173, 23717, 85114, 85998, 57782, 63951, 53723, 86853, 63851, 79430, 49181, 46386, 69666, 55743, 76162, 71724, 40028, 94786, 34457, 16906, 90040, 30789, 40281, 94697, 96584, 81907, 4055, 53990, 66397, 80579, 42517, 78181, 39251, 9467, 67097, 95523, 66568, 63632, 71048, 15581, 39904, 75774, 77495, 75994, 29911, 65690, 41178, 47712, 70355, 16998, 56025, 5230, 10093, 71495, 34784, 70950, 54680, 57811, 53782, 39145, 36829, 85342, 40406, 35883, 45668, 3459, 29870, 78252, 70088, 70621, 67153, 5737, 40933, 91075, 93335, 86853, 15860, 81167, 91259, 16118, 52401, 83593, 84474, 2423, 75608, 39646, 90871, 70284, 82100, 96032, 5115, 63678, 2225, 88087, 58581, 44364, 57468, 21539, 13042, 64150, 63754, 5210, 87644, 54114, 64013, 63562, 41388, 32397, 74152, 23982, 71982, 71700, 33026, 66477, 47838, 46712, 39848, 35083, 65927, 97868, 11067, 76771, 71799, 43836, 41014, 97025, 93225, 8511, 63096, 26628, 73012, 12543, 76269, 99708, 2629, 49845, 73677, 19193, 14924, 57236, 95564, 15010, 59667, 73773, 78515, 2624, 99744, 13585, 33746, 58771, 94785, 62628, 99585, 11363, 80832, 59979, 9444, 78700, 2596, 85984, 69438, 16913, 96475, 93283, 18625, 77086, 45911, 39746, 64722, 39938, 43930, 54619, 302, 50384, 2738, 75714, 75249, 95439, 80714, 52555, 47266, 96190, 78750, 94973, 83669, 16479, 53163, 48071, 28e3, 45011, 26733, 67132, 83362, 84162, 43028, 8415, 27236, 52651, 89059, 64844, 80910, 1676, 91752, 57815, 26264, 3415, 57532, 29981, 61200, 96036, 62600, 20068, 56530, 38487, 8432, 89514, 26883, 69165, 97237, 22361, 55276, 39902, 95927, 82190, 49269, 27212, 46095, 37106, 64254, 27460, 49572, 51700, 27679, 12574, 33891, 3867, 9925, 6476, 82018, 45094, 59014, 67113, 44192, 75, 23318, 79895, 70550, 81717, 28833, 30271, 15821, 14999, 88174, 62617, 57517, 55256, 50281, 51583, 96879, 5225, 42272, 5339, 20483, 57596, 41011, 75937, 22767, 50120, 95938, 49753, 63882, 99616, 69083, 38721, 73889, 80236, 99531, 23053, 71237, 48861, 59046, 76283, 60538, 19732, 93877, 30345, 64882, 66660, 17026, 70364, 45676, 8039, 96228, 89936, 59141, 95585, 89552, 97247, 59325, 27848, 80058, 15950, 61481, 90906, 40998, 44137, 16144, 66300, 44091, 50018, 81364, 18211, 60294, 76559, 20279, 27414, 10589, 39860, 23e3, 31767, 95618, 56738, 50332, 16936, 70342, 92481, 30702, 76264, 62619, 68678, 62284, 83112, 93032, 55203, 52614, 36950, 41796, 45403, 79262, 2887, 53596, 61308, 20738, 34811, 27099, 90956, 65448, 3080, 75795, 29753, 97699, 80872, 23830, 85882, 74427, 99523, 74904, 28017, 45898, 57232, 48525, 7086, 26805, 74533, 92470, 18840, 76011, 93109, 14344, 55614, 50284, 15865, 19458, 35856, 13464, 53679, 64603, 51571, 56124, 79107, 29596, 89572, 78198, 57121, 73649, 8804, 87977, 87959, 70859, 40909, 77295, 87877, 75158, 62810, 92074, 23244, 59516, 50552, 31602, 41899, 6347, 27821, 68370, 48596, 88577, 30231, 25267, 84622, 31449, 12086, 56461, 22962, 78213, 62483, 93966, 60437, 52239, 58113, 32526, 38708, 81607, 57016, 1695, 90110, 4649, 59990, 23979, 3855, 10297, 46516, 96092, 82305, 30760, 78756, 4967, 82876, 4773, 86651, 16648, 53133, 82439, 78851, 49766, 24553, 15273, 36417, 1901, 33386, 76979, 25920, 33372, 2695, 11982, 40911, 6230, 91696, 43907, 17827, 30332, 89203, 32215, 91806, 23080, 49102, 9174, 11548, 54590, 75803, 66108, 73882, 62324, 26017, 72716, 33887, 1285, 31604, 71039, 24337, 53514, 58964, 89901, 22040, 92751, 12617, 37007, 5523, 61672, 62557, 98540, 26094, 60284, 19621, 96230, 38044, 6545, 9458, 42988, 2913, 86345, 67936, 90174, 40840, 44991, 24256, 34989, 74086, 13652, 68706, 1363, 4294, 88008, 78693, 83068, 94746, 221, 89299, 53186, 5930, 61889, 51341, 45412, 58860, 72568, 11381, 59785, 36887, 10690, 31347, 93326, 96267, 86987, 57565, 86836, 49071, 90331, 41248, 34629, 30240, 27270, 3864, 84308, 3035, 61369, 36902, 51017, 44409, 17120, 23823, 36460, 63359, 8333, 63173, 19134, 6493, 303, 18550, 26191, 19051, 81502, 66343, 6737, 90430, 65478, 58982, 82484, 16483, 47704, 44640, 68322, 44548, 72787, 2335, 28749, 39320, 5436, 98146, 56596, 812, 51445, 35533, 35478, 47573, 38414, 25542, 38032, 13442, 42983, 97207, 77854, 57806, 81616, 52828, 79429, 47389, 96795, 57764, 19605, 24767, 63253, 18809, 65093, 44449, 22952, 76872, 30983, 38948, 9310, 48336, 87651, 27110, 84427, 76209, 56412, 12760, 16747, 14551, 82626, 31224, 98636, 75100, 84882, 79479, 83420, 5347, 6803, 90063, 4617, 40257, 79183, 41766, 71873, 25242, 12275, 336, 40798, 42055, 74066, 69128, 32547, 76508, 32530, 42359, 89207, 49758, 58984, 92732, 15779, 7234, 28884, 28226, 50011, 35883, 99606, 45423, 76224, 75427, 85747, 33879, 97978, 57441, 927, 19164, 74716, 40702, 19715, 70917, 60344, 40236, 9019, 50577, 15598, 53136, 57285, 20536, 7539, 74832, 89184, 41501, 39447, 97422, 97041, 21913, 40581, 76081, 13089, 28776, 54164, 55736, 36263, 71841, 34488, 74988, 55467, 43322, 9214, 36746, 67981, 71877, 81683, 32461, 84091, 19422, 88366, 62054, 85664, 13409, 8003, 88276, 6989, 16607, 33633, 85349, 5784, 25950, 97998, 74110, 16699, 60184, 92818, 79705, 10381, 1474, 18656, 50434, 18232, 92132, 66537, 70141, 42854, 25120, 39581, 28249, 14215, 34810, 19767, 3409, 11807, 6566, 66138, 42997, 41999, 67504, 87117, 28961, 5e3, 29673, 77726, 73225, 54753, 69712, 71576, 92337, 17713, 63185, 87923, 91889, 68351, 17712, 75532, 93849, 48280, 62219, 317, 25290, 29209, 90927, 92929, 92762, 60413, 2018, 31793, 76290, 73373, 80777, 60819, 77375, 57886, 47291, 99670, 32605, 29064, 99476, 80999, 31217, 35, 91300, 14892, 73653, 26593, 25305, 56797, 12837, 39560, 27582, 37253, 38531, 76489, 49946, 69108, 58687, 43092, 73807, 96282, 6648, 67431, 87124, 57694, 21660, 64002, 6, 33600, 30245, 60636, 80164, 9285, 61426, 4658, 54130, 14710, 76553, 1904, 93668, 63110, 98618, 5601, 32199, 74923, 98049, 49717, 55539, 35940, 58545, 43295, 35810, 45451, 38735, 42065, 66769, 69825, 45461, 83881, 67372, 67351, 90612, 79502, 69460, 23108, 74421, 82990, 46821, 40683, 71603, 55267, 48192, 50242, 79738, 96417, 6664, 19929, 23644, 41116, 51056, 219, 45086, 32747, 49492, 15399, 24874, 80825, 95928, 61457, 45813, 59037, 16136, 3953, 83583, 5910, 12654, 53630, 92997, 22168, 93491, 71897, 74579, 24022, 6278, 24049, 71670, 43044, 8474, 38572, 77402, 35800, 7455, 96177, 41653, 74493, 20802, 65843, 73050, 73349, 2638, 65813, 96209, 49196, 45007, 32207, 14097, 66059, 46681, 7534, 71263, 20582, 10171, 51514, 52142, 60961, 57951, 25637, 37860, 21683, 86190, 90434, 94481, 85697, 95344, 2606, 74095, 61133, 7472, 64777, 94050, 41482, 975, 23471, 76052, 82021, 87676, 91345, 20196, 2612, 86299, 44996, 40312, 65712, 46079, 88514, 8610, 3685, 63197, 9073, 53105, 86824, 28112, 99306, 40706, 66840, 83003, 51590, 52755, 32285, 68454, 85058, 13645, 23073, 24724, 52989, 71880, 21952, 44144, 74975, 76715, 7844, 46447, 86643, 75579, 29276, 10864, 83179, 36721, 19300, 35066, 29383, 47478, 56644, 33354, 31414, 17643, 92374, 85085, 88458, 87191, 85248, 34963, 76278, 53230, 13953, 76985, 70959, 36663, 5293, 32658, 56767, 56997, 76736, 6558, 64248, 11907, 29123, 78458, 17678, 63805, 89973, 5076, 39263, 54404, 4355, 64957, 74407, 99838, 18836, 78098, 6490, 74888, 73719, 80675, 86178, 56283, 33591, 96957, 38382, 18772, 74773, 71229, 2603, 52673, 44609, 14843, 58418, 18060, 95459, 626, 30914, 13550, 42195, 44863, 8871, 89182, 64446, 78422, 41140, 15312, 98274, 48168, 95651, 35562, 85386, 56252, 72136, 85088, 68761, 78434, 98143, 61330, 2446, 64409, 49406, 99127, 98626, 55095, 44808, 13594, 87370, 89472, 12833, 98932, 68064, 58193, 20225, 5192, 28425, 23978, 24542, 80845, 55858, 4015, 21454, 37346, 51007, 17202, 10242, 12682, 55933, 96922, 22280, 75597, 50227, 70712, 44236, 20470, 36320, 49339, 60536, 80083, 38880, 93327, 49522, 93585, 9918, 55268, 4671, 57526, 11457, 48424, 54610, 7211, 78610, 9473, 72923, 27347, 30057, 76968, 26177, 59367, 46172, 88951, 40229, 34921, 60405, 88959, 16779, 29547, 92231, 61997, 36002, 21080, 39795, 77221, 10012, 49748, 76900, 15964, 3803, 40260, 92351, 92844, 10288, 57483, 10881, 70408, 75688, 16610, 1638, 93082, 44282, 66849, 75702, 69428, 34047, 84968, 71281, 72328, 73143, 88672, 49802, 50639, 18129, 93659, 58389, 49095, 45971, 34196, 84609, 59222, 19332, 17777, 41004, 47057, 30688, 16039, 20906, 41477, 42915, 60877, 33864, 75195, 62294, 3371, 11672, 1370, 2486, 35553, 17907, 90621, 45136, 9722, 67635, 12114, 63055, 16004, 21625, 24321, 20491, 26881, 66259, 94287, 54751, 36242, 36557, 5842, 30687, 65418, 94608, 24741, 45887, 78800, 86912, 42076, 50287, 9284, 68891, 76368, 83094, 96302, 35997, 30761, 97081, 9501, 68887, 32876, 1705, 34260, 95065, 45528, 88241, 30402, 12318, 52430, 40139, 96986, 84900, 72408, 42027, 31676, 54382, 73370, 26184, 14024, 57444, 57660, 52173, 30274, 93448, 63273, 77681, 74946, 2099, 69091, 19372, 66961, 14595, 58642, 75760, 52253, 53148, 26074, 52293, 65359, 63971, 4833, 86492, 1227, 54505, 19515, 89889, 46933, 13364, 33883, 83389, 36952, 52505, 67513, 40071, 31001, 3105, 87912, 29610, 75108, 37363, 28479, 43546, 89992, 19550, 54863, 82633, 19209, 21548, 35022, 21960, 57961, 11815, 95867, 559, 26428, 69386, 57453, 70147, 73538, 49562, 46806, 64550, 36653, 25718, 68792, 31113, 7607, 48037, 71020, 22666, 65957, 11141, 39227, 7990, 19849, 65972, 74528, 40888, 55386, 95918, 92088, 91125, 53648, 66122, 138, 79933, 71058, 34826, 97725, 69513, 22915, 18246, 52244, 91161, 40861, 40374, 13239, 56162, 4703, 95851, 22824, 41271, 28202, 62852, 84238, 46625, 20031, 8524, 20077, 65817, 21174, 29279, 57712, 22401, 67500, 30980, 74485, 26480, 21343, 30031, 61921, 35744, 57308, 71196, 1865, 49234, 62616, 54021, 29008, 83672, 85839, 96836, 45077, 80900, 66906, 63526, 93824, 71820, 11033, 20183, 85704, 4683, 63512, 39144, 56880, 64424, 95979, 17709, 94849, 31771, 5737, 84286, 16757, 46256, 24478, 73180, 59978, 8254, 78963, 95437, 86351, 33824, 32540, 18357, 2668, 99260, 21284, 81351, 70961, 10255, 6911, 47394, 72408, 23827, 59865, 96395, 30665, 43699, 3593, 29165, 23388, 26628, 92402, 16731, 86740, 29493, 9069, 78653, 90094, 42735, 33682, 95041, 89887, 92369, 57949, 81585, 50593, 14698, 4737, 72551, 57271, 59433, 156, 33966, 58773, 59108, 49578, 18100, 59836, 73221, 21110, 1650, 11058, 47770, 66141, 84576, 58388, 40915, 94507, 32209, 17272, 65674, 95552, 25685, 5345, 36995, 36302, 7971, 67001, 62062, 75939, 36005, 26739, 56484, 46885, 66348, 87666, 78055, 44485, 82955, 85936, 9219, 1847, 92687, 72579, 45457, 78252, 98239, 4e4, 75563, 92408, 17175, 78845, 32638, 26959, 35406, 59553, 57852, 7506, 9, 93172, 77713, 93880, 40981, 27924, 9678, 24538, 52426, 84852, 83781, 23712, 82490, 77890, 22482, 66668, 55850, 25644, 44972, 62275, 78089, 28894, 98685, 32998, 98766, 89119, 34355, 75127, 69797, 71419, 62067, 57990, 96514, 50603, 79807, 26135, 29207, 43632, 32905, 38513, 18924, 88872, 20758, 70232, 60425, 1116, 24077, 21369, 93541, 75329, 78656, 44251, 42014, 98154, 42552, 14575, 30765, 348, 1134, 71581, 68420, 78141, 21105, 63305, 9718, 54851, 65867, 8595, 47390, 39182, 51174, 41478, 64433, 59628, 31945, 87322, 78667, 95282, 5622, 26224, 19972, 97269, 98376, 14779, 51138, 49658, 45345, 4972, 52794, 15737, 496, 48939, 63485, 42780, 16061, 59631, 37171, 13483, 56058, 51093, 62290, 88227, 17400, 88433, 67363, 89507, 26482, 85964, 71336, 67799, 28342, 37747, 61722, 27180, 78755, 18603, 42953, 6606, 23875, 56766, 1932, 36113, 62807, 84012, 21103, 9685, 69662, 76755, 13701, 95168, 13169, 44726, 15284, 16702, 89617, 54397, 52052, 12835, 37741, 86434, 22400, 37947, 95763, 86337, 35189, 22756, 47473, 16618, 42479, 47405, 14055, 64262, 66670, 89692, 54032, 94591, 44149, 29854, 76691, 33263, 62048, 25116, 88598, 16119, 62116, 54517, 31883, 86707, 18895, 81790, 71294, 2684, 15292, 48107, 14341, 91416, 75609, 92564, 39987, 2283, 89970, 95855, 80970, 5432, 89860, 90293, 99851, 94648, 5598, 32171, 28793, 92305, 64244, 8277, 93391, 96717, 34464, 29838, 10664, 28050, 60122, 77934, 10758, 84922, 92220, 45071, 97697, 36368, 17792, 84792, 76594, 67319, 51886, 5665, 45201, 11348, 9254, 7510, 51039, 91683, 84500, 85338, 5555, 19633, 3870, 39576, 41486, 58524, 54508, 20707, 58504, 39642, 22454, 80069, 83455, 31043, 90794, 51934, 3295, 26582, 16300, 74990, 22197, 83310, 69642, 81113, 58558, 84833, 17105, 46659, 25003, 85749, 44829, 4103, 67516, 76458, 52392, 53546, 70291, 98846, 67315, 30686, 18555, 29755, 5923, 22732, 19501, 56181, 85351, 5023, 4808, 56911, 16793, 75336, 49712, 27723, 96974, 34321, 5454, 12862, 71924, 45928, 95697, 68664, 58183, 78104, 42483, 71204, 99628, 40642, 56410, 17350, 13396, 76724, 87509, 9158, 83708, 27298, 92651, 95086, 38851, 63558, 89810, 1580, 32518, 35795, 26514, 56322, 78635, 63731, 91428, 7247, 66460, 38671, 26799, 22549, 47991, 46064, 80467, 40083, 17141, 39152, 99872, 27561, 75389, 74778, 94893, 82935, 99076, 93419, 10474, 84436, 47536, 16719, 60136, 80566, 28404, 74525, 74212, 3704, 65516, 98197, 34210, 64140, 22238, 49939, 99542, 27481, 21992, 78181, 90060, 71365, 66935, 29578, 14961, 8569, 9454, 43308, 66753, 45972, 93572, 16382, 87320, 37183, 25478, 38164, 31997, 69856, 60898, 63968, 62264, 4799, 17591, 89937, 73905, 55890, 88285, 2448, 40398, 54180, 65869, 45155, 43407, 39105, 339, 51619, 20203, 21189, 68245, 76912, 1222, 76411, 82679, 7, 66047, 32043, 42627, 16638, 27019, 15248, 66444, 8249, 18790, 82150, 54084, 84469, 3426, 50226, 99868, 88894, 43769, 66384, 8593, 41414, 2976, 60053, 51866, 87904, 74135, 53842, 59520, 67482, 16995, 32328, 29555, 49067, 2799, 68851, 41049, 97190, 53984, 99755, 46412, 45885, 64e3, 21962, 36438, 71742, 57223, 66599, 86071, 31436, 32667, 98099, 38399, 47377, 5171, 2742, 48803, 17823, 22093, 9866, 691, 5514, 25546, 2114, 5919, 56181, 96052, 67211, 61712, 25995, 3188, 23833, 38549, 44775, 55355, 61548, 55988, 47309, 23749, 30667, 70732, 33299, 16127, 30842, 78961, 41072, 9876, 18903, 30292, 25275, 61881, 15939, 72573, 84502, 92654, 97226, 53434, 77025, 63892, 12421, 33644, 39445, 30933, 84218, 13757, 37719, 84450, 2697, 60309, 22402, 80310, 92771, 45205, 72792, 95776, 85945, 74651, 216, 50842, 47854, 21916, 61588, 75405, 10495, 83083, 60427, 78495, 99809, 47890, 22993, 21508, 9459, 26845, 98130, 1184, 46438, 27698, 40652, 65654, 98517, 1096, 6998, 49133, 57041, 77983, 58708, 42176, 67356, 324, 70063, 10597, 65205, 25622, 34336, 16640, 27896, 26907, 86760, 48244, 89650, 44997, 51609, 28934, 9171, 97859, 97213, 19859, 41037, 64081, 94781, 27683, 41521, 52871, 86935, 26486, 38744, 25943, 60617, 6414, 42292, 46204, 53262, 30201, 38776, 88831, 97253, 67282, 72860, 18452, 60927, 81504, 57713, 30296, 10896, 39900, 67135, 42772, 4631, 55283, 39253, 25264, 1809, 12874, 88035, 88421, 90491, 83290, 6884, 15444, 90113, 20406, 20796, 40239, 34431, 15018, 45600, 17241, 26611, 9551, 89126, 65673, 31708, 91252, 39647, 63011, 24193, 58932, 89326, 33491, 53217, 27976, 70151, 37531, 53576, 23931, 11789, 73073, 52171, 89301, 51718, 15385, 79487, 66436, 35771, 34163, 86540, 42665, 80748, 77622, 14679, 40185, 25030, 42622, 13162, 17048, 24243, 59985, 59807, 60562, 3595, 10135, 29199, 69784, 59796, 38194, 58432, 50943, 40422, 63035, 3208, 81440, 90749, 88046, 32218, 88092, 22224, 2627, 91576, 16781, 43948, 57795, 71073, 27817, 87077, 82717, 24473, 42096, 76920, 88864, 90537, 14715, 42551, 45066, 24316, 37361, 38582, 21871, 14672, 93362, 21727, 57021, 94313, 39562, 64985, 94028, 46094, 43845, 91838, 79574, 7597, 3153, 56783, 18817, 74711, 6883, 91061, 31674, 73729, 99315, 66183, 57647, 74484, 68077, 33224, 397, 56753, 53158, 71872, 68153, 9298, 20961, 49656, 33407, 95683, 14328, 44708, 72952, 27048, 67887, 28741, 46752, 88177, 95894, 40086, 88534, 87112, 68614, 83073, 88794, 96799, 67588, 75049, 84603, 83140, 97347, 87316, 73087, 77135, 71883, 98643, 3808, 8848, 14133, 60447, 1366, 72976, 1868, 51667, 63279, 60040, 88264, 79152, 3474, 61366, 20523, 21584, 93712, 83654, 89761, 90154, 96345, 37539, 32556, 74254, 70603, 97122, 44978, 78028, 8943, 13778, 11080, 34271, 68276, 85372, 48410, 94516, 15427, 75323, 71685, 70774, 50342, 33771, 3678, 42321, 69788, 41758, 55004, 30992, 17402, 63523, 42328, 87171, 24751, 15084, 33884, 83655, 88345, 69602, 52606, 57886, 18034, 3381, 75796, 35901, 77480, 28683, 68324, 66035, 7223, 14926, 16128, 13645, 90370, 31949, 11057, 98849, 29499, 21565, 30786, 83292, 92392, 37104, 36899, 49906, 79368, 43710, 80365, 88735, 75275, 21664, 57965, 19002, 301, 12658, 94385, 1717, 96191, 50404, 80166, 93965, 24688, 27839, 10812, 31715, 92127, 42588, 93307, 80834, 11317, 26583, 25769, 98227, 14884, 58462, 29148, 68662, 26872, 72927, 79021, 51622, 29521, 33355, 45701, 45996, 33782, 93424, 16530, 96086, 17329, 74020, 11501, 46660, 5583, 22277, 77653, 55430, 84644, 448, 86828, 58855, 67451, 95264, 67386, 82424, 52611, 60012, 88620, 72894, 94716, 22262, 99813, 69592, 63464, 33163, 91857, 47904, 22209, 78590, 68615, 52952, 31441, 41313, 18550, 72685, 68825, 4795, 53971, 14592, 39634, 23682, 76630, 2731, 81481, 86542, 23727, 54291, 56045, 61635, 32186, 9355, 73416, 63532, 24340, 18886, 84832, 30654, 48543, 18339, 65024, 91197, 64624, 74648, 9660, 27897, 49771, 11123, 8732, 49393, 12911, 72416, 17834, 18878, 62754, 85072, 23727, 56577, 51257, 83291, 12329, 16203, 91681, 68137, 79959, 43609, 58987, 2026, 42969, 59144, 84349, 75214, 76972, 22633, 64104, 53799, 16851, 99197, 70476, 77113, 46320, 88693, 37711, 96536, 68156, 7119, 2104, 49435, 77706, 18924, 24957, 92406, 87148, 70482, 36491, 42605, 54440, 7893, 31618, 35707, 65130, 30007, 75706, 77266, 37100, 9601, 87681, 42543, 69847, 81848, 32034, 49429, 99434, 62209, 17125, 55227, 61634, 52574, 83649, 28725, 70119, 62467, 80676, 21192, 99584, 21310, 25292, 72781, 17186, 10393, 98390, 19789, 92931, 36234, 62627, 23437, 3885, 58822, 82941, 43806, 8172, 23790, 72295, 36196, 98200, 2889, 87619, 13846, 56197, 27151, 21238, 48794, 81100, 62643, 40001, 39243, 33213, 78416, 194, 91369, 79342, 36404, 52308, 13741, 24442, 88610, 12659, 11574, 70052, 93039, 79367, 41792, 61816, 35435, 47192, 97596, 28330, 41145, 16918, 62865, 9576, 45857, 68737, 90124, 16703, 7071, 48433, 57222, 34435, 800, 72496, 16449, 68187, 28739, 97672, 86818, 50768, 40807, 88681, 64340, 2224, 19703, 59245, 90905, 31239, 84216, 93942, 97371, 16842, 92168, 52692, 16064, 84686, 89444, 27938, 98406, 41365, 4515, 20494, 18813, 16242, 10634, 61566, 18592, 78057, 8720, 33739, 78345, 87693, 30242, 70545, 55521, 23687, 9160, 8655, 38811, 61768, 7228, 5567, 5561, 82071, 85, 50145, 23113, 97761, 88441, 14891, 72188, 85166, 37189, 75671, 81377, 92470, 73645, 93258, 6610, 12185, 43065, 26704, 47922, 56650, 7527, 18006, 56948, 51675, 16658, 66402, 1047, 81624, 77395, 62310, 73262, 66050, 57275, 32936, 87641, 51528, 58183, 21952, 84098, 28913, 28622, 18140, 89796, 41317, 93954, 67690, 64667, 57092, 21315, 4731, 76115, 77291, 11204, 8634, 93034, 27411, 27149, 13843, 9817, 9407, 84492, 28444, 59901, 14592, 89654, 66207, 66232, 80293, 74502, 36925, 55515, 10121, 16768, 4720, 71502, 40500, 21406, 571, 87320, 81683, 42788, 86367, 44686, 22159, 67015, 35892, 49668, 83991, 72088, 30210, 74009, 86370, 97956, 2132, 93512, 54819, 26094, 51409, 21485, 94764, 85806, 13393, 48543, 7042, 76538, 64224, 47909, 9994, 23750, 17351, 52141, 30486, 60380, 86546, 66606, 36913, 58173, 45709, 83679, 82617, 23381, 9603, 61107, 566, 6572, 64745, 10614, 86371, 43244, 97154, 10397, 50975, 68006, 20045, 16942, 25536, 74031, 31807, 70133, 78790, 40341, 68730, 39635, 39013, 66841, 44043, 96215, 21270, 59427, 25034, 40645, 84741, 52083, 54503, 36861, 27659, 95463, 53847, 40921, 70116, 61536, 56756, 8967, 31079, 20097, 76014, 99818, 16606, 19713, 66904, 27106, 24874, 96701, 73287, 76772, 6073, 57343, 51428, 91171, 28299, 17520, 64903, 4177, 36071, 94952, 59008, 28543, 11576, 74547, 13260, 20688, 41261, 2780, 6633, 37536, 8844, 95774, 49323, 30448, 14154, 83379, 71259, 23302, 68402, 43750, 88505, 15575, 44927, 6584, 29867, 21541, 65763, 12154, 86616, 79877, 73259, 68626, 98962, 68548, 86576, 48046, 51755, 64995, 3661, 64585, 81550, 46798, 49319, 50206, 22024, 5175, 12923, 23427, 55915, 91723, 55831, 83784, 81034, 86779, 34622, 84570, 18960, 48798, 42970, 95789, 39465, 82353, 68905, 44234, 18244, 54345, 5592, 89361, 14644, 67924, 66415, 89349, 88530, 72096, 44459, 5258, 48317, 48866, 56886, 90458, 75889, 4514, 37227, 11302, 4667, 2129, 80414, 86289, 15887, 87380, 50749, 83220, 50529, 20619, 11606, 36531, 23409, 78122, 19566, 76564, 33045, 66703, 30017, 35347, 35038, 12952, 13971, 3922, 98702, 11786, 38388, 69556, 76728, 60535, 59961, 23634, 42211, 98387, 34880, 27755, 93182, 99040, 96390, 65989, 38375, 3652, 59657, 57431, 24666, 11061, 64713, 85185, 72849, 58611, 31220, 26657, 77056, 24553, 24993, 5210, 89024, 32054, 46997, 92652, 28363, 98992, 22593, 97710, 47766, 37646, 93573, 95502, 33790, 92973, 27766, 62671, 89698, 10877, 73893, 41004, 96035, 18795, 48080, 59666, 30241, 35233, 87353, 43647, 13404, 41982, 19264, 29229, 61369, 8309, 39383, 42305, 25944, 13577, 51545, 68990, 69801, 37145, 79189, 55897, 57793, 66816, 21930, 56771, 79296, 73793, 21632, 42301, 23696, 72641, 56310, 85576, 3004, 25669, 69221, 32996, 23040, 65782, 23712, 13414, 10758, 15590, 97298, 74246, 51511, 46900, 36795, 38292, 3852, 6384, 84421, 3446, 91670, 45312, 27609, 87034, 6683, 83891, 88991, 16533, 9197, 34427, 60384, 48525, 90978, 46107, 21693, 12956, 21804, 46558, 37682, 81207, 85840, 53238, 35026, 4835, 53264, 41376, 17783, 64756, 39278, 25403, 33042, 20954, 31193, 24247, 45911, 92453, 25370, 86602, 48574, 57865, 26436, 16122, 76614, 17028, 21262, 59718, 77821, 14036, 31033, 90563, 45410, 15158, 90209, 84089, 38053, 60780, 54166, 14255, 33120, 27171, 71798, 91214, 80040, 56699, 12475, 40193, 59415, 4769, 75920, 1036, 2692, 75862, 16612, 73670, 61182, 3305, 90334, 187, 91659, 28063, 75684, 50017, 82643, 9282, 77376, 85469, 8164, 5584, 36623, 82597, 83859, 3435, 98460, 70095, 80257, 4381, 6501, 8924, 35514, 14297, 54373, 71369, 5172, 15955, 82441, 4636, 48215, 6821, 3385, 17663, 40107, 55679, 30366, 42390, 95895, 16083, 58499, 17176, 55993, 51034, 49296, 4010, 78974, 35930, 2019, 96226, 27167, 68245, 53109, 59037, 37843, 79243, 10262, 58797, 61490, 82590, 52411, 54783, 29447, 94551, 30026, 97959, 93939, 73217, 82573, 62154, 78291, 33728, 39102, 11484, 86210, 43794, 73553, 87435, 1110, 77108, 56521, 78610, 8254, 1842, 43068, 70415, 79195, 26136, 49786, 47279, 38471, 20379, 54704, 86614, 91138, 51595, 50818, 80186, 73087, 17262, 94735, 4952, 27935, 4928, 74862, 51392, 62388, 9570, 38485, 30594, 56278, 47395, 72762, 94597, 72279, 16010, 34697, 54475, 67874, 78014, 88381, 4045, 41494, 55178, 46054, 24373, 1824, 55333, 7525, 97908, 61178, 84635, 2199, 35361, 4803, 21907, 79414, 66083, 54782, 58692, 28332, 41851, 28198, 55819, 37313, 67046, 16147, 90478, 71230, 34141, 85002, 44332, 35906, 429, 39744, 773, 22909, 19536, 98986, 90945, 45209, 85439, 92265, 25291, 22775, 60611, 49159, 95701, 36113, 53923, 60824, 84935, 29656, 50007, 86624, 61691, 76150, 32187, 42765, 60660, 13859, 10792, 88210, 29374, 29563, 45188, 28811, 19739, 67649, 73775, 99247, 48414, 91067, 68253, 9452, 90116, 91737, 73979, 62370, 69112, 58791, 20349, 71480, 56852, 36919, 87977, 77609, 68738, 85159, 4918, 70076, 46473, 4122, 57713, 1426, 50987, 77910, 66211, 62546, 77749, 96462, 34304, 77441, 12104, 91805, 10287, 60943, 49632, 83116, 25716, 23113, 22707, 77770, 31176, 6759, 46130, 4739, 55554, 3843, 31653, 70834, 72877, 41561, 36903, 23010, 6663, 2266, 16360, 70118, 91936, 17098, 77278, 4880, 23484, 94970, 41826, 46733, 93484, 68350, 38861, 18134, 32936, 241, 24803, 13876, 93278, 5039, 35873, 44418, 5305, 28510, 36115, 46717, 15238, 78607, 23464, 68635, 55712, 55007, 92411, 65739, 4858, 67537, 37041, 67453, 89801, 45963, 14800, 14225, 65655, 80463, 9716, 77255, 65136, 11230, 76323, 81433, 36445, 86523, 61058, 59560, 19380, 40791, 48073, 29626, 36661, 87907, 57369, 41623, 13705, 3880, 45088, 55444, 41003, 27754, 1450, 75312, 71801, 99600, 60719, 54182, 29245, 63315, 73758, 42973, 32702, 10855, 56363, 14638, 84424, 27178, 78195, 3133, 70865, 48019, 26117, 7151, 52107, 85562, 41347, 50486, 69457, 86961, 95482, 11857, 93587, 45680, 42145, 13029, 10043, 5142, 49213, 54525, 85761, 42707, 70754, 33768, 87671, 85038, 58900, 88438, 20004, 63390, 14815, 38875, 73417, 82875, 89481, 55517, 944, 15773, 61814, 32915, 27868, 5510, 21916, 28426, 89881, 16680, 88850, 11056, 51991, 4230, 39107, 49216, 40065, 4523, 75848, 95349, 56034, 10724, 9885, 88232, 42478, 65702, 95696, 39746, 66032, 88082, 86905, 30007, 75068, 66629, 7358, 26706, 90511, 72843, 67857, 20061, 98581, 69682, 38e3, 14186, 70, 2290, 17269, 30909, 69449, 19997, 13275, 2444, 84985, 51290, 97641, 15092, 69650, 21920, 19617, 7418, 49725, 91090, 20805, 28627, 80665, 67192, 34697, 57667, 99323, 50101, 40587, 35081, 14037, 34414, 19898, 60779, 83267, 87499, 29596, 41852, 15813, 32419, 72232, 8322, 39184, 46525, 13833, 65743, 94595, 37363, 4711, 35386, 96413, 10627, 62625, 56555, 12919, 93218, 25191, 98380, 51923, 66181, 5788, 73491, 1452, 487, 12277, 45415, 11884, 61300, 94528, 9181, 26616, 11455, 31514, 63290, 45035, 42759, 33804, 85721, 80979, 46010, 50975, 72482, 31231, 3086, 58941, 46102, 25773, 89742, 29788, 96741, 88523, 14922, 88262, 76305, 57676, 93259, 2396, 69145, 26074, 30056, 3853, 75317, 56639, 66203, 38923, 48939, 22813, 91864, 10934, 6714, 84099, 25631, 73223, 95630, 97552, 45950, 22197, 42886, 33764, 1263, 41856, 82057, 62349, 94091, 78028, 62651, 18911, 5693, 92561, 97821, 41994, 92343, 76785, 22216, 4203, 5038, 86151, 23596, 24338, 77181, 51761, 97693, 10955, 98159, 37568, 58932, 72128, 27303, 99608, 31688, 57557, 91022, 43036, 93927, 32869, 53653, 55205, 33139, 47271, 31224, 51650, 36422, 86857, 73799, 22068, 43376, 84760, 44898, 65776, 42451, 71480, 38509, 41673, 44141, 75918, 95652, 68981, 83001, 48815, 98086, 67950, 27986, 33175, 43624, 55274, 71051, 61124, 51550, 64967, 31570, 15748, 19159, 38174, 51078, 79811, 39183, 57527, 96550, 85168, 28824, 47466, 56993, 13151, 96664, 29735, 70251, 1079, 4314, 77714, 11507, 1440, 48415, 31984, 99915, 20282, 26524, 18057, 4992, 40521, 98108, 84045, 91961, 79256, 72244, 25788, 5487, 23595, 73302, 14205, 8925, 27625, 64343, 28821, 37992, 67156, 83320, 31106, 10884, 30735, 15067, 51091, 15668, 48777, 50770, 19169, 76504, 41165, 29749, 92812, 8065, 66782, 26841, 1411, 95461, 61134, 18699, 52261, 60469, 81373, 44825, 11448, 73320, 30151, 56991, 31372, 6655, 36472, 86292, 30247, 30931, 21029, 53410, 9859, 37267, 47514, 3492, 49008, 94727, 25234, 40546, 53417, 36492, 25723, 76227, 58456, 15979, 34876, 9574, 34392, 3751, 36933, 83921, 65108, 63135, 67572, 40184, 21098];
          var SBOX = new Array(16);
          var shiftTable = [16, 8, 16, 24];
          var sboxSize = 16;
          var count5 = 4;
          var randomIndex = 0;
          function getRandomDigit() {
            if (count5 < 0) {
              count5 = 4;
              randomIndex++;
            }
            return randTable[randomIndex] % Math.pow(10, count5 + 1) / Math.pow(10, count5--) | 0;
          }
          function getRandomNumber(low, high) {
            var range = high - low + 1;
            var rand = 0;
            var max = 1;
            do {
              for (rand = 0, max = 1; max < range; max *= 10) {
                rand = rand * 10 + getRandomDigit();
              }
            } while (rand >= (max / range | 0) * range);
            return low + rand % range | 0;
          }
          function generateSbox(size) {
            for (var i = 0; i < size; i++) {
              SBOX[i] = new Array(256);
              for (var row = 0; row < 256; row++) {
                SBOX[i][row] = row | row << 8 | row << 16 | row << 24 | 0;
              }
              for (var col = 3; col >= 0; col--) {
                for (var _row = 0; _row < 255; _row++) {
                  var mask = 255 << (col << 3);
                  var temp = SBOX[i][_row] | 0;
                  var row2 = getRandomNumber(_row, 255);
                  SBOX[i][_row] = SBOX[i][_row] & ~mask | SBOX[i][row2] & mask | 0;
                  SBOX[i][row2] = SBOX[i][row2] & ~mask | temp & mask | 0;
                }
              }
            }
          }
          generateSbox(sboxSize);
          var Snefru = function(_Hasher32be) {
            _inherits(Snefru2, _Hasher32be);
            var _super = _createSuper(Snefru2);
            function Snefru2(options) {
              var _this;
              _classCallCheck(this, Snefru2);
              options = options || {};
              options.length = options.length || 128;
              options.rounds = options.rounds || 8;
              _this = _super.call(this, options);
              _this.blockSize = 16 - _this.state.hash.length;
              _this.blockSizeInBytes = _this.blockSize * _this.unitSize;
              _this.W = new Array(16);
              return _this;
            }
            _createClass(Snefru2, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Snefru2.prototype), "reset", this).call(this);
                this.state.hash = new Array(this.options.length / 32 | 0);
                for (var i = 0; i < this.state.hash.length; i++) {
                  this.state.hash[i] = 0 | 0;
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                for (var i = 0; i < this.state.hash.length; i++) {
                  this.W[i] = this.state.hash[i] | 0;
                }
                for (var _i = this.state.hash.length; _i < 16; _i++) {
                  this.W[_i] = block[_i - this.state.hash.length] | 0;
                }
                for (var _i2 = 0; _i2 < this.options.rounds << 1; _i2 += 2) {
                  for (var byteInWord = 0; byteInWord < 4; byteInWord++) {
                    for (var n = 0; n < 16; n++) {
                      var sbe = SBOX[_i2 + (n / 2 | 0) % 2][this.W[n] & 255] | 0;
                      this.W[n - 1 >>> 0 & 15] ^= sbe;
                      this.W[n + 1 & 15] ^= sbe;
                    }
                    for (var _n = 0; _n < 16; _n++) {
                      this.W[_n] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                        /* rotateRight */
                        "b"
                      ])(this.W[_n], shiftTable[byteInWord]);
                    }
                  }
                }
                for (var _i3 = 0; _i3 < this.state.hash.length; _i3++) {
                  this.state.hash[_i3] = this.state.hash[_i3] ^ this.W[15 - _i3] | 0;
                }
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                if (this.state.message.length > 0) {
                  this.addPaddingZero(this.blockSizeInBytes - this.state.message.length | 0);
                }
                this.addPaddingZero(this.blockSizeInBytes - 8 | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }]);
            return Snefru2;
          }(_hasher32be__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Snefru;
        },
        /* 10 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32le__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var S = [[7, 12, 17, 22], [5, 9, 14, 20], [4, 11, 16, 23], [6, 10, 15, 21]];
          var T = new Array(64);
          for (var i = 0; i < 64; i++) {
            T[i] = Math.abs(Math.sin(i + 1)) * 4294967296 | 0;
          }
          var Md5 = function(_Hasher32le) {
            _inherits(Md52, _Hasher32le);
            var _super = _createSuper(Md52);
            function Md52() {
              _classCallCheck(this, Md52);
              return _super.apply(this, arguments);
            }
            _createClass(Md52, [{
              key: "reset",
              value: (
                /**
                 * Reset hasher to initial state
                 */
                function reset() {
                  _get(_getPrototypeOf(Md52.prototype), "reset", this).call(this);
                  this.state.hash = [1732584193 | 0, 4023233417 | 0, 2562383102 | 0, 271733878 | 0];
                }
              )
              /**
               * @protected
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "processBlock",
              value: (
                /**
                 * Process ready blocks
                 *
                 * @protected
                 * @ignore
                 * @param {number[]} block - Block
                 */
                function processBlock(block) {
                  var a = this.state.hash[0] | 0;
                  var b = this.state.hash[1] | 0;
                  var c = this.state.hash[2] | 0;
                  var d = this.state.hash[3] | 0;
                  a = Md52.CC(Md52.FF, T[0], a, b, c, d, block[0], S[0][0]);
                  d = Md52.CC(Md52.FF, T[1], d, a, b, c, block[1], S[0][1]);
                  c = Md52.CC(Md52.FF, T[2], c, d, a, b, block[2], S[0][2]);
                  b = Md52.CC(Md52.FF, T[3], b, c, d, a, block[3], S[0][3]);
                  a = Md52.CC(Md52.FF, T[4], a, b, c, d, block[4], S[0][0]);
                  d = Md52.CC(Md52.FF, T[5], d, a, b, c, block[5], S[0][1]);
                  c = Md52.CC(Md52.FF, T[6], c, d, a, b, block[6], S[0][2]);
                  b = Md52.CC(Md52.FF, T[7], b, c, d, a, block[7], S[0][3]);
                  a = Md52.CC(Md52.FF, T[8], a, b, c, d, block[8], S[0][0]);
                  d = Md52.CC(Md52.FF, T[9], d, a, b, c, block[9], S[0][1]);
                  c = Md52.CC(Md52.FF, T[10], c, d, a, b, block[10], S[0][2]);
                  b = Md52.CC(Md52.FF, T[11], b, c, d, a, block[11], S[0][3]);
                  a = Md52.CC(Md52.FF, T[12], a, b, c, d, block[12], S[0][0]);
                  d = Md52.CC(Md52.FF, T[13], d, a, b, c, block[13], S[0][1]);
                  c = Md52.CC(Md52.FF, T[14], c, d, a, b, block[14], S[0][2]);
                  b = Md52.CC(Md52.FF, T[15], b, c, d, a, block[15], S[0][3]);
                  a = Md52.CC(Md52.GG, T[16], a, b, c, d, block[1], S[1][0]);
                  d = Md52.CC(Md52.GG, T[17], d, a, b, c, block[6], S[1][1]);
                  c = Md52.CC(Md52.GG, T[18], c, d, a, b, block[11], S[1][2]);
                  b = Md52.CC(Md52.GG, T[19], b, c, d, a, block[0], S[1][3]);
                  a = Md52.CC(Md52.GG, T[20], a, b, c, d, block[5], S[1][0]);
                  d = Md52.CC(Md52.GG, T[21], d, a, b, c, block[10], S[1][1]);
                  c = Md52.CC(Md52.GG, T[22], c, d, a, b, block[15], S[1][2]);
                  b = Md52.CC(Md52.GG, T[23], b, c, d, a, block[4], S[1][3]);
                  a = Md52.CC(Md52.GG, T[24], a, b, c, d, block[9], S[1][0]);
                  d = Md52.CC(Md52.GG, T[25], d, a, b, c, block[14], S[1][1]);
                  c = Md52.CC(Md52.GG, T[26], c, d, a, b, block[3], S[1][2]);
                  b = Md52.CC(Md52.GG, T[27], b, c, d, a, block[8], S[1][3]);
                  a = Md52.CC(Md52.GG, T[28], a, b, c, d, block[13], S[1][0]);
                  d = Md52.CC(Md52.GG, T[29], d, a, b, c, block[2], S[1][1]);
                  c = Md52.CC(Md52.GG, T[30], c, d, a, b, block[7], S[1][2]);
                  b = Md52.CC(Md52.GG, T[31], b, c, d, a, block[12], S[1][3]);
                  a = Md52.CC(Md52.HH, T[32], a, b, c, d, block[5], S[2][0]);
                  d = Md52.CC(Md52.HH, T[33], d, a, b, c, block[8], S[2][1]);
                  c = Md52.CC(Md52.HH, T[34], c, d, a, b, block[11], S[2][2]);
                  b = Md52.CC(Md52.HH, T[35], b, c, d, a, block[14], S[2][3]);
                  a = Md52.CC(Md52.HH, T[36], a, b, c, d, block[1], S[2][0]);
                  d = Md52.CC(Md52.HH, T[37], d, a, b, c, block[4], S[2][1]);
                  c = Md52.CC(Md52.HH, T[38], c, d, a, b, block[7], S[2][2]);
                  b = Md52.CC(Md52.HH, T[39], b, c, d, a, block[10], S[2][3]);
                  a = Md52.CC(Md52.HH, T[40], a, b, c, d, block[13], S[2][0]);
                  d = Md52.CC(Md52.HH, T[41], d, a, b, c, block[0], S[2][1]);
                  c = Md52.CC(Md52.HH, T[42], c, d, a, b, block[3], S[2][2]);
                  b = Md52.CC(Md52.HH, T[43], b, c, d, a, block[6], S[2][3]);
                  a = Md52.CC(Md52.HH, T[44], a, b, c, d, block[9], S[2][0]);
                  d = Md52.CC(Md52.HH, T[45], d, a, b, c, block[12], S[2][1]);
                  c = Md52.CC(Md52.HH, T[46], c, d, a, b, block[15], S[2][2]);
                  b = Md52.CC(Md52.HH, T[47], b, c, d, a, block[2], S[2][3]);
                  a = Md52.CC(Md52.II, T[48], a, b, c, d, block[0], S[3][0]);
                  d = Md52.CC(Md52.II, T[49], d, a, b, c, block[7], S[3][1]);
                  c = Md52.CC(Md52.II, T[50], c, d, a, b, block[14], S[3][2]);
                  b = Md52.CC(Md52.II, T[51], b, c, d, a, block[5], S[3][3]);
                  a = Md52.CC(Md52.II, T[52], a, b, c, d, block[12], S[3][0]);
                  d = Md52.CC(Md52.II, T[53], d, a, b, c, block[3], S[3][1]);
                  c = Md52.CC(Md52.II, T[54], c, d, a, b, block[10], S[3][2]);
                  b = Md52.CC(Md52.II, T[55], b, c, d, a, block[1], S[3][3]);
                  a = Md52.CC(Md52.II, T[56], a, b, c, d, block[8], S[3][0]);
                  d = Md52.CC(Md52.II, T[57], d, a, b, c, block[15], S[3][1]);
                  c = Md52.CC(Md52.II, T[58], c, d, a, b, block[6], S[3][2]);
                  b = Md52.CC(Md52.II, T[59], b, c, d, a, block[13], S[3][3]);
                  a = Md52.CC(Md52.II, T[60], a, b, c, d, block[4], S[3][0]);
                  d = Md52.CC(Md52.II, T[61], d, a, b, c, block[11], S[3][1]);
                  c = Md52.CC(Md52.II, T[62], c, d, a, b, block[2], S[3][2]);
                  b = Md52.CC(Md52.II, T[63], b, c, d, a, block[9], S[3][3]);
                  this.state.hash[0] = this.state.hash[0] + a | 0;
                  this.state.hash[1] = this.state.hash[1] + b | 0;
                  this.state.hash[2] = this.state.hash[2] + c | 0;
                  this.state.hash[3] = this.state.hash[3] + d | 0;
                }
              )
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }], [{
              key: "FF",
              value: function FF(x, y, z) {
                return x & y | ~x & z;
              }
              /**
               * @protected
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "GG",
              value: function GG(x, y, z) {
                return x & z | y & ~z;
              }
              /**
               * @protected
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "HH",
              value: function HH(x, y, z) {
                return x ^ y ^ z;
              }
              /**
               * @protected
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "II",
              value: function II(x, y, z) {
                return y ^ (x | ~z);
              }
              /**
               * @protected
               * @ignore
               * @param {function} f
               * @param {number} k
               * @param {number} a
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @param {number} m
               * @param {number} s
               * @returns {number}
               */
            }, {
              key: "CC",
              value: function CC(f2, k, a, x, y, z, m, s) {
                return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                  /* rotateLeft */
                  "a"
                ])(a + f2(x, y, z) + m + k, s) + x | 0;
              }
            }]);
            return Md52;
          }(_hasher32le__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Md5;
        },
        /* 11 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var K = [1518500249, 1859775393, 2400959708, 3395469782];
          var Sha1 = function(_Hasher32be) {
            _inherits(Sha12, _Hasher32be);
            var _super = _createSuper(Sha12);
            function Sha12(options) {
              var _this;
              _classCallCheck(this, Sha12);
              _this = _super.call(this, options);
              _this.options.rounds = _this.options.rounds || 80;
              _this.W = new Array(80);
              return _this;
            }
            _createClass(Sha12, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Sha12.prototype), "reset", this).call(this);
                this.state.hash = [1732584193 | 0, 4023233417 | 0, 2562383102 | 0, 271733878 | 0, 3285377520 | 0];
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                var a = this.state.hash[0] | 0;
                var b = this.state.hash[1] | 0;
                var c = this.state.hash[2] | 0;
                var d = this.state.hash[3] | 0;
                var e = this.state.hash[4] | 0;
                for (var i = 0; i < this.options.rounds; i++) {
                  if (i < 16) {
                    this.W[i] = block[i] | 0;
                  } else {
                    this.W[i] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                      /* rotateLeft */
                      "a"
                    ])(this.W[i - 3] ^ this.W[i - 8] ^ this.W[i - 14] ^ this.W[i - 16], 1) | 0;
                  }
                  var t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(a, 5) + e + this.W[i] + K[i / 20 >> 0] | 0;
                  if (i < 20) {
                    t = t + (b & c | ~b & d) | 0;
                  } else if (i < 40) {
                    t = t + (b ^ c ^ d) | 0;
                  } else if (i < 60) {
                    t = t + (b & c | b & d | c & d) | 0;
                  } else {
                    t = t + (b ^ c ^ d) | 0;
                  }
                  e = d;
                  d = c;
                  c = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(b, 30) | 0;
                  b = a;
                  a = t;
                }
                this.state.hash[0] = this.state.hash[0] + a | 0;
                this.state.hash[1] = this.state.hash[1] + b | 0;
                this.state.hash[2] = this.state.hash[2] + c | 0;
                this.state.hash[3] = this.state.hash[3] + d | 0;
                this.state.hash[4] = this.state.hash[4] + e | 0;
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }]);
            return Sha12;
          }(_hasher32be__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Sha1;
        },
        /* 12 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _tools_tools__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
          var _hasher32be__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var SBOX = new Array(256);
          var SBOX0 = [104, 208, 235, 43, 72, 157, 106, 228, 227, 163, 86, 129, 125, 241, 133, 158, 44, 142, 120, 202, 23, 169, 97, 213, 93, 11, 140, 60, 119, 81, 34, 66, 63, 84, 65, 128, 204, 134, 179, 24, 46, 87, 6, 98, 244, 54, 209, 107, 27, 101, 117, 16, 218, 73, 38, 249, 203, 102, 231, 186, 174, 80, 82, 171, 5, 240, 13, 115, 59, 4, 32, 254, 221, 245, 180, 95, 10, 181, 192, 160, 113, 165, 45, 96, 114, 147, 57, 8, 131, 33, 92, 135, 177, 224, 0, 195, 18, 145, 138, 2, 28, 230, 69, 194, 196, 253, 191, 68, 161, 76, 51, 197, 132, 35, 124, 176, 37, 21, 53, 105, 255, 148, 77, 112, 162, 175, 205, 214, 108, 183, 248, 9, 243, 103, 164, 234, 236, 182, 212, 210, 20, 30, 225, 36, 56, 198, 219, 75, 122, 58, 222, 94, 223, 149, 252, 170, 215, 206, 7, 15, 61, 88, 154, 152, 156, 242, 167, 17, 126, 139, 67, 3, 226, 220, 229, 178, 78, 199, 109, 233, 39, 64, 216, 55, 146, 143, 1, 29, 83, 62, 89, 193, 79, 50, 22, 250, 116, 251, 99, 159, 52, 26, 42, 90, 141, 201, 207, 246, 144, 40, 136, 155, 49, 14, 189, 74, 232, 150, 166, 12, 200, 121, 188, 190, 239, 110, 70, 151, 91, 237, 25, 217, 172, 153, 168, 41, 100, 31, 173, 85, 19, 187, 247, 111, 185, 71, 47, 238, 184, 123, 137, 48, 211, 127, 118, 130];
          var eBOX = [1, 11, 9, 12, 13, 6, 15, 3, 14, 8, 7, 4, 10, 2, 5, 0];
          var rBOX = [7, 12, 11, 13, 14, 4, 9, 15, 6, 3, 8, 10, 2, 5, 1, 0];
          var iBOX = new Array(16);
          var theta = [1, 1, 4, 1, 8, 5, 2, 9];
          var theta0 = [1, 1, 3, 1, 5, 8, 9, 5];
          var C = new Array(512);
          var RC = new Array(22);
          var C0 = new Array(512);
          var RC0 = new Array(22);
          var CT = new Array(512);
          var RCT = new Array(22);
          function calculateSBOX() {
            for (var i = 0; i < 16; i++) {
              iBOX[eBOX[i]] = i | 0;
            }
            for (var _i = 0; _i < 256; _i++) {
              var left = eBOX[_i >> 4];
              var right = iBOX[_i & 15];
              var temp = rBOX[left ^ right];
              SBOX[_i] = eBOX[left ^ temp] << 4 | iBOX[right ^ temp];
            }
          }
          function calculateRC(SBOX2, theta2) {
            var C2 = new Array(512);
            var RC2 = new Array(22);
            for (var t = 0; t < 8; t++) {
              C2[t] = [];
            }
            for (var i = 0; i < 256; i++) {
              var V = new Array(10);
              V[1] = SBOX2[i];
              V[2] = V[1] << 1;
              if (V[2] >= 256) {
                V[2] ^= 285;
              }
              V[3] = V[2] ^ V[1];
              V[4] = V[2] << 1;
              if (V[4] >= 256) {
                V[4] ^= 285;
              }
              V[5] = V[4] ^ V[1];
              V[8] = V[4] << 1;
              if (V[8] >= 256) {
                V[8] ^= 285;
              }
              V[9] = V[8] ^ V[1];
              C2[0][i * 2] = V[theta2[0]] << 24 | V[theta2[1]] << 16 | V[theta2[2]] << 8 | V[theta2[3]];
              C2[0][i * 2 + 1] = V[theta2[4]] << 24 | V[theta2[5]] << 16 | V[theta2[6]] << 8 | V[theta2[7]];
              for (var _t = 1; _t < 8; _t++) {
                C2[_t][i * 2] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__[
                  /* rotateRight64lo */
                  "d"
                ])(C2[0][i * 2 + 1], C2[0][i * 2], _t << 3);
                C2[_t][i * 2 + 1] = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_0__[
                  /* rotateRight64hi */
                  "c"
                ])(C2[0][i * 2 + 1], C2[0][i * 2], _t << 3);
              }
            }
            RC2[0] = 0;
            RC2[1] = 0;
            for (var _i2 = 1; _i2 <= 10; _i2++) {
              RC2[_i2 * 2] = C2[0][16 * _i2 - 16] & 4278190080 ^ C2[1][16 * _i2 - 14] & 16711680 ^ C2[2][16 * _i2 - 12] & 65280 ^ C2[3][16 * _i2 - 10] & 255;
              RC2[_i2 * 2 + 1] = C2[4][16 * _i2 - 7] & 4278190080 ^ C2[5][16 * _i2 - 5] & 16711680 ^ C2[6][16 * _i2 - 3] & 65280 ^ C2[7][16 * _i2 - 1] & 255;
            }
            return [C2, RC2];
          }
          (function() {
            calculateSBOX();
            var x = calculateRC(SBOX0, theta0);
            C0 = x[0];
            RC0 = x[1];
            x = calculateRC(SBOX, theta0);
            CT = x[0];
            RCT = x[1];
            x = calculateRC(SBOX, theta);
            C = x[0];
            RC = x[1];
          })();
          var Whirlpool = function(_Hasher32be) {
            _inherits(Whirlpool2, _Hasher32be);
            var _super = _createSuper(Whirlpool2);
            function Whirlpool2(options) {
              var _this;
              _classCallCheck(this, Whirlpool2);
              options = options || {};
              options.type = options.type || "";
              options.rounds = options.rounds || 10;
              _this = _super.call(this, options);
              switch (_this.options.type) {
                case "0":
                case 0:
                  _this.C = C0;
                  _this.RC = RC0;
                  break;
                case "t":
                  _this.C = CT;
                  _this.RC = RCT;
                  break;
                default:
                  _this.C = C;
                  _this.RC = RC;
              }
              return _this;
            }
            _createClass(Whirlpool2, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Whirlpool2.prototype), "reset", this).call(this);
                this.state.hash = new Array(16);
                for (var i = 0; i < 16; i++) {
                  this.state.hash[i] = 0 | 0;
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                var K = new Array(16);
                var state = [];
                for (var i = 0; i < 16; i++) {
                  state[i] = block[i] ^ (K[i] = this.state.hash[i]) | 0;
                }
                var L = [];
                for (var r = 1; r <= this.options.rounds; r++) {
                  for (var _i3 = 0; _i3 < 8; _i3++) {
                    L[_i3 * 2] = 0;
                    L[_i3 * 2 + 1] = 0;
                    for (var t = 0, s = 56, j = 0; t < 8; t++, s -= 8, j = s < 32 ? 1 : 0) {
                      L[_i3 * 2] ^= this.C[t][(K[(_i3 - t & 7) * 2 + j] >>> s % 32 & 255) * 2];
                      L[_i3 * 2 + 1] ^= this.C[t][(K[(_i3 - t & 7) * 2 + j] >>> s % 32 & 255) * 2 + 1];
                    }
                  }
                  for (var _i4 = 0; _i4 < 16; _i4++) {
                    K[_i4] = L[_i4];
                  }
                  K[0] ^= this.RC[r * 2];
                  K[1] ^= this.RC[r * 2 + 1];
                  for (var _i5 = 0; _i5 < 8; _i5++) {
                    L[_i5 * 2] = K[_i5 * 2];
                    L[_i5 * 2 + 1] = K[_i5 * 2 + 1];
                    for (var _t2 = 0, _s = 56, _j = 0; _t2 < 8; _t2++, _s -= 8, _j = _s < 32 ? 1 : 0) {
                      L[_i5 * 2] ^= this.C[_t2][(state[(_i5 - _t2 & 7) * 2 + _j] >>> _s % 32 & 255) * 2];
                      L[_i5 * 2 + 1] ^= this.C[_t2][(state[(_i5 - _t2 & 7) * 2 + _j] >>> _s % 32 & 255) * 2 + 1];
                    }
                  }
                  for (var _i6 = 0; _i6 < 16; _i6++) {
                    state[_i6] = L[_i6];
                  }
                }
                for (var _i7 = 0; _i7 < 16; _i7++) {
                  this.state.hash[_i7] ^= state[_i7] ^ block[_i7];
                }
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 32 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }]);
            return Whirlpool2;
          }(_hasher32be__WEBPACK_IMPORTED_MODULE_1__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Whirlpool;
        },
        /* 13 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var hasher = __webpack_require__(4);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var Hasher8 = function(_Hasher) {
            _inherits(Hasher82, _Hasher);
            var _super = _createSuper(Hasher82);
            function Hasher82(options) {
              var _this;
              _classCallCheck(this, Hasher82);
              _this = _super.call(this, options);
              _this.unitSize = 1;
              _this.blockSizeInBytes = _this.blockSize * _this.unitSize;
              _this.blockUnits = [];
              return _this;
            }
            _createClass(Hasher82, [{
              key: "process",
              value: function process2() {
                while (this.state.message.length >= this.blockSizeInBytes) {
                  this.blockUnits = new Array(this.blockSizeInBytes);
                  for (var i = 0; i < this.blockSizeInBytes; i++) {
                    this.blockUnits[i] = this.state.message.charCodeAt(i) | 0;
                  }
                  this.state.message = this.state.message.substr(this.blockSizeInBytes);
                  this.processBlock(this.blockUnits);
                }
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @param {number[]} M
               */
            }, {
              key: "processBlock",
              value: function processBlock(M) {
              }
              /**
               * Get hash from state
               *
               * @protected
               * @param {number} [size=this.state.hash.length] - Limit hash size (in chunks)
               * @returns {string}
               */
            }, {
              key: "getStateHash",
              value: function getStateHash(size) {
                size = size || this.state.hash.length;
                var hash = "";
                for (var i = 0; i < size; i++) {
                  hash += String.fromCharCode(this.state.hash[i] & 255);
                }
                return hash;
              }
            }]);
            return Hasher82;
          }(hasher[
            "a"
            /* default */
          ]);
          var hasher8 = Hasher8;
          function md2_typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              md2_typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              md2_typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return md2_typeof(obj);
          }
          function md2_classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function md2_defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function md2_createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              md2_defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              md2_defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = md2_getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function md2_inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              md2_setPrototypeOf(subClass, superClass);
          }
          function md2_setPrototypeOf(o, p) {
            md2_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return md2_setPrototypeOf(o, p);
          }
          function md2_createSuper(Derived) {
            var hasNativeReflectConstruct = md2_isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = md2_getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = md2_getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return md2_possibleConstructorReturn(this, result);
            };
          }
          function md2_possibleConstructorReturn(self2, call) {
            if (call && (md2_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return md2_assertThisInitialized(self2);
          }
          function md2_assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function md2_isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function md2_getPrototypeOf(o) {
            md2_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return md2_getPrototypeOf(o);
          }
          var SBOX = [41, 46, 67, 201, 162, 216, 124, 1, 61, 54, 84, 161, 236, 240, 6, 19, 98, 167, 5, 243, 192, 199, 115, 140, 152, 147, 43, 217, 188, 76, 130, 202, 30, 155, 87, 60, 253, 212, 224, 22, 103, 66, 111, 24, 138, 23, 229, 18, 190, 78, 196, 214, 218, 158, 222, 73, 160, 251, 245, 142, 187, 47, 238, 122, 169, 104, 121, 145, 21, 178, 7, 63, 148, 194, 16, 137, 11, 34, 95, 33, 128, 127, 93, 154, 90, 144, 50, 39, 53, 62, 204, 231, 191, 247, 151, 3, 255, 25, 48, 179, 72, 165, 181, 209, 215, 94, 146, 42, 172, 86, 170, 198, 79, 184, 56, 210, 150, 164, 125, 182, 118, 252, 107, 226, 156, 116, 4, 241, 69, 157, 112, 89, 100, 113, 135, 32, 134, 91, 207, 101, 230, 45, 168, 2, 27, 96, 37, 173, 174, 176, 185, 246, 28, 70, 97, 105, 52, 64, 126, 15, 85, 71, 163, 35, 221, 81, 175, 58, 195, 92, 249, 206, 186, 197, 234, 38, 44, 83, 13, 110, 133, 40, 132, 9, 211, 223, 205, 244, 65, 129, 77, 82, 106, 220, 55, 200, 108, 193, 171, 250, 36, 225, 123, 8, 12, 189, 177, 74, 120, 136, 149, 139, 227, 99, 232, 109, 233, 203, 213, 254, 59, 0, 29, 57, 242, 239, 183, 14, 102, 88, 208, 228, 166, 119, 114, 248, 235, 117, 75, 10, 49, 68, 80, 180, 143, 237, 31, 26, 219, 153, 141, 51, 159, 17, 131, 20];
          var Md2 = function(_Hasher) {
            md2_inherits(Md22, _Hasher);
            var _super = md2_createSuper(Md22);
            function Md22(options) {
              var _this;
              md2_classCallCheck(this, Md22);
              _this = _super.call(this, options);
              _this.options.rounds = _this.options.rounds || 18;
              return _this;
            }
            md2_createClass(Md22, [{
              key: "reset",
              value: function reset() {
                _get(md2_getPrototypeOf(Md22.prototype), "reset", this).call(this);
                this.state.hash = new Array(48);
                this.state.checksum = new Array(16);
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                for (var i = 0; i < 16; i++) {
                  this.state.hash[16 + i] = block[i] | 0;
                  this.state.hash[32 + i] = block[i] ^ this.state.hash[i];
                }
                var t = 0;
                for (var _i = 0; _i < this.options.rounds; _i++) {
                  for (var j = 0; j < 48; j++) {
                    t = this.state.hash[j] ^= SBOX[t];
                  }
                  t = t + _i & 255;
                }
                t = this.state.checksum[15] & 255;
                for (var _i2 = 0; _i2 < 16; _i2++) {
                  t = this.state.checksum[_i2] ^= SBOX[block[_i2] ^ t];
                }
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingPKCS7(16 - (this.state.message.length & 15) | 0);
                this.process();
                for (var i = 0; i < 16; i++) {
                  this.state.message += String.fromCharCode(this.state.checksum[i]);
                }
                this.process();
                return this.getStateHash(16);
              }
            }]);
            return Md22;
          }(hasher8);
          var md2 = __webpack_exports__["a"] = Md2;
        },
        /* 14 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32le__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var K = [0, 1518500249, 1859775393, 2400959708];
          var ROT = [5, 11, 7, 15, 6, 13, 8, 14, 7, 12, 9, 11, 8, 15, 6, 12, 9, 14, 5, 13];
          var ROT2 = [10, 17, 25, 30];
          var IND = [18, 0, 1, 2, 3, 19, 4, 5, 6, 7, 16, 8, 9, 10, 11, 17, 12, 13, 14, 15, 22, 3, 6, 9, 12, 23, 15, 2, 5, 8, 20, 11, 14, 1, 4, 21, 7, 10, 13, 0, 26, 12, 5, 14, 7, 27, 0, 9, 2, 11, 24, 4, 13, 6, 15, 25, 8, 1, 10, 3, 30, 7, 2, 13, 8, 31, 3, 14, 9, 4, 28, 15, 10, 5, 0, 29, 11, 6, 1, 12];
          var Has160 = function(_Hasher32le) {
            _inherits(Has1602, _Hasher32le);
            var _super = _createSuper(Has1602);
            function Has1602(options) {
              var _this;
              _classCallCheck(this, Has1602);
              _this = _super.call(this, options);
              _this.options.rounds = _this.options.rounds || 80;
              _this.W = new Array(32);
              return _this;
            }
            _createClass(Has1602, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Has1602.prototype), "reset", this).call(this);
                this.state.hash = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                var a = this.state.hash[0] | 0;
                var b = this.state.hash[1] | 0;
                var c = this.state.hash[2] | 0;
                var d = this.state.hash[3] | 0;
                var e = this.state.hash[4] | 0;
                for (var i = 0; i < 16; i++) {
                  this.W[i] = block[i] | 0;
                }
                this.W[16] = this.W[0] ^ this.W[1] ^ this.W[2] ^ this.W[3] | 0;
                this.W[17] = this.W[4] ^ this.W[5] ^ this.W[6] ^ this.W[7] | 0;
                this.W[18] = this.W[8] ^ this.W[9] ^ this.W[10] ^ this.W[11] | 0;
                this.W[19] = this.W[12] ^ this.W[13] ^ this.W[14] ^ this.W[15] | 0;
                this.W[20] = this.W[3] ^ this.W[6] ^ this.W[9] ^ this.W[12] | 0;
                this.W[21] = this.W[2] ^ this.W[5] ^ this.W[8] ^ this.W[15] | 0;
                this.W[22] = this.W[1] ^ this.W[4] ^ this.W[11] ^ this.W[14] | 0;
                this.W[23] = this.W[0] ^ this.W[7] ^ this.W[10] ^ this.W[13] | 0;
                this.W[24] = this.W[5] ^ this.W[7] ^ this.W[12] ^ this.W[14] | 0;
                this.W[25] = this.W[0] ^ this.W[2] ^ this.W[9] ^ this.W[11] | 0;
                this.W[26] = this.W[4] ^ this.W[6] ^ this.W[13] ^ this.W[15] | 0;
                this.W[27] = this.W[1] ^ this.W[3] ^ this.W[8] ^ this.W[10] | 0;
                this.W[28] = this.W[2] ^ this.W[7] ^ this.W[8] ^ this.W[13] | 0;
                this.W[29] = this.W[3] ^ this.W[4] ^ this.W[9] ^ this.W[14] | 0;
                this.W[30] = this.W[0] ^ this.W[5] ^ this.W[10] ^ this.W[15] | 0;
                this.W[31] = this.W[1] ^ this.W[6] ^ this.W[11] ^ this.W[12] | 0;
                for (var _i = 0; _i < this.options.rounds; _i++) {
                  var t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(a, ROT[_i % 20]) + e + this.W[IND[_i]] + K[_i / 20 >> 0] | 0;
                  if (_i < 20) {
                    t = t + (b & c | ~b & d) | 0;
                  } else if (_i < 40) {
                    t = t + (b ^ c ^ d) | 0;
                  } else if (_i < 60) {
                    t = t + (c ^ (b | ~d)) | 0;
                  } else {
                    t = t + (b ^ c ^ d) | 0;
                  }
                  e = d;
                  d = c;
                  c = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(b, ROT2[_i / 20 >> 0]) | 0;
                  b = a;
                  a = t;
                }
                this.state.hash[0] = this.state.hash[0] + a | 0;
                this.state.hash[1] = this.state.hash[1] + b | 0;
                this.state.hash[2] = this.state.hash[2] + c | 0;
                this.state.hash[3] = this.state.hash[3] + d | 0;
                this.state.hash[4] = this.state.hash[4] + e | 0;
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }]);
            return Has1602;
          }(_hasher32le__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Has160;
        },
        /* 15 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return toBase64;
          });
          var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          function toBase64(raw) {
            var str = "";
            var size = raw.length - raw.length % 3 | 0;
            var n = 0;
            for (var i = 0; i < size; i += 3) {
              n = raw.charCodeAt(i) << 16 | raw.charCodeAt(i + 1) << 8 | raw.charCodeAt(i + 2);
              str += chars.charAt(n >> 18) + chars.charAt(n >> 12 & 63) + chars.charAt(n >> 6 & 63) + chars.charAt(n & 63);
            }
            if (raw.length - size === 2) {
              n = raw.charCodeAt(size) << 16 | raw.charCodeAt(size + 1) << 8;
              str += chars.charAt(n >> 18) + chars.charAt(n >> 12 & 63) + chars.charAt(n >> 6 & 63) + "=";
            } else if (raw.length - size === 1) {
              n = raw.charCodeAt(size) << 16;
              str += chars.charAt(n >> 18) + chars.charAt(n >> 12 & 63) + "==";
            }
            return str;
          }
        },
        /* 16 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32le__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var S = [[3, 7, 11, 19], [3, 5, 9, 13], [3, 9, 11, 15]];
          var F = 0;
          var G = 1518500249;
          var H = 1859775393;
          var Md4 = function(_Hasher32le) {
            _inherits(Md42, _Hasher32le);
            var _super = _createSuper(Md42);
            function Md42() {
              _classCallCheck(this, Md42);
              return _super.apply(this, arguments);
            }
            _createClass(Md42, [{
              key: "reset",
              value: (
                /**
                 * Reset hasher to initial state
                 */
                function reset() {
                  _get(_getPrototypeOf(Md42.prototype), "reset", this).call(this);
                  this.state.hash = [1732584193 | 0, 4023233417 | 0, 2562383102 | 0, 271733878 | 0];
                }
              )
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "processBlock",
              value: (
                /**
                 * Process ready blocks
                 *
                 * @protected
                 * @ignore
                 * @param {number[]} block - Block
                 */
                function processBlock(block) {
                  var a = this.state.hash[0] | 0;
                  var b = this.state.hash[1] | 0;
                  var c = this.state.hash[2] | 0;
                  var d = this.state.hash[3] | 0;
                  a = Md42.CC(Md42.FF, F, a, b, c, d, block[0], S[0][0]);
                  d = Md42.CC(Md42.FF, F, d, a, b, c, block[1], S[0][1]);
                  c = Md42.CC(Md42.FF, F, c, d, a, b, block[2], S[0][2]);
                  b = Md42.CC(Md42.FF, F, b, c, d, a, block[3], S[0][3]);
                  a = Md42.CC(Md42.FF, F, a, b, c, d, block[4], S[0][0]);
                  d = Md42.CC(Md42.FF, F, d, a, b, c, block[5], S[0][1]);
                  c = Md42.CC(Md42.FF, F, c, d, a, b, block[6], S[0][2]);
                  b = Md42.CC(Md42.FF, F, b, c, d, a, block[7], S[0][3]);
                  a = Md42.CC(Md42.FF, F, a, b, c, d, block[8], S[0][0]);
                  d = Md42.CC(Md42.FF, F, d, a, b, c, block[9], S[0][1]);
                  c = Md42.CC(Md42.FF, F, c, d, a, b, block[10], S[0][2]);
                  b = Md42.CC(Md42.FF, F, b, c, d, a, block[11], S[0][3]);
                  a = Md42.CC(Md42.FF, F, a, b, c, d, block[12], S[0][0]);
                  d = Md42.CC(Md42.FF, F, d, a, b, c, block[13], S[0][1]);
                  c = Md42.CC(Md42.FF, F, c, d, a, b, block[14], S[0][2]);
                  b = Md42.CC(Md42.FF, F, b, c, d, a, block[15], S[0][3]);
                  a = Md42.CC(Md42.GG, G, a, b, c, d, block[0], S[1][0]);
                  d = Md42.CC(Md42.GG, G, d, a, b, c, block[4], S[1][1]);
                  c = Md42.CC(Md42.GG, G, c, d, a, b, block[8], S[1][2]);
                  b = Md42.CC(Md42.GG, G, b, c, d, a, block[12], S[1][3]);
                  a = Md42.CC(Md42.GG, G, a, b, c, d, block[1], S[1][0]);
                  d = Md42.CC(Md42.GG, G, d, a, b, c, block[5], S[1][1]);
                  c = Md42.CC(Md42.GG, G, c, d, a, b, block[9], S[1][2]);
                  b = Md42.CC(Md42.GG, G, b, c, d, a, block[13], S[1][3]);
                  a = Md42.CC(Md42.GG, G, a, b, c, d, block[2], S[1][0]);
                  d = Md42.CC(Md42.GG, G, d, a, b, c, block[6], S[1][1]);
                  c = Md42.CC(Md42.GG, G, c, d, a, b, block[10], S[1][2]);
                  b = Md42.CC(Md42.GG, G, b, c, d, a, block[14], S[1][3]);
                  a = Md42.CC(Md42.GG, G, a, b, c, d, block[3], S[1][0]);
                  d = Md42.CC(Md42.GG, G, d, a, b, c, block[7], S[1][1]);
                  c = Md42.CC(Md42.GG, G, c, d, a, b, block[11], S[1][2]);
                  b = Md42.CC(Md42.GG, G, b, c, d, a, block[15], S[1][3]);
                  a = Md42.CC(Md42.HH, H, a, b, c, d, block[0], S[2][0]);
                  d = Md42.CC(Md42.HH, H, d, a, b, c, block[8], S[2][1]);
                  c = Md42.CC(Md42.HH, H, c, d, a, b, block[4], S[2][2]);
                  b = Md42.CC(Md42.HH, H, b, c, d, a, block[12], S[2][3]);
                  a = Md42.CC(Md42.HH, H, a, b, c, d, block[2], S[2][0]);
                  d = Md42.CC(Md42.HH, H, d, a, b, c, block[10], S[2][1]);
                  c = Md42.CC(Md42.HH, H, c, d, a, b, block[6], S[2][2]);
                  b = Md42.CC(Md42.HH, H, b, c, d, a, block[14], S[2][3]);
                  a = Md42.CC(Md42.HH, H, a, b, c, d, block[1], S[2][0]);
                  d = Md42.CC(Md42.HH, H, d, a, b, c, block[9], S[2][1]);
                  c = Md42.CC(Md42.HH, H, c, d, a, b, block[5], S[2][2]);
                  b = Md42.CC(Md42.HH, H, b, c, d, a, block[13], S[2][3]);
                  a = Md42.CC(Md42.HH, H, a, b, c, d, block[3], S[2][0]);
                  d = Md42.CC(Md42.HH, H, d, a, b, c, block[11], S[2][1]);
                  c = Md42.CC(Md42.HH, H, c, d, a, b, block[7], S[2][2]);
                  b = Md42.CC(Md42.HH, H, b, c, d, a, block[15], S[2][3]);
                  this.state.hash = [this.state.hash[0] + a | 0, this.state.hash[1] + b | 0, this.state.hash[2] + c | 0, this.state.hash[3] + d | 0];
                }
              )
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }], [{
              key: "FF",
              value: function FF(x, y, z) {
                return x & y | ~x & z;
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "GG",
              value: function GG(x, y, z) {
                return x & y | x & z | y & z;
              }
              /**
               * @private
               * @ignore
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @returns {number}
               */
            }, {
              key: "HH",
              value: function HH(x, y, z) {
                return x ^ y ^ z;
              }
              /**
               * @private
               * @ignore
               * @param {function} f
               * @param {number} k
               * @param {number} a
               * @param {number} x
               * @param {number} y
               * @param {number} z
               * @param {number} m
               * @param {number} s
               * @returns {number}
               * @constructor
               */
            }, {
              key: "CC",
              value: function CC(f2, k, a, x, y, z, m, s) {
                return Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                  /* rotateLeft */
                  "a"
                ])(a + f2(x, y, z) + m + k, s) | 0;
              }
            }]);
            return Md42;
          }(_hasher32le__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Md4;
        },
        /* 17 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          var _hasher32be__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
          var _tools_tools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0);
          function _typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof = function _typeof2(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof = function _typeof2(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof(obj);
          }
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          function _get(target, property, receiver) {
            if (typeof Reflect !== "undefined" && Reflect.get) {
              _get = Reflect.get;
            } else {
              _get = function _get2(target2, property2, receiver2) {
                var base = _superPropBase(target2, property2);
                if (!base)
                  return;
                var desc = Object.getOwnPropertyDescriptor(base, property2);
                if (desc.get) {
                  return desc.get.call(receiver2);
                }
                return desc.value;
              };
            }
            return _get(target, property, receiver || target);
          }
          function _superPropBase(object, property) {
            while (!Object.prototype.hasOwnProperty.call(object, property)) {
              object = _getPrototypeOf(object);
              if (object === null)
                break;
            }
            return object;
          }
          function _inherits(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf(subClass, superClass);
          }
          function _setPrototypeOf(o, p) {
            _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf(o, p);
          }
          function _createSuper(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn(this, result);
            };
          }
          function _possibleConstructorReturn(self2, call) {
            if (call && (_typeof(call) === "object" || typeof call === "function")) {
              return call;
            } else if (call !== void 0) {
              throw new TypeError("Derived constructors may only return object or undefined");
            }
            return _assertThisInitialized(self2);
          }
          function _assertThisInitialized(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf(o) {
            _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf(o);
          }
          var K = [1518500249, 1859775393, 2400959708, 3395469782];
          var Sha0 = function(_Hasher32be) {
            _inherits(Sha02, _Hasher32be);
            var _super = _createSuper(Sha02);
            function Sha02(options) {
              var _this;
              _classCallCheck(this, Sha02);
              _this = _super.call(this, options);
              _this.options.rounds = _this.options.rounds || 80;
              _this.W = new Array(80);
              return _this;
            }
            _createClass(Sha02, [{
              key: "reset",
              value: function reset() {
                _get(_getPrototypeOf(Sha02.prototype), "reset", this).call(this);
                this.state.hash = [1732584193 | 0, 4023233417 | 0, 2562383102 | 0, 271733878 | 0, 3285377520 | 0];
              }
              /**
               * Process ready blocks
               *
               * @protected
               * @ignore
               * @param {number[]} block - Block
               */
            }, {
              key: "processBlock",
              value: function processBlock(block) {
                var a = this.state.hash[0] | 0;
                var b = this.state.hash[1] | 0;
                var c = this.state.hash[2] | 0;
                var d = this.state.hash[3] | 0;
                var e = this.state.hash[4] | 0;
                for (var i = 0; i < this.options.rounds; i++) {
                  if (i < 16) {
                    this.W[i] = block[i] | 0;
                  } else {
                    this.W[i] = this.W[i - 3] ^ this.W[i - 8] ^ this.W[i - 14] ^ this.W[i - 16] | 0;
                  }
                  var t = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(a, 5) + e + this.W[i] + K[i / 20 >> 0] | 0;
                  if (i < 20) {
                    t = t + (b & c | ~b & d) | 0;
                  } else if (i < 40) {
                    t = t + (b ^ c ^ d) | 0;
                  } else if (i < 60) {
                    t = t + (b & c | b & d | c & d) | 0;
                  } else {
                    t = t + (b ^ c ^ d) | 0;
                  }
                  e = d;
                  d = c;
                  c = Object(_tools_tools__WEBPACK_IMPORTED_MODULE_1__[
                    /* rotateLeft */
                    "a"
                  ])(b, 30) | 0;
                  b = a;
                  a = t;
                }
                this.state.hash[0] = this.state.hash[0] + a | 0;
                this.state.hash[1] = this.state.hash[1] + b | 0;
                this.state.hash[2] = this.state.hash[2] + c | 0;
                this.state.hash[3] = this.state.hash[3] + d | 0;
                this.state.hash[4] = this.state.hash[4] + e | 0;
              }
              /**
               * Finalize hash and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                this.addPaddingISO7816(this.state.message.length < 56 ? 56 - this.state.message.length | 0 : 120 - this.state.message.length | 0);
                this.addLengthBits();
                this.process();
                return this.getStateHash();
              }
            }]);
            return Sha02;
          }(_hasher32be__WEBPACK_IMPORTED_MODULE_0__[
            /* default */
            "a"
          ]);
          __webpack_exports__["a"] = Sha0;
        },
        /* 18 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.d(__webpack_exports__, "a", function() {
            return fromArrayBuffer;
          });
          function fromArrayBuffer(buffer) {
            var s = "";
            var bytes = new Uint8Array(buffer);
            for (var i = 0; i < bytes.length; i++) {
              s += String.fromCharCode(bytes[i]);
            }
            return s;
          }
        },
        ,
        ,
        /* 21 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          var Hmac = function() {
            function Hmac2(key, hasher) {
              _classCallCheck(this, Hmac2);
              if (key.length > hasher.blockSizeInBytes) {
                hasher.update(key);
                key = hasher.finalize();
                hasher.reset();
              }
              for (var i = key.length; i < hasher.blockSizeInBytes; i++) {
                key += "\0";
              }
              this.oPad = "";
              for (var _i = 0; _i < key.length; _i++) {
                hasher.update(String.fromCharCode(54 ^ key.charCodeAt(_i)));
                this.oPad += String.fromCharCode(92 ^ key.charCodeAt(_i));
              }
              this.hasher = hasher;
            }
            _createClass(Hmac2, [{
              key: "update",
              value: function update(message) {
                this.hasher.update(message);
              }
              /**
               * Finalize hmac and return result
               *
               * @returns {string}
               */
            }, {
              key: "finalize",
              value: function finalize() {
                var hash = this.hasher.finalize();
                this.hasher.reset();
                this.hasher.update(this.oPad);
                this.hasher.update(hash);
                return this.hasher.finalize();
              }
            }]);
            return Hmac2;
          }();
          __webpack_exports__["a"] = Hmac;
        },
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        /* 31 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          var _hasher_has160__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14);
          var _hasher_md2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13);
          var _hasher_md4__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(16);
          var _hasher_md5__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10);
          var _hasher_ripemd__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(8);
          var _hasher_sha0__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(17);
          var _hasher_sha1__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(11);
          var _hasher_sha256__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(7);
          var _hasher_sha512__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6);
          var _hasher_snefru__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(9);
          var _hasher_whirlpool__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(12);
          var _encoder_utf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(1);
          var _encoder_array_buffer__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(18);
          var _encoder_hex__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(2);
          var _encoder_base64__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(15);
          var _mac_hmac__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(21);
          function _classCallCheck(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
              var descriptor = props[i];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties(Constructor, staticProps);
            return Constructor;
          }
          var CryptoApi2 = function() {
            function CryptoApi3() {
              _classCallCheck(this, CryptoApi3);
              this.encoder = {};
              this.encoder.fromUtf = _encoder_utf__WEBPACK_IMPORTED_MODULE_11__[
                /* fromUtf */
                "a"
              ];
              this.encoder.fromArrayBuffer = _encoder_array_buffer__WEBPACK_IMPORTED_MODULE_12__[
                /* fromArrayBuffer */
                "a"
              ];
              this.encoder.toHex = _encoder_hex__WEBPACK_IMPORTED_MODULE_13__[
                /* toHex */
                "a"
              ];
              this.encoder.toBase64 = _encoder_base64__WEBPACK_IMPORTED_MODULE_14__[
                /* toBase64 */
                "a"
              ];
            }
            _createClass(CryptoApi3, [{
              key: "getHasher",
              value: function getHasher(name, options) {
                options = options || {};
                switch (name) {
                  case "has160":
                    return new _hasher_has160__WEBPACK_IMPORTED_MODULE_0__[
                      /* default */
                      "a"
                    ](options);
                  case "md2":
                    return new _hasher_md2__WEBPACK_IMPORTED_MODULE_1__[
                      /* default */
                      "a"
                    ](options);
                  case "md4":
                    return new _hasher_md4__WEBPACK_IMPORTED_MODULE_2__[
                      /* default */
                      "a"
                    ](options);
                  case "md5":
                    return new _hasher_md5__WEBPACK_IMPORTED_MODULE_3__[
                      /* default */
                      "a"
                    ](options);
                  case "ripemd128":
                    options = Object.assign({}, {
                      length: 128
                    }, options);
                    return new _hasher_ripemd__WEBPACK_IMPORTED_MODULE_4__[
                      /* default */
                      "a"
                    ](options);
                  case "ripemd":
                  case "ripemd160":
                    options = Object.assign({}, {
                      length: 160
                    }, options);
                    return new _hasher_ripemd__WEBPACK_IMPORTED_MODULE_4__[
                      /* default */
                      "a"
                    ](options);
                  case "ripemd256":
                    options = Object.assign({}, {
                      length: 256
                    }, options);
                    return new _hasher_ripemd__WEBPACK_IMPORTED_MODULE_4__[
                      /* default */
                      "a"
                    ](options);
                  case "ripemd320":
                    options = Object.assign({}, {
                      length: 320
                    }, options);
                    return new _hasher_ripemd__WEBPACK_IMPORTED_MODULE_4__[
                      /* default */
                      "a"
                    ](options);
                  case "sha0":
                    return new _hasher_sha0__WEBPACK_IMPORTED_MODULE_5__[
                      /* default */
                      "a"
                    ](options);
                  case "sha1":
                    return new _hasher_sha1__WEBPACK_IMPORTED_MODULE_6__[
                      /* default */
                      "a"
                    ](options);
                  case "sha224":
                    options = Object.assign({}, {
                      length: 224
                    }, options);
                    return new _hasher_sha256__WEBPACK_IMPORTED_MODULE_7__[
                      /* default */
                      "a"
                    ](options);
                  case "sha256":
                    options = Object.assign({}, {
                      length: 256
                    }, options);
                    return new _hasher_sha256__WEBPACK_IMPORTED_MODULE_7__[
                      /* default */
                      "a"
                    ](options);
                  case "sha384":
                    options = Object.assign({}, {
                      length: 384
                    }, options);
                    return new _hasher_sha512__WEBPACK_IMPORTED_MODULE_8__[
                      /* default */
                      "a"
                    ](options);
                  case "sha512":
                    options = Object.assign({}, {
                      length: 512
                    }, options);
                    return new _hasher_sha512__WEBPACK_IMPORTED_MODULE_8__[
                      /* default */
                      "a"
                    ](options);
                  case "sha512/224":
                    options = Object.assign({}, {
                      length: 224
                    }, options);
                    return new _hasher_sha512__WEBPACK_IMPORTED_MODULE_8__[
                      /* default */
                      "a"
                    ](options);
                  case "sha512/256":
                    options = Object.assign({}, {
                      length: 256
                    }, options);
                    return new _hasher_sha512__WEBPACK_IMPORTED_MODULE_8__[
                      /* default */
                      "a"
                    ](options);
                  case "snefru":
                  case "snefru128":
                  case "snefru128/8":
                    options = Object.assign({}, {
                      length: 128
                    }, options);
                    return new _hasher_snefru__WEBPACK_IMPORTED_MODULE_9__[
                      /* default */
                      "a"
                    ](options);
                  case "snefru256":
                  case "snefru256/8":
                    options = Object.assign({}, {
                      length: 256
                    }, options);
                    return new _hasher_snefru__WEBPACK_IMPORTED_MODULE_9__[
                      /* default */
                      "a"
                    ](options);
                  case "snefru128/2":
                    options = Object.assign({}, {
                      length: 128,
                      rounds: 2
                    }, options);
                    return new _hasher_snefru__WEBPACK_IMPORTED_MODULE_9__[
                      /* default */
                      "a"
                    ](options);
                  case "snefru256/4":
                    options = Object.assign({}, {
                      length: 256,
                      rounds: 4
                    }, options);
                    return new _hasher_snefru__WEBPACK_IMPORTED_MODULE_9__[
                      /* default */
                      "a"
                    ](options);
                  case "whirlpool":
                    return new _hasher_whirlpool__WEBPACK_IMPORTED_MODULE_10__[
                      /* default */
                      "a"
                    ](options);
                  case "whirlpool-0":
                    options = Object.assign({}, {
                      type: "0"
                    }, options);
                    return new _hasher_whirlpool__WEBPACK_IMPORTED_MODULE_10__[
                      /* default */
                      "a"
                    ](options);
                  case "whirlpool-t":
                    options = Object.assign({}, {
                      type: "t"
                    }, options);
                    return new _hasher_whirlpool__WEBPACK_IMPORTED_MODULE_10__[
                      /* default */
                      "a"
                    ](options);
                }
              }
              /**
               * Hash UTF message and return result in hex
               *
               * @param {string} name
               * @param {string} message
               * @param {Object} options
               * @returns {string}
               */
            }, {
              key: "hash",
              value: function hash(name, message, options) {
                options = options || {};
                var hasher = this.getHasher(name, options);
                hasher.update(Object(_encoder_utf__WEBPACK_IMPORTED_MODULE_11__[
                  /* fromUtf */
                  "a"
                ])(message));
                return Object(_encoder_hex__WEBPACK_IMPORTED_MODULE_13__[
                  /* toHex */
                  "a"
                ])(hasher.finalize());
              }
              /**
               * Get HMAC instance
               *
               * @param {string} key
               * @param {Hasher} hasher
               * @returns {Hmac}
               */
            }, {
              key: "getHmac",
              value: function getHmac(key, hasher) {
                return new _mac_hmac__WEBPACK_IMPORTED_MODULE_15__[
                  /* default */
                  "a"
                ](key, hasher);
              }
              /**
               * HMAC with UTF key from UTF message and return result in hex
               *
               * @param {string} key
               * @param {string} message
               * @param {Hasher} hasher
               * @returns {string}
               */
            }, {
              key: "hmac",
              value: function hmac(key, message, hasher) {
                var mac = this.getHmac(Object(_encoder_utf__WEBPACK_IMPORTED_MODULE_11__[
                  /* fromUtf */
                  "a"
                ])(key), hasher);
                mac.update(Object(_encoder_utf__WEBPACK_IMPORTED_MODULE_11__[
                  /* fromUtf */
                  "a"
                ])(message));
                return Object(_encoder_hex__WEBPACK_IMPORTED_MODULE_13__[
                  /* toHex */
                  "a"
                ])(mac.finalize());
              }
            }]);
            return CryptoApi3;
          }();
          CryptoApi2 = new CryptoApi2();
          __webpack_exports__["default"] = CryptoApi2;
        },
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        ,
        /* 40 */
        /***/
        function(__webpack_module__, __webpack_exports__, __webpack_require__) {
          "use strict";
          __webpack_require__.r(__webpack_exports__);
          var _crypto_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31);
          module.exports = _crypto_api__WEBPACK_IMPORTED_MODULE_0__["default"];
        }
        /******/
      ])["default"]
    );
  }
});

// browser-external:buffer
var require_buffer2 = __commonJS({
  "browser-external:buffer"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "buffer" has been externalized for browser compatibility. Cannot access "buffer.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports, module) {
    (function(module2, exports2) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base === "le" || base === "be") {
            endian = base;
            base = 10;
          }
          this._init(number || 0, base || 10, endian || "be");
        }
      }
      if (typeof module2 === "object") {
        module2.exports = BN;
      } else {
        exports2.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base, endian);
        }
        if (base === "hex") {
          base = 16;
        }
        assert(base === (base | 0) && base >= 2 && base <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base, endian);
      };
      BN.prototype._initArray = function _initArray(number, base, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string, index) {
        var c = string.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string, lowerBound, index) {
        var r = parseHex4Bits(string, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base | 0;
        var total = number.length - start;
        var mod = total % limbLen;
        var end = Math.min(total, total - mod) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base);
          for (i = 0; i < mod; i++) {
            pow *= base;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString(base, padding) {
        base = base || 10;
        padding = padding | 0 || 1;
        var out;
        if (base === 16 || base === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base === (base | 0) && base >= 2 && base <= 36) {
          var groupSize = groupSizes[base];
          var groupBase = groupBases[base];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length);
      };
      BN.prototype.toArray = function toArray(endian, length) {
        return this.toArrayLike(Array, endian, length);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
        var byteLength = this.byteLength();
        var reqLength = length || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io2 = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io2;
              io2 = rtwdf_ * io2 + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io2;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io2;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.iadd(num);
            }
          }
          return {
            div,
            mod
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod = res.mod.neg();
            if (positive && mod.negative !== 0) {
              mod.isub(num);
            }
          }
          return {
            div: res.div,
            mod
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name, p) {
        this.name = name;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name) {
        if (primes[name])
          return primes[name];
        var prime2;
        if (name === "k256") {
          prime2 = new K256();
        } else if (name === "p224") {
          prime2 = new P224();
        } else if (name === "p192") {
          prime2 = new P192();
        } else if (name === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name);
        }
        primes[name] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(
          a.red && a.red === b.red,
          "red works only with red numbers"
        );
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module === "undefined" || module, exports);
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key))
        continue;
      if (key === "SlowBuffer" || key === "Buffer")
        continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key))
        continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow")
        continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/asn1.js/lib/asn1/base/reporter.js
var require_reporter = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/reporter.js"(exports) {
    "use strict";
    var inherits = require_inherits_browser();
    function Reporter(options) {
      this._reporterState = {
        obj: null,
        path: [],
        options: options || {},
        errors: []
      };
    }
    exports.Reporter = Reporter;
    Reporter.prototype.isError = function isError(obj) {
      return obj instanceof ReporterError;
    };
    Reporter.prototype.save = function save() {
      const state = this._reporterState;
      return { obj: state.obj, pathLen: state.path.length };
    };
    Reporter.prototype.restore = function restore(data) {
      const state = this._reporterState;
      state.obj = data.obj;
      state.path = state.path.slice(0, data.pathLen);
    };
    Reporter.prototype.enterKey = function enterKey(key) {
      return this._reporterState.path.push(key);
    };
    Reporter.prototype.exitKey = function exitKey(index) {
      const state = this._reporterState;
      state.path = state.path.slice(0, index - 1);
    };
    Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
      const state = this._reporterState;
      this.exitKey(index);
      if (state.obj !== null)
        state.obj[key] = value;
    };
    Reporter.prototype.path = function path() {
      return this._reporterState.path.join("/");
    };
    Reporter.prototype.enterObject = function enterObject() {
      const state = this._reporterState;
      const prev = state.obj;
      state.obj = {};
      return prev;
    };
    Reporter.prototype.leaveObject = function leaveObject(prev) {
      const state = this._reporterState;
      const now = state.obj;
      state.obj = prev;
      return now;
    };
    Reporter.prototype.error = function error(msg) {
      let err;
      const state = this._reporterState;
      const inherited = msg instanceof ReporterError;
      if (inherited) {
        err = msg;
      } else {
        err = new ReporterError(state.path.map(function(elem) {
          return "[" + JSON.stringify(elem) + "]";
        }).join(""), msg.message || msg, msg.stack);
      }
      if (!state.options.partial)
        throw err;
      if (!inherited)
        state.errors.push(err);
      return err;
    };
    Reporter.prototype.wrapResult = function wrapResult(result) {
      const state = this._reporterState;
      if (!state.options.partial)
        return result;
      return {
        result: this.isError(result) ? null : result,
        errors: state.errors
      };
    };
    function ReporterError(path, msg) {
      this.path = path;
      this.rethrow(msg);
    }
    inherits(ReporterError, Error);
    ReporterError.prototype.rethrow = function rethrow(msg) {
      this.message = msg + " at: " + (this.path || "(shallow)");
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, ReporterError);
      if (!this.stack) {
        try {
          throw new Error(this.message);
        } catch (e) {
          this.stack = e.stack;
        }
      }
      return this;
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/buffer.js
var require_buffer3 = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/buffer.js"(exports) {
    "use strict";
    var inherits = require_inherits_browser();
    var Reporter = require_reporter().Reporter;
    var Buffer2 = require_safer().Buffer;
    function DecoderBuffer(base, options) {
      Reporter.call(this, options);
      if (!Buffer2.isBuffer(base)) {
        this.error("Input not Buffer");
        return;
      }
      this.base = base;
      this.offset = 0;
      this.length = base.length;
    }
    inherits(DecoderBuffer, Reporter);
    exports.DecoderBuffer = DecoderBuffer;
    DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
      if (data instanceof DecoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && Buffer2.isBuffer(data.base) && data.constructor.name === "DecoderBuffer" && typeof data.offset === "number" && typeof data.length === "number" && typeof data.save === "function" && typeof data.restore === "function" && typeof data.isEmpty === "function" && typeof data.readUInt8 === "function" && typeof data.skip === "function" && typeof data.raw === "function";
      return isCompatible;
    };
    DecoderBuffer.prototype.save = function save() {
      return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
    };
    DecoderBuffer.prototype.restore = function restore(save) {
      const res = new DecoderBuffer(this.base);
      res.offset = save.offset;
      res.length = this.offset;
      this.offset = save.offset;
      Reporter.prototype.restore.call(this, save.reporter);
      return res;
    };
    DecoderBuffer.prototype.isEmpty = function isEmpty() {
      return this.offset === this.length;
    };
    DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
      if (this.offset + 1 <= this.length)
        return this.base.readUInt8(this.offset++, true);
      else
        return this.error(fail || "DecoderBuffer overrun");
    };
    DecoderBuffer.prototype.skip = function skip(bytes, fail) {
      if (!(this.offset + bytes <= this.length))
        return this.error(fail || "DecoderBuffer overrun");
      const res = new DecoderBuffer(this.base);
      res._reporterState = this._reporterState;
      res.offset = this.offset;
      res.length = this.offset + bytes;
      this.offset += bytes;
      return res;
    };
    DecoderBuffer.prototype.raw = function raw(save) {
      return this.base.slice(save ? save.offset : this.offset, this.length);
    };
    function EncoderBuffer(value, reporter) {
      if (Array.isArray(value)) {
        this.length = 0;
        this.value = value.map(function(item) {
          if (!EncoderBuffer.isEncoderBuffer(item))
            item = new EncoderBuffer(item, reporter);
          this.length += item.length;
          return item;
        }, this);
      } else if (typeof value === "number") {
        if (!(0 <= value && value <= 255))
          return reporter.error("non-byte EncoderBuffer value");
        this.value = value;
        this.length = 1;
      } else if (typeof value === "string") {
        this.value = value;
        this.length = Buffer2.byteLength(value);
      } else if (Buffer2.isBuffer(value)) {
        this.value = value;
        this.length = value.length;
      } else {
        return reporter.error("Unsupported type: " + typeof value);
      }
    }
    exports.EncoderBuffer = EncoderBuffer;
    EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
      if (data instanceof EncoderBuffer) {
        return true;
      }
      const isCompatible = typeof data === "object" && data.constructor.name === "EncoderBuffer" && typeof data.length === "number" && typeof data.join === "function";
      return isCompatible;
    };
    EncoderBuffer.prototype.join = function join(out, offset) {
      if (!out)
        out = Buffer2.alloc(this.length);
      if (!offset)
        offset = 0;
      if (this.length === 0)
        return out;
      if (Array.isArray(this.value)) {
        this.value.forEach(function(item) {
          item.join(out, offset);
          offset += item.length;
        });
      } else {
        if (typeof this.value === "number")
          out[offset] = this.value;
        else if (typeof this.value === "string")
          out.write(this.value, offset);
        else if (Buffer2.isBuffer(this.value))
          this.value.copy(out, offset);
        offset += this.length;
      }
      return out;
    };
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports, module) {
    module.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/node.js
var require_node = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/node.js"(exports, module) {
    "use strict";
    var Reporter = require_reporter().Reporter;
    var EncoderBuffer = require_buffer3().EncoderBuffer;
    var DecoderBuffer = require_buffer3().DecoderBuffer;
    var assert = require_minimalistic_assert();
    var tags = [
      "seq",
      "seqof",
      "set",
      "setof",
      "objid",
      "bool",
      "gentime",
      "utctime",
      "null_",
      "enum",
      "int",
      "objDesc",
      "bitstr",
      "bmpstr",
      "charstr",
      "genstr",
      "graphstr",
      "ia5str",
      "iso646str",
      "numstr",
      "octstr",
      "printstr",
      "t61str",
      "unistr",
      "utf8str",
      "videostr"
    ];
    var methods = [
      "key",
      "obj",
      "use",
      "optional",
      "explicit",
      "implicit",
      "def",
      "choice",
      "any",
      "contains"
    ].concat(tags);
    var overrided = [
      "_peekTag",
      "_decodeTag",
      "_use",
      "_decodeStr",
      "_decodeObjid",
      "_decodeTime",
      "_decodeNull",
      "_decodeInt",
      "_decodeBool",
      "_decodeList",
      "_encodeComposite",
      "_encodeStr",
      "_encodeObjid",
      "_encodeTime",
      "_encodeNull",
      "_encodeInt",
      "_encodeBool"
    ];
    function Node(enc, parent, name) {
      const state = {};
      this._baseState = state;
      state.name = name;
      state.enc = enc;
      state.parent = parent || null;
      state.children = null;
      state.tag = null;
      state.args = null;
      state.reverseArgs = null;
      state.choice = null;
      state.optional = false;
      state.any = false;
      state.obj = false;
      state.use = null;
      state.useDecoder = null;
      state.key = null;
      state["default"] = null;
      state.explicit = null;
      state.implicit = null;
      state.contains = null;
      if (!state.parent) {
        state.children = [];
        this._wrap();
      }
    }
    module.exports = Node;
    var stateProps = [
      "enc",
      "parent",
      "children",
      "tag",
      "args",
      "reverseArgs",
      "choice",
      "optional",
      "any",
      "obj",
      "use",
      "alteredUse",
      "key",
      "default",
      "explicit",
      "implicit",
      "contains"
    ];
    Node.prototype.clone = function clone() {
      const state = this._baseState;
      const cstate = {};
      stateProps.forEach(function(prop) {
        cstate[prop] = state[prop];
      });
      const res = new this.constructor(cstate.parent);
      res._baseState = cstate;
      return res;
    };
    Node.prototype._wrap = function wrap() {
      const state = this._baseState;
      methods.forEach(function(method) {
        this[method] = function _wrappedMethod() {
          const clone = new this.constructor(this);
          state.children.push(clone);
          return clone[method].apply(clone, arguments);
        };
      }, this);
    };
    Node.prototype._init = function init(body) {
      const state = this._baseState;
      assert(state.parent === null);
      body.call(this);
      state.children = state.children.filter(function(child) {
        return child._baseState.parent === this;
      }, this);
      assert.equal(state.children.length, 1, "Root node can have only one child");
    };
    Node.prototype._useArgs = function useArgs(args) {
      const state = this._baseState;
      const children = args.filter(function(arg) {
        return arg instanceof this.constructor;
      }, this);
      args = args.filter(function(arg) {
        return !(arg instanceof this.constructor);
      }, this);
      if (children.length !== 0) {
        assert(state.children === null);
        state.children = children;
        children.forEach(function(child) {
          child._baseState.parent = this;
        }, this);
      }
      if (args.length !== 0) {
        assert(state.args === null);
        state.args = args;
        state.reverseArgs = args.map(function(arg) {
          if (typeof arg !== "object" || arg.constructor !== Object)
            return arg;
          const res = {};
          Object.keys(arg).forEach(function(key) {
            if (key == (key | 0))
              key |= 0;
            const value = arg[key];
            res[value] = key;
          });
          return res;
        });
      }
    };
    overrided.forEach(function(method) {
      Node.prototype[method] = function _overrided() {
        const state = this._baseState;
        throw new Error(method + " not implemented for encoding: " + state.enc);
      };
    });
    tags.forEach(function(tag) {
      Node.prototype[tag] = function _tagMethod() {
        const state = this._baseState;
        const args = Array.prototype.slice.call(arguments);
        assert(state.tag === null);
        state.tag = tag;
        this._useArgs(args);
        return this;
      };
    });
    Node.prototype.use = function use(item) {
      assert(item);
      const state = this._baseState;
      assert(state.use === null);
      state.use = item;
      return this;
    };
    Node.prototype.optional = function optional() {
      const state = this._baseState;
      state.optional = true;
      return this;
    };
    Node.prototype.def = function def(val) {
      const state = this._baseState;
      assert(state["default"] === null);
      state["default"] = val;
      state.optional = true;
      return this;
    };
    Node.prototype.explicit = function explicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.explicit = num;
      return this;
    };
    Node.prototype.implicit = function implicit(num) {
      const state = this._baseState;
      assert(state.explicit === null && state.implicit === null);
      state.implicit = num;
      return this;
    };
    Node.prototype.obj = function obj() {
      const state = this._baseState;
      const args = Array.prototype.slice.call(arguments);
      state.obj = true;
      if (args.length !== 0)
        this._useArgs(args);
      return this;
    };
    Node.prototype.key = function key(newKey) {
      const state = this._baseState;
      assert(state.key === null);
      state.key = newKey;
      return this;
    };
    Node.prototype.any = function any() {
      const state = this._baseState;
      state.any = true;
      return this;
    };
    Node.prototype.choice = function choice(obj) {
      const state = this._baseState;
      assert(state.choice === null);
      state.choice = obj;
      this._useArgs(Object.keys(obj).map(function(key) {
        return obj[key];
      }));
      return this;
    };
    Node.prototype.contains = function contains(item) {
      const state = this._baseState;
      assert(state.use === null);
      state.contains = item;
      return this;
    };
    Node.prototype._decode = function decode(input, options) {
      const state = this._baseState;
      if (state.parent === null)
        return input.wrapResult(state.children[0]._decode(input, options));
      let result = state["default"];
      let present = true;
      let prevKey = null;
      if (state.key !== null)
        prevKey = input.enterKey(state.key);
      if (state.optional) {
        let tag = null;
        if (state.explicit !== null)
          tag = state.explicit;
        else if (state.implicit !== null)
          tag = state.implicit;
        else if (state.tag !== null)
          tag = state.tag;
        if (tag === null && !state.any) {
          const save = input.save();
          try {
            if (state.choice === null)
              this._decodeGeneric(state.tag, input, options);
            else
              this._decodeChoice(input, options);
            present = true;
          } catch (e) {
            present = false;
          }
          input.restore(save);
        } else {
          present = this._peekTag(input, tag, state.any);
          if (input.isError(present))
            return present;
        }
      }
      let prevObj;
      if (state.obj && present)
        prevObj = input.enterObject();
      if (present) {
        if (state.explicit !== null) {
          const explicit = this._decodeTag(input, state.explicit);
          if (input.isError(explicit))
            return explicit;
          input = explicit;
        }
        const start = input.offset;
        if (state.use === null && state.choice === null) {
          let save;
          if (state.any)
            save = input.save();
          const body = this._decodeTag(
            input,
            state.implicit !== null ? state.implicit : state.tag,
            state.any
          );
          if (input.isError(body))
            return body;
          if (state.any)
            result = input.raw(save);
          else
            input = body;
        }
        if (options && options.track && state.tag !== null)
          options.track(input.path(), start, input.length, "tagged");
        if (options && options.track && state.tag !== null)
          options.track(input.path(), input.offset, input.length, "content");
        if (state.any) {
        } else if (state.choice === null) {
          result = this._decodeGeneric(state.tag, input, options);
        } else {
          result = this._decodeChoice(input, options);
        }
        if (input.isError(result))
          return result;
        if (!state.any && state.choice === null && state.children !== null) {
          state.children.forEach(function decodeChildren(child) {
            child._decode(input, options);
          });
        }
        if (state.contains && (state.tag === "octstr" || state.tag === "bitstr")) {
          const data = new DecoderBuffer(result);
          result = this._getUse(state.contains, input._reporterState.obj)._decode(data, options);
        }
      }
      if (state.obj && present)
        result = input.leaveObject(prevObj);
      if (state.key !== null && (result !== null || present === true))
        input.leaveKey(prevKey, state.key, result);
      else if (prevKey !== null)
        input.exitKey(prevKey);
      return result;
    };
    Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
      const state = this._baseState;
      if (tag === "seq" || tag === "set")
        return null;
      if (tag === "seqof" || tag === "setof")
        return this._decodeList(input, tag, state.args[0], options);
      else if (/str$/.test(tag))
        return this._decodeStr(input, tag, options);
      else if (tag === "objid" && state.args)
        return this._decodeObjid(input, state.args[0], state.args[1], options);
      else if (tag === "objid")
        return this._decodeObjid(input, null, null, options);
      else if (tag === "gentime" || tag === "utctime")
        return this._decodeTime(input, tag, options);
      else if (tag === "null_")
        return this._decodeNull(input, options);
      else if (tag === "bool")
        return this._decodeBool(input, options);
      else if (tag === "objDesc")
        return this._decodeStr(input, tag, options);
      else if (tag === "int" || tag === "enum")
        return this._decodeInt(input, state.args && state.args[0], options);
      if (state.use !== null) {
        return this._getUse(state.use, input._reporterState.obj)._decode(input, options);
      } else {
        return input.error("unknown tag: " + tag);
      }
    };
    Node.prototype._getUse = function _getUse(entity, obj) {
      const state = this._baseState;
      state.useDecoder = this._use(entity, obj);
      assert(state.useDecoder._baseState.parent === null);
      state.useDecoder = state.useDecoder._baseState.children[0];
      if (state.implicit !== state.useDecoder._baseState.implicit) {
        state.useDecoder = state.useDecoder.clone();
        state.useDecoder._baseState.implicit = state.implicit;
      }
      return state.useDecoder;
    };
    Node.prototype._decodeChoice = function decodeChoice(input, options) {
      const state = this._baseState;
      let result = null;
      let match = false;
      Object.keys(state.choice).some(function(key) {
        const save = input.save();
        const node = state.choice[key];
        try {
          const value = node._decode(input, options);
          if (input.isError(value))
            return false;
          result = { type: key, value };
          match = true;
        } catch (e) {
          input.restore(save);
          return false;
        }
        return true;
      }, this);
      if (!match)
        return input.error("Choice not matched");
      return result;
    };
    Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
      return new EncoderBuffer(data, this.reporter);
    };
    Node.prototype._encode = function encode(data, reporter, parent) {
      const state = this._baseState;
      if (state["default"] !== null && state["default"] === data)
        return;
      const result = this._encodeValue(data, reporter, parent);
      if (result === void 0)
        return;
      if (this._skipDefault(result, reporter, parent))
        return;
      return result;
    };
    Node.prototype._encodeValue = function encode(data, reporter, parent) {
      const state = this._baseState;
      if (state.parent === null)
        return state.children[0]._encode(data, reporter || new Reporter());
      let result = null;
      this.reporter = reporter;
      if (state.optional && data === void 0) {
        if (state["default"] !== null)
          data = state["default"];
        else
          return;
      }
      let content = null;
      let primitive = false;
      if (state.any) {
        result = this._createEncoderBuffer(data);
      } else if (state.choice) {
        result = this._encodeChoice(data, reporter);
      } else if (state.contains) {
        content = this._getUse(state.contains, parent)._encode(data, reporter);
        primitive = true;
      } else if (state.children) {
        content = state.children.map(function(child) {
          if (child._baseState.tag === "null_")
            return child._encode(null, reporter, data);
          if (child._baseState.key === null)
            return reporter.error("Child should have a key");
          const prevKey = reporter.enterKey(child._baseState.key);
          if (typeof data !== "object")
            return reporter.error("Child expected, but input is not object");
          const res = child._encode(data[child._baseState.key], reporter, data);
          reporter.leaveKey(prevKey);
          return res;
        }, this).filter(function(child) {
          return child;
        });
        content = this._createEncoderBuffer(content);
      } else {
        if (state.tag === "seqof" || state.tag === "setof") {
          if (!(state.args && state.args.length === 1))
            return reporter.error("Too many args for : " + state.tag);
          if (!Array.isArray(data))
            return reporter.error("seqof/setof, but data is not Array");
          const child = this.clone();
          child._baseState.implicit = null;
          content = this._createEncoderBuffer(data.map(function(item) {
            const state2 = this._baseState;
            return this._getUse(state2.args[0], data)._encode(item, reporter);
          }, child));
        } else if (state.use !== null) {
          result = this._getUse(state.use, parent)._encode(data, reporter);
        } else {
          content = this._encodePrimitive(state.tag, data);
          primitive = true;
        }
      }
      if (!state.any && state.choice === null) {
        const tag = state.implicit !== null ? state.implicit : state.tag;
        const cls = state.implicit === null ? "universal" : "context";
        if (tag === null) {
          if (state.use === null)
            reporter.error("Tag could be omitted only for .use()");
        } else {
          if (state.use === null)
            result = this._encodeComposite(tag, primitive, cls, content);
        }
      }
      if (state.explicit !== null)
        result = this._encodeComposite(state.explicit, false, "context", result);
      return result;
    };
    Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
      const state = this._baseState;
      const node = state.choice[data.type];
      if (!node) {
        assert(
          false,
          data.type + " not found in " + JSON.stringify(Object.keys(state.choice))
        );
      }
      return node._encode(data.value, reporter);
    };
    Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
      const state = this._baseState;
      if (/str$/.test(tag))
        return this._encodeStr(data, tag);
      else if (tag === "objid" && state.args)
        return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
      else if (tag === "objid")
        return this._encodeObjid(data, null, null);
      else if (tag === "gentime" || tag === "utctime")
        return this._encodeTime(data, tag);
      else if (tag === "null_")
        return this._encodeNull();
      else if (tag === "int" || tag === "enum")
        return this._encodeInt(data, state.args && state.reverseArgs[0]);
      else if (tag === "bool")
        return this._encodeBool(data);
      else if (tag === "objDesc")
        return this._encodeStr(data, tag);
      else
        throw new Error("Unsupported tag: " + tag);
    };
    Node.prototype._isNumstr = function isNumstr(str) {
      return /^[0-9 ]*$/.test(str);
    };
    Node.prototype._isPrintstr = function isPrintstr(str) {
      return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
    };
  }
});

// node_modules/asn1.js/lib/asn1/constants/der.js
var require_der = __commonJS({
  "node_modules/asn1.js/lib/asn1/constants/der.js"(exports) {
    "use strict";
    function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    }
    exports.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    };
    exports.tagClassByName = reverse(exports.tagClass);
    exports.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    };
    exports.tagByName = reverse(exports.tag);
  }
});

// node_modules/asn1.js/lib/asn1/encoders/der.js
var require_der2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/der.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var Buffer2 = require_safer().Buffer;
    var Node = require_node();
    var der = require_der();
    function DEREncoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module.exports = DEREncoder;
    DEREncoder.prototype.encode = function encode(data, reporter) {
      return this.tree._encode(data, reporter).join();
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._encodeComposite = function encodeComposite(tag, primitive, cls, content) {
      const encodedTag = encodeTag(tag, primitive, cls, this.reporter);
      if (content.length < 128) {
        const header2 = Buffer2.alloc(2);
        header2[0] = encodedTag;
        header2[1] = content.length;
        return this._createEncoderBuffer([header2, content]);
      }
      let lenOctets = 1;
      for (let i = content.length; i >= 256; i >>= 8)
        lenOctets++;
      const header = Buffer2.alloc(1 + 1 + lenOctets);
      header[0] = encodedTag;
      header[1] = 128 | lenOctets;
      for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
        header[i] = j & 255;
      return this._createEncoderBuffer([header, content]);
    };
    DERNode.prototype._encodeStr = function encodeStr(str, tag) {
      if (tag === "bitstr") {
        return this._createEncoderBuffer([str.unused | 0, str.data]);
      } else if (tag === "bmpstr") {
        const buf = Buffer2.alloc(str.length * 2);
        for (let i = 0; i < str.length; i++) {
          buf.writeUInt16BE(str.charCodeAt(i), i * 2);
        }
        return this._createEncoderBuffer(buf);
      } else if (tag === "numstr") {
        if (!this._isNumstr(str)) {
          return this.reporter.error("Encoding of string type: numstr supports only digits and space");
        }
        return this._createEncoderBuffer(str);
      } else if (tag === "printstr") {
        if (!this._isPrintstr(str)) {
          return this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark");
        }
        return this._createEncoderBuffer(str);
      } else if (/str$/.test(tag)) {
        return this._createEncoderBuffer(str);
      } else if (tag === "objDesc") {
        return this._createEncoderBuffer(str);
      } else {
        return this.reporter.error("Encoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
      if (typeof id === "string") {
        if (!values)
          return this.reporter.error("string objid given, but no values map found");
        if (!values.hasOwnProperty(id))
          return this.reporter.error("objid not found in values map");
        id = values[id].split(/[\s.]+/g);
        for (let i = 0; i < id.length; i++)
          id[i] |= 0;
      } else if (Array.isArray(id)) {
        id = id.slice();
        for (let i = 0; i < id.length; i++)
          id[i] |= 0;
      }
      if (!Array.isArray(id)) {
        return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(id));
      }
      if (!relative) {
        if (id[1] >= 40)
          return this.reporter.error("Second objid identifier OOB");
        id.splice(0, 2, id[0] * 40 + id[1]);
      }
      let size = 0;
      for (let i = 0; i < id.length; i++) {
        let ident = id[i];
        for (size++; ident >= 128; ident >>= 7)
          size++;
      }
      const objid = Buffer2.alloc(size);
      let offset = objid.length - 1;
      for (let i = id.length - 1; i >= 0; i--) {
        let ident = id[i];
        objid[offset--] = ident & 127;
        while ((ident >>= 7) > 0)
          objid[offset--] = 128 | ident & 127;
      }
      return this._createEncoderBuffer(objid);
    };
    function two(num) {
      if (num < 10)
        return "0" + num;
      else
        return num;
    }
    DERNode.prototype._encodeTime = function encodeTime(time, tag) {
      let str;
      const date = new Date(time);
      if (tag === "gentime") {
        str = [
          two(date.getUTCFullYear()),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else if (tag === "utctime") {
        str = [
          two(date.getUTCFullYear() % 100),
          two(date.getUTCMonth() + 1),
          two(date.getUTCDate()),
          two(date.getUTCHours()),
          two(date.getUTCMinutes()),
          two(date.getUTCSeconds()),
          "Z"
        ].join("");
      } else {
        this.reporter.error("Encoding " + tag + " time is not supported yet");
      }
      return this._encodeStr(str, "octstr");
    };
    DERNode.prototype._encodeNull = function encodeNull() {
      return this._createEncoderBuffer("");
    };
    DERNode.prototype._encodeInt = function encodeInt(num, values) {
      if (typeof num === "string") {
        if (!values)
          return this.reporter.error("String int or enum given, but no values map");
        if (!values.hasOwnProperty(num)) {
          return this.reporter.error("Values map doesn't contain: " + JSON.stringify(num));
        }
        num = values[num];
      }
      if (typeof num !== "number" && !Buffer2.isBuffer(num)) {
        const numArray = num.toArray();
        if (!num.sign && numArray[0] & 128) {
          numArray.unshift(0);
        }
        num = Buffer2.from(numArray);
      }
      if (Buffer2.isBuffer(num)) {
        let size2 = num.length;
        if (num.length === 0)
          size2++;
        const out2 = Buffer2.alloc(size2);
        num.copy(out2);
        if (num.length === 0)
          out2[0] = 0;
        return this._createEncoderBuffer(out2);
      }
      if (num < 128)
        return this._createEncoderBuffer(num);
      if (num < 256)
        return this._createEncoderBuffer([0, num]);
      let size = 1;
      for (let i = num; i >= 256; i >>= 8)
        size++;
      const out = new Array(size);
      for (let i = out.length - 1; i >= 0; i--) {
        out[i] = num & 255;
        num >>= 8;
      }
      if (out[0] & 128) {
        out.unshift(0);
      }
      return this._createEncoderBuffer(Buffer2.from(out));
    };
    DERNode.prototype._encodeBool = function encodeBool(value) {
      return this._createEncoderBuffer(value ? 255 : 0);
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getEncoder("der").tree;
    };
    DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
      const state = this._baseState;
      let i;
      if (state["default"] === null)
        return false;
      const data = dataBuffer.join();
      if (state.defaultBuffer === void 0)
        state.defaultBuffer = this._encodeValue(state["default"], reporter, parent).join();
      if (data.length !== state.defaultBuffer.length)
        return false;
      for (i = 0; i < data.length; i++)
        if (data[i] !== state.defaultBuffer[i])
          return false;
      return true;
    };
    function encodeTag(tag, primitive, cls, reporter) {
      let res;
      if (tag === "seqof")
        tag = "seq";
      else if (tag === "setof")
        tag = "set";
      if (der.tagByName.hasOwnProperty(tag))
        res = der.tagByName[tag];
      else if (typeof tag === "number" && (tag | 0) === tag)
        res = tag;
      else
        return reporter.error("Unknown tag: " + tag);
      if (res >= 31)
        return reporter.error("Multi-octet tag encoding unsupported");
      if (!primitive)
        res |= 32;
      res |= der.tagClassByName[cls || "universal"] << 6;
      return res;
    }
  }
});

// node_modules/asn1.js/lib/asn1/encoders/pem.js
var require_pem = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/pem.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var DEREncoder = require_der2();
    function PEMEncoder(entity) {
      DEREncoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMEncoder, DEREncoder);
    module.exports = PEMEncoder;
    PEMEncoder.prototype.encode = function encode(data, options) {
      const buf = DEREncoder.prototype.encode.call(this, data);
      const p = buf.toString("base64");
      const out = ["-----BEGIN " + options.label + "-----"];
      for (let i = 0; i < p.length; i += 64)
        out.push(p.slice(i, i + 64));
      out.push("-----END " + options.label + "-----");
      return out.join("\n");
    };
  }
});

// node_modules/asn1.js/lib/asn1/encoders/index.js
var require_encoders = __commonJS({
  "node_modules/asn1.js/lib/asn1/encoders/index.js"(exports) {
    "use strict";
    var encoders = exports;
    encoders.der = require_der2();
    encoders.pem = require_pem();
  }
});

// node_modules/asn1.js/lib/asn1/decoders/der.js
var require_der3 = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/der.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var bignum = require_bn();
    var DecoderBuffer = require_buffer3().DecoderBuffer;
    var Node = require_node();
    var der = require_der();
    function DERDecoder(entity) {
      this.enc = "der";
      this.name = entity.name;
      this.entity = entity;
      this.tree = new DERNode();
      this.tree._init(entity.body);
    }
    module.exports = DERDecoder;
    DERDecoder.prototype.decode = function decode(data, options) {
      if (!DecoderBuffer.isDecoderBuffer(data)) {
        data = new DecoderBuffer(data, options);
      }
      return this.tree._decode(data, options);
    };
    function DERNode(parent) {
      Node.call(this, "der", parent);
    }
    inherits(DERNode, Node);
    DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
      if (buffer.isEmpty())
        return false;
      const state = buffer.save();
      const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
      if (buffer.isError(decodedTag))
        return decodedTag;
      buffer.restore(state);
      return decodedTag.tag === tag || decodedTag.tagStr === tag || decodedTag.tagStr + "of" === tag || any;
    };
    DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
      const decodedTag = derDecodeTag(
        buffer,
        'Failed to decode tag of "' + tag + '"'
      );
      if (buffer.isError(decodedTag))
        return decodedTag;
      let len = derDecodeLen(
        buffer,
        decodedTag.primitive,
        'Failed to get length of "' + tag + '"'
      );
      if (buffer.isError(len))
        return len;
      if (!any && decodedTag.tag !== tag && decodedTag.tagStr !== tag && decodedTag.tagStr + "of" !== tag) {
        return buffer.error('Failed to match tag: "' + tag + '"');
      }
      if (decodedTag.primitive || len !== null)
        return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
      const state = buffer.save();
      const res = this._skipUntilEnd(
        buffer,
        'Failed to skip indefinite length body: "' + this.tag + '"'
      );
      if (buffer.isError(res))
        return res;
      len = buffer.offset - state.offset;
      buffer.restore(state);
      return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
    };
    DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
      for (; ; ) {
        const tag = derDecodeTag(buffer, fail);
        if (buffer.isError(tag))
          return tag;
        const len = derDecodeLen(buffer, tag.primitive, fail);
        if (buffer.isError(len))
          return len;
        let res;
        if (tag.primitive || len !== null)
          res = buffer.skip(len);
        else
          res = this._skipUntilEnd(buffer, fail);
        if (buffer.isError(res))
          return res;
        if (tag.tagStr === "end")
          break;
      }
    };
    DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder, options) {
      const result = [];
      while (!buffer.isEmpty()) {
        const possibleEnd = this._peekTag(buffer, "end");
        if (buffer.isError(possibleEnd))
          return possibleEnd;
        const res = decoder.decode(buffer, "der", options);
        if (buffer.isError(res) && possibleEnd)
          break;
        result.push(res);
      }
      return result;
    };
    DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
      if (tag === "bitstr") {
        const unused = buffer.readUInt8();
        if (buffer.isError(unused))
          return unused;
        return { unused, data: buffer.raw() };
      } else if (tag === "bmpstr") {
        const raw = buffer.raw();
        if (raw.length % 2 === 1)
          return buffer.error("Decoding of string type: bmpstr length mismatch");
        let str = "";
        for (let i = 0; i < raw.length / 2; i++) {
          str += String.fromCharCode(raw.readUInt16BE(i * 2));
        }
        return str;
      } else if (tag === "numstr") {
        const numstr = buffer.raw().toString("ascii");
        if (!this._isNumstr(numstr)) {
          return buffer.error("Decoding of string type: numstr unsupported characters");
        }
        return numstr;
      } else if (tag === "octstr") {
        return buffer.raw();
      } else if (tag === "objDesc") {
        return buffer.raw();
      } else if (tag === "printstr") {
        const printstr = buffer.raw().toString("ascii");
        if (!this._isPrintstr(printstr)) {
          return buffer.error("Decoding of string type: printstr unsupported characters");
        }
        return printstr;
      } else if (/str$/.test(tag)) {
        return buffer.raw().toString();
      } else {
        return buffer.error("Decoding of string type: " + tag + " unsupported");
      }
    };
    DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
      let result;
      const identifiers = [];
      let ident = 0;
      let subident = 0;
      while (!buffer.isEmpty()) {
        subident = buffer.readUInt8();
        ident <<= 7;
        ident |= subident & 127;
        if ((subident & 128) === 0) {
          identifiers.push(ident);
          ident = 0;
        }
      }
      if (subident & 128)
        identifiers.push(ident);
      const first = identifiers[0] / 40 | 0;
      const second = identifiers[0] % 40;
      if (relative)
        result = identifiers;
      else
        result = [first, second].concat(identifiers.slice(1));
      if (values) {
        let tmp = values[result.join(" ")];
        if (tmp === void 0)
          tmp = values[result.join(".")];
        if (tmp !== void 0)
          result = tmp;
      }
      return result;
    };
    DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
      const str = buffer.raw().toString();
      let year;
      let mon;
      let day;
      let hour;
      let min;
      let sec;
      if (tag === "gentime") {
        year = str.slice(0, 4) | 0;
        mon = str.slice(4, 6) | 0;
        day = str.slice(6, 8) | 0;
        hour = str.slice(8, 10) | 0;
        min = str.slice(10, 12) | 0;
        sec = str.slice(12, 14) | 0;
      } else if (tag === "utctime") {
        year = str.slice(0, 2) | 0;
        mon = str.slice(2, 4) | 0;
        day = str.slice(4, 6) | 0;
        hour = str.slice(6, 8) | 0;
        min = str.slice(8, 10) | 0;
        sec = str.slice(10, 12) | 0;
        if (year < 70)
          year = 2e3 + year;
        else
          year = 1900 + year;
      } else {
        return buffer.error("Decoding " + tag + " time is not supported yet");
      }
      return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
    };
    DERNode.prototype._decodeNull = function decodeNull() {
      return null;
    };
    DERNode.prototype._decodeBool = function decodeBool(buffer) {
      const res = buffer.readUInt8();
      if (buffer.isError(res))
        return res;
      else
        return res !== 0;
    };
    DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
      const raw = buffer.raw();
      let res = new bignum(raw);
      if (values)
        res = values[res.toString(10)] || res;
      return res;
    };
    DERNode.prototype._use = function use(entity, obj) {
      if (typeof entity === "function")
        entity = entity(obj);
      return entity._getDecoder("der").tree;
    };
    function derDecodeTag(buf, fail) {
      let tag = buf.readUInt8(fail);
      if (buf.isError(tag))
        return tag;
      const cls = der.tagClass[tag >> 6];
      const primitive = (tag & 32) === 0;
      if ((tag & 31) === 31) {
        let oct = tag;
        tag = 0;
        while ((oct & 128) === 128) {
          oct = buf.readUInt8(fail);
          if (buf.isError(oct))
            return oct;
          tag <<= 7;
          tag |= oct & 127;
        }
      } else {
        tag &= 31;
      }
      const tagStr = der.tag[tag];
      return {
        cls,
        primitive,
        tag,
        tagStr
      };
    }
    function derDecodeLen(buf, primitive, fail) {
      let len = buf.readUInt8(fail);
      if (buf.isError(len))
        return len;
      if (!primitive && len === 128)
        return null;
      if ((len & 128) === 0) {
        return len;
      }
      const num = len & 127;
      if (num > 4)
        return buf.error("length octect is too long");
      len = 0;
      for (let i = 0; i < num; i++) {
        len <<= 8;
        const j = buf.readUInt8(fail);
        if (buf.isError(j))
          return j;
        len |= j;
      }
      return len;
    }
  }
});

// node_modules/asn1.js/lib/asn1/decoders/pem.js
var require_pem2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/pem.js"(exports, module) {
    "use strict";
    var inherits = require_inherits_browser();
    var Buffer2 = require_safer().Buffer;
    var DERDecoder = require_der3();
    function PEMDecoder(entity) {
      DERDecoder.call(this, entity);
      this.enc = "pem";
    }
    inherits(PEMDecoder, DERDecoder);
    module.exports = PEMDecoder;
    PEMDecoder.prototype.decode = function decode(data, options) {
      const lines = data.toString().split(/[\r\n]+/g);
      const label = options.label.toUpperCase();
      const re = /^-----(BEGIN|END) ([^-]+)-----$/;
      let start = -1;
      let end = -1;
      for (let i = 0; i < lines.length; i++) {
        const match = lines[i].match(re);
        if (match === null)
          continue;
        if (match[2] !== label)
          continue;
        if (start === -1) {
          if (match[1] !== "BEGIN")
            break;
          start = i;
        } else {
          if (match[1] !== "END")
            break;
          end = i;
          break;
        }
      }
      if (start === -1 || end === -1)
        throw new Error("PEM section not found for: " + label);
      const base64 = lines.slice(start + 1, end).join("");
      base64.replace(/[^a-z0-9+/=]+/gi, "");
      const input = Buffer2.from(base64, "base64");
      return DERDecoder.prototype.decode.call(this, input, options);
    };
  }
});

// node_modules/asn1.js/lib/asn1/decoders/index.js
var require_decoders = __commonJS({
  "node_modules/asn1.js/lib/asn1/decoders/index.js"(exports) {
    "use strict";
    var decoders = exports;
    decoders.der = require_der3();
    decoders.pem = require_pem2();
  }
});

// node_modules/asn1.js/lib/asn1/api.js
var require_api = __commonJS({
  "node_modules/asn1.js/lib/asn1/api.js"(exports) {
    "use strict";
    var encoders = require_encoders();
    var decoders = require_decoders();
    var inherits = require_inherits_browser();
    var api = exports;
    api.define = function define2(name, body) {
      return new Entity(name, body);
    };
    function Entity(name, body) {
      this.name = name;
      this.body = body;
      this.decoders = {};
      this.encoders = {};
    }
    Entity.prototype._createNamed = function createNamed(Base) {
      const name = this.name;
      function Generated(entity) {
        this._initNamed(entity, name);
      }
      inherits(Generated, Base);
      Generated.prototype._initNamed = function _initNamed(entity, name2) {
        Base.call(this, entity, name2);
      };
      return new Generated(this);
    };
    Entity.prototype._getDecoder = function _getDecoder(enc) {
      enc = enc || "der";
      if (!this.decoders.hasOwnProperty(enc))
        this.decoders[enc] = this._createNamed(decoders[enc]);
      return this.decoders[enc];
    };
    Entity.prototype.decode = function decode(data, enc, options) {
      return this._getDecoder(enc).decode(data, options);
    };
    Entity.prototype._getEncoder = function _getEncoder(enc) {
      enc = enc || "der";
      if (!this.encoders.hasOwnProperty(enc))
        this.encoders[enc] = this._createNamed(encoders[enc]);
      return this.encoders[enc];
    };
    Entity.prototype.encode = function encode(data, enc, reporter) {
      return this._getEncoder(enc).encode(data, reporter);
    };
  }
});

// node_modules/asn1.js/lib/asn1/base/index.js
var require_base = __commonJS({
  "node_modules/asn1.js/lib/asn1/base/index.js"(exports) {
    "use strict";
    var base = exports;
    base.Reporter = require_reporter().Reporter;
    base.DecoderBuffer = require_buffer3().DecoderBuffer;
    base.EncoderBuffer = require_buffer3().EncoderBuffer;
    base.Node = require_node();
  }
});

// node_modules/asn1.js/lib/asn1/constants/index.js
var require_constants2 = __commonJS({
  "node_modules/asn1.js/lib/asn1/constants/index.js"(exports) {
    "use strict";
    var constants = exports;
    constants._reverse = function reverse(map) {
      const res = {};
      Object.keys(map).forEach(function(key) {
        if ((key | 0) == key)
          key = key | 0;
        const value = map[key];
        res[value] = key;
      });
      return res;
    };
    constants.der = require_der();
  }
});

// node_modules/asn1.js/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/asn1.js/lib/asn1.js"(exports) {
    "use strict";
    var asn1 = exports;
    asn1.bignum = require_bn();
    asn1.define = require_api().define;
    asn1.base = require_base();
    asn1.constants = require_constants2();
    asn1.decoders = require_decoders();
    asn1.encoders = require_encoders();
  }
});

// node_modules/js-crypto-key-utils/dist/params.js
var require_params = __commonJS({
  "node_modules/js-crypto-key-utils/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAlgorithmFromOidStrict = exports.getAlgorithmFromOid = exports.hashes = exports.encryptionSchemes = exports.pbkdf2Prfs = exports.keyDerivationFunctions = exports.passwordBasedEncryptionSchemes = exports.publicKeyAlgorithms = exports.namedCurves = void 0;
    exports.namedCurves = {
      "P-256": { indutnyName: "p256", payloadSize: 32, oid: [1, 2, 840, 10045, 3, 1, 7] },
      "P-384": { indutnyName: "p384", payloadSize: 48, oid: [1, 3, 132, 0, 34] },
      "P-521": { indutnyName: "p521", payloadSize: 66, oid: [1, 3, 132, 0, 35] },
      "P-256K": { indutnyName: "secp256k1", payloadSize: 32, oid: [1, 3, 132, 0, 10] }
    };
    exports.publicKeyAlgorithms = {
      "EC": { oid: [1, 2, 840, 10045, 2, 1] },
      "RSA": { oid: [1, 2, 840, 113549, 1, 1, 1] }
    };
    exports.passwordBasedEncryptionSchemes = {
      // PBES1
      "pbeWithMD5AndDES-CBC": { oid: [1, 2, 840, 113549, 1, 5, 3], hash: "MD5", encrypt: "DES-CBC" },
      "pbeWithSHA1AndDES-CBC": { oid: [1, 2, 840, 113549, 1, 5, 10], hash: "SHA-1", encrypt: "DES-CBC" },
      // PBES2
      "pbes2": { oid: [1, 2, 840, 113549, 1, 5, 13] }
    };
    exports.keyDerivationFunctions = {
      "pbkdf2": { oid: [1, 2, 840, 113549, 1, 5, 12], defaultSaltLen: 8 }
    };
    exports.pbkdf2Prfs = {
      "hmacWithSHA1": { oid: [1, 2, 840, 113549, 2, 7], hash: "SHA-1" },
      "hmacWithSHA256": { oid: [1, 2, 840, 113549, 2, 9], hash: "SHA-256" },
      "hmacWithSHA384": { oid: [1, 2, 840, 113549, 2, 10], hash: "SHA-384" },
      "hmacWithSHA512": { oid: [1, 2, 840, 113549, 2, 11], hash: "SHA-512" }
    };
    exports.encryptionSchemes = {
      "des-ede3-cbc": { oid: [1, 2, 840, 113549, 3, 7], keyLength: 24, ivLength: 8 },
      "aes128-cbc": { oid: [2, 16, 840, 1, 101, 3, 4, 1, 2], keyLength: 16, ivLength: 16 },
      "aes192-cbc": { oid: [2, 16, 840, 1, 101, 3, 4, 1, 22], keyLength: 24, ivLength: 16 },
      "aes256-cbc": { oid: [2, 16, 840, 1, 101, 3, 4, 1, 42], keyLength: 32, ivLength: 16 }
    };
    exports.hashes = {
      "SHA-256": { hashSize: 32 },
      "SHA-384": { hashSize: 48 },
      "SHA-512": { hashSize: 64 },
      "SHA-1": { hashSize: 20 },
      "MD5": { hashSize: 16 }
      // SHOULD NOT USE
    };
    function getAlgorithmFromOid(oid, oidDict) {
      return Object.keys(oidDict).filter(function(k) {
        return oidDict[k].oid.toString() === oid.toString();
      });
    }
    exports.getAlgorithmFromOid = getAlgorithmFromOid;
    var getAlgorithmFromOidStrict = function(oid, dict) {
      var array = getAlgorithmFromOid(oid, dict);
      if (array.length === 0)
        throw new Error("UnsupportedAlgorithm");
      return array[0];
    };
    exports.getAlgorithmFromOidStrict = getAlgorithmFromOidStrict;
  }
});

// node_modules/js-encoding-utils/dist/src/env.js
var require_env = __commonJS({
  "node_modules/js-encoding-utils/dist/src/env.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getEnvAtob = exports.getEnvBtoa = void 0;
    var getEnvBtoa = () => {
      if (typeof window !== "undefined")
        return window.btoa;
      else
        return nodeBtoa;
    };
    exports.getEnvBtoa = getEnvBtoa;
    var getEnvAtob = () => {
      if (typeof window !== "undefined")
        return window.atob;
      else
        return nodeAtob;
    };
    exports.getEnvAtob = getEnvAtob;
    var nodeBtoa = (str) => {
      if (typeof Buffer === "undefined")
        throw new Error("UnsupportedEnvironment");
      const buffer = Buffer.from(str.toString(), "binary");
      return buffer.toString("base64");
    };
    var nodeAtob = (str) => {
      if (typeof Buffer === "undefined")
        throw new Error("UnsupportedEnvironment");
      return Buffer.from(str, "base64").toString("binary");
    };
  }
});

// node_modules/js-encoding-utils/dist/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/js-encoding-utils/dist/src/encoder.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.stringToArrayBuffer = exports.arrayBufferToString = exports.hexStringToArrayBuffer = exports.arrayBufferToHexString = exports.decodeBase64Url = exports.encodeBase64Url = exports.decodeBase64 = exports.encodeBase64 = void 0;
    var env = __importStar(require_env());
    var encodeBase64 = (data) => {
      let str = "";
      if (typeof data === "string")
        str = data;
      else
        str = (0, exports.arrayBufferToString)(data);
      const btoa2 = env.getEnvBtoa();
      return btoa2(str);
    };
    exports.encodeBase64 = encodeBase64;
    var decodeBase64 = (str) => {
      const atob = env.getEnvAtob();
      const binary = atob(str);
      const data = (0, exports.stringToArrayBuffer)(binary);
      return getAsciiIfAscii(data);
    };
    exports.decodeBase64 = decodeBase64;
    var sanitizeTypedArrayAndArrayBuffer = (data) => {
      if (data instanceof Uint8Array)
        return data;
      if (ArrayBuffer.isView(data) && typeof data.buffer !== "undefined") {
        return new Uint8Array(data.buffer);
      } else
        return new Uint8Array(data);
    };
    var getAsciiIfAscii = (data) => {
      let flag = true;
      for (let i = 0; i < data.length; i++) {
        if (data[i] > 126 || data[i] < 32 && data[i] !== 13 && data[i] !== 10) {
          flag = false;
          break;
        }
      }
      let returnData = null;
      if (flag) {
        returnData = "";
        for (let i = 0; i < data.length; i++)
          returnData += String.fromCharCode(data[i]);
      } else
        returnData = data;
      return returnData;
    };
    var encodeBase64Url = (data) => (0, exports.encodeBase64)(data).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "");
    exports.encodeBase64Url = encodeBase64Url;
    var decodeBase64Url = (str) => {
      str = str.replace(/-/g, "+").replace(/_/g, "/");
      return (0, exports.decodeBase64)(str);
    };
    exports.decodeBase64Url = decodeBase64Url;
    var arrayBufferToHexString = (data) => {
      const arr = sanitizeTypedArrayAndArrayBuffer(data);
      let hexStr = "";
      for (let i = 0; i < arr.length; i++) {
        let hex = (arr[i] & 255).toString(16);
        hex = hex.length === 1 ? `0${hex}` : hex;
        hexStr += hex;
      }
      return hexStr;
    };
    exports.arrayBufferToHexString = arrayBufferToHexString;
    var hexStringToArrayBuffer = (str) => {
      const arr = [];
      const len = str.length;
      for (let i = 0; i < len; i += 2)
        arr.push(parseInt(str.substr(i, 2), 16));
      return new Uint8Array(arr);
    };
    exports.hexStringToArrayBuffer = hexStringToArrayBuffer;
    var arrayBufferToString = (data) => {
      const bytes = sanitizeTypedArrayAndArrayBuffer(data);
      const arr = new Array(bytes.length);
      bytes.forEach((x, i) => {
        arr[i] = x;
      });
      return String.fromCharCode.apply(null, arr);
    };
    exports.arrayBufferToString = arrayBufferToString;
    var stringToArrayBuffer = (str) => {
      const bytes = new Uint8Array(str.length);
      return bytes.map((_x, i) => str.charCodeAt(i));
    };
    exports.stringToArrayBuffer = stringToArrayBuffer;
  }
});

// node_modules/js-encoding-utils/dist/src/formatter.js
var require_formatter = __commonJS({
  "node_modules/js-encoding-utils/dist/src/formatter.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.binToPem = exports.pemToBin = void 0;
    var encoder2 = __importStar(require_encoder());
    var PemArmorString = {
      "public": "PUBLIC KEY",
      "private": "PRIVATE KEY",
      "encryptedPrivate": "ENCRYPTED PRIVATE KEY",
      "certificate": "CERTIFICATE",
      "certRequest": "CERTIFICATE REQUEST"
    };
    var pemToBin = (keydataB64Pem) => {
      const keydataB64 = dearmorPem(keydataB64Pem);
      return encoder2.decodeBase64(keydataB64);
    };
    exports.pemToBin = pemToBin;
    var binToPem = (keydata, type) => {
      const keydataB64 = encoder2.encodeBase64(keydata);
      return formatAsPem(keydataB64, type);
    };
    exports.binToPem = binToPem;
    var formatAsPem = (str, type) => {
      const typeString = PemArmorString[type];
      let finalString = `-----BEGIN ${typeString}-----
`;
      while (str.length > 0) {
        finalString += `${str.substring(0, 64)}
`;
        str = str.substring(64);
      }
      finalString = `${finalString}-----END ${typeString}-----`;
      return finalString;
    };
    var dearmorPem = (str) => {
      const beginRegExp = RegExp("^-----[s]*BEGIN[^-]*-----$", "gm");
      const endRegExp = RegExp("^-----[s]*END[^-]*-----$", "gm");
      try {
        let dearmored = str.split(beginRegExp)[1].split(endRegExp)[0];
        dearmored = dearmored.replace(/\r?\n/g, "");
        return dearmored;
      } catch (e) {
        throw new Error("Invalid format as PEM");
      }
    };
  }
});

// node_modules/js-encoding-utils/dist/src/index.js
var require_src = __commonJS({
  "node_modules/js-encoding-utils/dist/src/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatter = exports.encoder = void 0;
    var Encoder = __importStar(require_encoder());
    var Formatter = __importStar(require_formatter());
    var encoder2;
    (function(encoder3) {
      encoder3.encodeBase64 = Encoder.encodeBase64;
      encoder3.decodeBase64 = Encoder.decodeBase64;
      encoder3.encodeBase64Url = Encoder.encodeBase64Url;
      encoder3.decodeBase64Url = Encoder.decodeBase64Url;
      encoder3.arrayBufferToHexString = Encoder.arrayBufferToHexString;
      encoder3.hexStringToArrayBuffer = Encoder.hexStringToArrayBuffer;
      encoder3.stringToArrayBuffer = Encoder.stringToArrayBuffer;
      encoder3.arrayBufferToString = Encoder.arrayBufferToString;
    })(encoder2 || (exports.encoder = encoder2 = {}));
    var formatter;
    (function(formatter2) {
      formatter2.binToPem = Formatter.binToPem;
      formatter2.pemToBin = Formatter.pemToBin;
    })(formatter || (exports.formatter = formatter = {}));
    exports.default = { encoder: encoder2, formatter };
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports, module) {
    module.exports = {
      name: "elliptic",
      version: "6.5.7",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports) {
    "use strict";
    var utils4 = exports;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils4.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils4.zero2 = zero2;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils4.toHex = toHex;
    utils4.encode = function encode(arr, enc) {
      if (enc === "hex")
        return toHex(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils4 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports) {
    "use strict";
    var utils4 = exports;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils3();
    utils4.assert = minAssert;
    utils4.toArray = minUtils.toArray;
    utils4.zero2 = minUtils.zero2;
    utils4.toHex = minUtils.toHex;
    utils4.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      var i;
      for (i = 0; i < naf.length; i += 1) {
        naf[i] = 0;
      }
      var ws = 1 << w + 1;
      var k = num.clone();
      for (i = 0; i < naf.length; i++) {
        var z;
        var mod = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod > (ws >> 1) - 1)
            z = (ws >> 1) - mod;
          else
            z = mod;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils4.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils4.getJSF = getJSF;
    function cachedProperty(obj, name, computer) {
      var key = "_" + name;
      obj.prototype[name] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils4.cachedProperty = cachedProperty;
    function parseBytes(bytes) {
      return typeof bytes === "string" ? utils4.toArray(bytes, "hex") : bytes;
    }
    utils4.parseBytes = parseBytes;
    function intFromLE(bytes) {
      return new BN(bytes, "hex", "le");
    }
    utils4.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports, module) {
    var r;
    module.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto2 = require_crypto();
        if (typeof crypto2.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto2.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto2;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils4 = require_utils4();
    var getNAF = utils4.getNAF;
    var getJSF = utils4.getJSF;
    var assert = utils4.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate2() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          /* 1 */
          null,
          /* 3 */
          null,
          /* 5 */
          points[b]
          /* 7 */
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          /* -1 -1 */
          -1,
          /* -1 0 */
          -5,
          /* -1 1 */
          -7,
          /* 0 -1 */
          0,
          /* 0 0 */
          7,
          /* 0 1 */
          5,
          /* 1 -1 */
          1,
          /* 1 0 */
          3
          /* 1 1 */
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate2() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      bytes = utils4.toArray(bytes, enc);
      var len = this.p.byteLength();
      if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
        if (bytes[0] === 6)
          assert(bytes[bytes.length - 1] % 2 === 0);
        else if (bytes[0] === 7)
          assert(bytes[bytes.length - 1] % 2 === 1);
        var res = this.point(
          bytes.slice(1, 1 + len),
          bytes.slice(1 + len, 1 + 2 * len)
        );
        return res;
      } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
        return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode(enc, compact) {
      return utils4.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports, module) {
    "use strict";
    var utils4 = require_utils4();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils4.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate2(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f2 = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f2.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var utils4 = require_utils4();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module.exports = MontCurve;
    MontCurve.prototype.validate = function validate2(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
      return this.point(utils4.toArray(bytes, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports, module) {
    "use strict";
    var utils4 = require_utils4();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base2();
    var assert = utils4.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate2(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f2 = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f2);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f2.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f2 = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f2.redSub(this.curve.two));
          ny = f2.redMul(e.redSub(d));
          nz = f2.redSqr().redSub(f2).redSub(f2);
        } else {
          h = this.z.redSqr();
          j = f2.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f2.redMul(e.redSub(d));
          nz = f2.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f2 = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f2);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f2.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f2 = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f2).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f2.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f2).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(
        this.x.redNeg(),
        this.y,
        this.z,
        this.t && this.t.redNeg()
      );
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports) {
    "use strict";
    var curve = exports;
    curve.base = require_base2();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils5 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports.toArray = toArray;
    function toHex(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports.toHex = toHex;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports.sum32_5 = sum32_5;
    function sum64(buf, pos, ah, al) {
      var bh = buf[pos];
      var bl = buf[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf[pos] = hi >>> 0;
      buf[pos + 1] = lo;
    }
    exports.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports) {
    "use strict";
    var utils4 = require_utils5();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils4.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils4.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes = this._delta8;
      var k = bytes - (len + this.padLength) % bytes;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports) {
    "use strict";
    var utils4 = require_utils5();
    var rotr32 = utils4.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports, module) {
    "use strict";
    var utils4 = require_utils5();
    var common = require_common();
    var shaCommon = require_common2();
    var rotl32 = utils4.rotl32;
    var sum32 = utils4.sum32;
    var sum32_5 = utils4.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils4.inherits(SHA1, BlockHash);
    module.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils4.toHex32(this.h, "big");
      else
        return utils4.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports, module) {
    "use strict";
    var utils4 = require_utils5();
    var common = require_common();
    var shaCommon = require_common2();
    var assert = require_minimalistic_assert();
    var sum32 = utils4.sum32;
    var sum32_4 = utils4.sum32_4;
    var sum32_5 = utils4.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils4.inherits(SHA256, BlockHash);
    module.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f2 = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f2, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f2;
        f2 = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f2);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils4.toHex32(this.h, "big");
      else
        return utils4.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports, module) {
    "use strict";
    var utils4 = require_utils5();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils4.inherits(SHA224, SHA256);
    module.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils4.toHex32(this.h.slice(0, 7), "big");
      else
        return utils4.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports, module) {
    "use strict";
    var utils4 = require_utils5();
    var common = require_common();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils4.rotr64_hi;
    var rotr64_lo = utils4.rotr64_lo;
    var shr64_hi = utils4.shr64_hi;
    var shr64_lo = utils4.shr64_lo;
    var sum64 = utils4.sum64;
    var sum64_hi = utils4.sum64_hi;
    var sum64_lo = utils4.sum64_lo;
    var sum64_4_hi = utils4.sum64_4_hi;
    var sum64_4_lo = utils4.sum64_4_lo;
    var sum64_5_hi = utils4.sum64_5_hi;
    var sum64_5_lo = utils4.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils4.inherits(SHA512, BlockHash);
    module.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
        W[i + 1] = sum64_4_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo
        );
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        var T1_lo = sum64_5_lo(
          c0_hi,
          c0_lo,
          c1_hi,
          c1_lo,
          c2_hi,
          c2_lo,
          c3_hi,
          c3_lo,
          c4_hi,
          c4_lo
        );
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils4.toHex32(this.h, "big");
      else
        return utils4.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports, module) {
    "use strict";
    var utils4 = require_utils5();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils4.inherits(SHA384, SHA512);
    module.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils4.toHex32(this.h.slice(0, 12), "big");
      else
        return utils4.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports) {
    "use strict";
    exports.sha1 = require__();
    exports.sha224 = require__3();
    exports.sha256 = require__2();
    exports.sha384 = require__5();
    exports.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports) {
    "use strict";
    var utils4 = require_utils5();
    var common = require_common();
    var rotl32 = utils4.rotl32;
    var sum32 = utils4.sum32;
    var sum32_3 = utils4.sum32_3;
    var sum32_4 = utils4.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils4.inherits(RIPEMD160, BlockHash);
    exports.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(
          rotl32(
            sum32_4(A, f2(j, B, C, D), msg[r[j] + start], K(j)),
            s[j]
          ),
          E
        );
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(
          rotl32(
            sum32_4(Ah, f2(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
            sh[j]
          ),
          Eh
        );
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils4.toHex32(this.h, "little");
      else
        return utils4.split32(this.h, "little");
    };
    function f2(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports, module) {
    "use strict";
    var utils4 = require_utils5();
    var assert = require_minimalistic_assert();
    function Hmac(hash, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash, key, enc);
      this.Hash = hash;
      this.blockSize = hash.blockSize / 8;
      this.outSize = hash.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils4.toArray(key, enc));
    }
    module.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports) {
    var hash = exports;
    hash.utils = require_utils5();
    hash.common = require_common();
    hash.sha = require_sha();
    hash.ripemd = require_ripemd();
    hash.hmac = require_hmac();
    hash.sha1 = hash.sha.sha1;
    hash.sha256 = hash.sha.sha256;
    hash.sha224 = hash.sha.sha224;
    hash.sha384 = hash.sha.sha384;
    hash.sha512 = hash.sha.sha512;
    hash.ripemd160 = hash.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports, module) {
    module.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports) {
    "use strict";
    var curves = exports;
    var hash = require_hash();
    var curve = require_curve();
    var utils4 = require_utils4();
    var assert = utils4.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name, options) {
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var utils4 = require_utils3();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils4.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils4.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils4.toArray(options.pers, options.persEnc || "hex");
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._init(entropy, nonce, pers);
    }
    module.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils4.toArray(entropy, entropyEnc);
      add = utils4.toArray(add, addEnc);
      assert(
        entropy.length >= this.minEntropy / 8,
        "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
      );
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils4.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils4.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils4 = require_utils4();
    var assert = utils4.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate2() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils4 = require_utils4();
    var assert = utils4.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf, p) {
      var initial = buf[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      if (buf[p.place] === 0) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf) {
      var i = 0;
      var len = buf.length - 1;
      while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf;
      }
      return buf.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils4.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      if ((data[p.place] & 128) !== 0) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils4.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils4 = require_utils4();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils4.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(
          Object.prototype.hasOwnProperty.call(curves, options),
          "Unknown curve " + options
        );
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes);
      var nonce = msg.toArray("be", bytes);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports, module) {
    "use strict";
    var utils4 = require_utils4();
    var assert = utils4.assert;
    var parseBytes = utils4.parseBytes;
    var cachedProperty = utils4.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils4.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils4.encode(this.pubBytes(), enc);
    };
    module.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports, module) {
    "use strict";
    var BN = require_bn();
    var utils4 = require_utils4();
    var assert = utils4.assert;
    var cachedProperty = utils4.cachedProperty;
    var parseBytes = utils4.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        assert(sig.length === eddsa.encodingLength * 2, "Signature has invalid size");
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex() {
      return utils4.encode(this.toBytes(), "hex").toUpperCase();
    };
    module.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports, module) {
    "use strict";
    var hash = require_hash();
    var curves = require_curves();
    var utils4 = require_utils4();
    var assert = utils4.assert;
    var parseBytes = utils4.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash.sha512;
    }
    module.exports = EDDSA;
    EDDSA.prototype.sign = function sign(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      if (sig.S().gte(sig.eddsa.curve.n) || sig.S().isNeg()) {
        return false;
      }
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash2 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash2.update(arguments[i]);
      return utils4.intFromLE(hash2.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes) {
      bytes = utils4.parseBytes(bytes);
      var lastIx = bytes.length - 1;
      var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
      var xIsOdd = (bytes[lastIx] & 128) !== 0;
      var y = utils4.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes) {
      return utils4.intFromLE(bytes);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports) {
    "use strict";
    var elliptic = exports;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils4();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/js-crypto-key-utils/dist/asn1def.js
var require_asn1def = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1def.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PBES2ESParams = exports.PBKDF2Params = exports.PBES2Params = exports.PBEParameter = exports.EncryptedPrivateKeyInfo = exports.OneAsymmetricKey = exports.SubjectPublicKeyInfo = exports.KeyStructure = void 0;
    var asn1_js_1 = __importDefault(require_asn1());
    exports.KeyStructure = asn1_js_1.default.define("KeyStructure", function() {
      this.choice({
        // @ts-ignore
        subjectPublicKeyInfo: this.use(exports.SubjectPublicKeyInfo),
        // @ts-ignore
        oneAsymmetricKey: this.use(exports.OneAsymmetricKey),
        // @ts-ignore
        encryptedPrivateKeyInfo: this.use(exports.EncryptedPrivateKeyInfo)
      });
    });
    exports.SubjectPublicKeyInfo = asn1_js_1.default.define("SubjectPublicKeyInfo", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("algorithm").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("subjectPublicKey").bitstr()
      );
    });
    exports.OneAsymmetricKey = asn1_js_1.default.define("OneAsymmetricKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").use(Version),
        // @ts-ignore
        this.key("privateKeyAlgorithm").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("privateKey").octstr(),
        // @ts-ignore
        this.key("attributes").implicit(0).optional().any(),
        // @ts-ignore
        this.key("publicKey").implicit(1).optional().bitstr()
      );
    });
    exports.EncryptedPrivateKeyInfo = asn1_js_1.default.define("EncryptedPrivateKeyInfo", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("encryptionAlgorithm").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("encryptedData").octstr()
      );
    });
    exports.PBEParameter = asn1_js_1.default.define("PBEParameter", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("salt").octstr(8),
        // @ts-ignore
        this.key("iterationCount").int()
      );
    });
    exports.PBES2Params = asn1_js_1.default.define("PBES2Params", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("keyDerivationFunc").use(AlgorithmIdentifier),
        // @ts-ignore
        this.key("encryptionScheme").use(AlgorithmIdentifier)
      );
    });
    exports.PBKDF2Params = asn1_js_1.default.define("PBKDF2Params", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("salt").choice({
          // @ts-ignore
          "specified": this.octstr(),
          // @ts-ignore
          "otherSource": this.use(AlgorithmIdentifier)
        }),
        // @ts-ignore
        this.key("iterationCount").int(),
        // @ts-ignore
        this.key("keyLength").int().optional(),
        // @ts-ignore
        this.key("prf").use(AlgorithmIdentifier).def({
          algorithm: [1, 2, 840, 113549, 2, 7],
          parameters: Buffer.from([5, 0])
        })
      );
    });
    exports.PBES2ESParams = {
      "des-ede3-cbc": asn1_js_1.default.define("DesEde3CbcParams", function() {
        this.octstr();
      }),
      "aes128-cbc": asn1_js_1.default.define("Aes128CbcParams", function() {
        this.octstr();
      }),
      "aes192-cbc": asn1_js_1.default.define("Aes192CbcParams", function() {
        this.octstr();
      }),
      "aes256-cbc": asn1_js_1.default.define("Aes256CbcParams", function() {
        this.octstr();
      })
    };
    var AlgorithmIdentifier = asn1_js_1.default.define("AlgorithmIdentifier", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("algorithm").objid(),
        // @ts-ignore
        this.key("parameters").optional().any()
      );
    });
    var Version = asn1_js_1.default.define("Version", function() {
      this.int();
    });
  }
});

// node_modules/js-crypto-key-utils/dist/util.js
var require_util3 = __commonJS({
  "node_modules/js-crypto-key-utils/dist/util.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.appendLeadingZeros = exports.pruneLeadingZeros = exports.getJwkType = exports.getSec1KeyType = exports.getAsn1KeyType = exports.isAsn1Public = exports.isAsn1Encrypted = void 0;
    var js_encoding_utils_1 = __importDefault(require_src());
    var params = __importStar(require_params());
    var asn1def_1 = require_asn1def();
    var isAsn1Encrypted = function(key, format) {
      if (format === void 0) {
        format = "pem";
      }
      var keyType;
      try {
        keyType = (0, exports.getAsn1KeyType)(key, format);
      } catch (e) {
        return false;
      }
      return keyType === "encryptedPrivate";
    };
    exports.isAsn1Encrypted = isAsn1Encrypted;
    var isAsn1Public = function(key, format) {
      if (format === void 0) {
        format = "pem";
      }
      var keyType;
      try {
        keyType = (0, exports.getAsn1KeyType)(key, format);
      } catch (e) {
        return false;
      }
      return keyType === "public";
    };
    exports.isAsn1Public = isAsn1Public;
    var getAsn1KeyType = function(key, format) {
      if (format === void 0) {
        format = "pem";
      }
      var binKey = format === "pem" ? js_encoding_utils_1.default.formatter.pemToBin(key) : key;
      var decoded = asn1def_1.KeyStructure.decode(Buffer.from(binKey), "der");
      if (decoded.type === "encryptedPrivateKeyInfo")
        return "encryptedPrivate";
      else if (decoded.type === "oneAsymmetricKey")
        return "private";
      else if (decoded.type === "subjectPublicKeyInfo")
        return "public";
      else
        throw new Error("NotSpkiNorPkcs8Key");
    };
    exports.getAsn1KeyType = getAsn1KeyType;
    var getSec1KeyType = function(sec1key, namedCurve) {
      var len = params.namedCurves[namedCurve].payloadSize;
      var binKey = sec1key instanceof Uint8Array ? sec1key : js_encoding_utils_1.default.encoder.hexStringToArrayBuffer(sec1key);
      if (binKey.length <= len)
        return "private";
      else if (binKey.length === 2 * len + 1 && binKey[0] === 4 || binKey.length === len + 1 && (binKey[0] === 2 || binKey[0] === 3))
        return "public";
      else
        throw new Error("UnsupportedKeyStructure");
    };
    exports.getSec1KeyType = getSec1KeyType;
    var getJwkType = function(jwkey) {
      if (jwkey.kty === "EC") {
        if (jwkey.x && jwkey.y && jwkey.d)
          return "private";
        else if (jwkey.x && jwkey.y)
          return "public";
        else
          throw new Error("InvalidECKey");
      } else if (jwkey.kty === "RSA") {
        if (jwkey.n && jwkey.e && jwkey.d && jwkey.p && jwkey.q && jwkey.dp && jwkey.dq && jwkey.qi)
          return "private";
        else if (jwkey.n && jwkey.e)
          return "public";
        else
          throw new Error("InvalidRSAKey");
      } else
        throw new Error("UnsupportedJWKType");
    };
    exports.getJwkType = getJwkType;
    var pruneLeadingZeros = function(array) {
      var offset = 0;
      for (var i = 0; i < array.length; i++) {
        if (array[i] !== 0)
          break;
        offset++;
      }
      var returnArray = new Uint8Array(array.length - offset);
      returnArray.set(array.slice(offset, array.length));
      return returnArray;
    };
    exports.pruneLeadingZeros = pruneLeadingZeros;
    var appendLeadingZeros = function(array, len) {
      if (array.length > len)
        throw new Error("InvalidLength");
      var returnArray = new Uint8Array(len);
      returnArray.set(array, len - array.length);
      return returnArray;
    };
    exports.appendLeadingZeros = appendLeadingZeros;
  }
});

// node_modules/js-crypto-key-utils/dist/octenc.js
var require_octenc = __commonJS({
  "node_modules/js-crypto-key-utils/dist/octenc.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwk = exports.fromJwk = void 0;
    var params = __importStar(require_params());
    var js_encoding_utils_1 = __importDefault(require_src());
    var elliptic = __importStar(require_elliptic());
    var util_1 = require_util3();
    var Ec = elliptic.ec;
    var fromJwk = function(jwkey, _a) {
      var outputPublic = _a.outputPublic, _b = _a.outputFormat, outputFormat = _b === void 0 ? "binary" : _b, _c = _a.compact, compact = _c === void 0 ? false : _c;
      var orgType = (0, util_1.getJwkType)(jwkey);
      var type = typeof outputPublic === "boolean" && outputPublic ? "public" : orgType;
      if (type === "public") {
        var bufX = js_encoding_utils_1.default.encoder.decodeBase64Url(jwkey.x);
        var bufY = js_encoding_utils_1.default.encoder.decodeBase64Url(jwkey.y);
        var publicKey = void 0;
        if (compact) {
          publicKey = new Uint8Array(bufX.length + 1);
          publicKey[0] = 255 & (1 & bufY.slice(-1)[0]) + 2;
          publicKey.set(bufX, 1);
        } else {
          publicKey = new Uint8Array(bufX.length + bufY.length + 1);
          publicKey[0] = 255 & 4;
          publicKey.set(bufX, 1);
          publicKey.set(bufY, bufX.length + 1);
        }
        return outputFormat === "string" ? js_encoding_utils_1.default.encoder.arrayBufferToHexString(publicKey) : publicKey;
      } else {
        if (!jwkey.d)
          throw new Error("InvalidKey");
        var bufD = js_encoding_utils_1.default.encoder.decodeBase64Url(jwkey.d);
        return outputFormat === "string" ? js_encoding_utils_1.default.encoder.arrayBufferToHexString(bufD) : bufD;
      }
    };
    exports.fromJwk = fromJwk;
    var toJwk = function(octkey, namedCurve, _a) {
      var outputPublic = _a.outputPublic;
      if (Object.keys(params.namedCurves).indexOf(namedCurve) < 0)
        throw new Error("UnsupportedCurve");
      var orgType = (0, util_1.getSec1KeyType)(octkey, namedCurve);
      var type = typeof outputPublic === "boolean" && outputPublic ? "public" : orgType;
      var binKey = typeof octkey === "string" ? js_encoding_utils_1.default.encoder.hexStringToArrayBuffer(octkey) : octkey;
      var curve = params.namedCurves[namedCurve].indutnyName;
      var ec = new Ec(curve);
      var ecKey = orgType === "public" ? ec.keyFromPublic(binKey) : ec.keyFromPrivate(binKey);
      var publicKey = new Uint8Array(ecKey.getPublic("array"));
      var len = params.namedCurves[namedCurve].payloadSize;
      var bufX = publicKey.slice(1, len + 1);
      var bufY = publicKey.slice(len + 1, len * 2 + 1);
      var jwKey = {
        kty: "EC",
        crv: namedCurve,
        x: js_encoding_utils_1.default.encoder.encodeBase64Url(bufX),
        y: js_encoding_utils_1.default.encoder.encodeBase64Url(bufY)
        // ext: true
      };
      if (type === "private") {
        jwKey.d = js_encoding_utils_1.default.encoder.encodeBase64Url(binKey);
      }
      return jwKey;
    };
    exports.toJwk = toJwk;
  }
});

// node_modules/js-crypto-key-utils/dist/asn1ec.js
var require_asn1ec = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1ec.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJWK = exports.fromJWK = void 0;
    var asn1_js_1 = __importDefault(require_asn1());
    var params = __importStar(require_params());
    var octenc_1 = require_octenc();
    var fromJWK = function(jwk, type, compact) {
      if (compact === void 0) {
        compact = false;
      }
      var octetPublicKey = (0, octenc_1.fromJwk)(jwk, { outputFormat: "binary", outputPublic: true, compact });
      var publicKeyAlgorithmOid = params.publicKeyAlgorithms["EC"].oid;
      var publicKey = { unused: 0, data: Array.from(octetPublicKey) };
      var parameters = ECParameters.encode({ type: "namedCurve", value: params.namedCurves[jwk.crv].oid }, "der");
      var algorithm = { algorithm: publicKeyAlgorithmOid, parameters };
      var decoded = {};
      if (type === "public") {
        decoded.subjectPublicKey = publicKey;
        decoded.algorithm = algorithm;
      } else if (type === "private") {
        var octetPrivateKey = (0, octenc_1.fromJwk)(jwk, { outputFormat: "binary", outputPublic: false, compact });
        decoded.version = 0;
        decoded.privateKeyAlgorithm = algorithm;
        decoded.privateKey = ECPrivateKey.encode({
          version: 1,
          privateKey: Array.from(octetPrivateKey),
          parameters,
          publicKey
        }, "der");
      }
      return decoded;
    };
    exports.fromJWK = fromJWK;
    var toJWK = function(decoded, type) {
      if (type === "public") {
        decoded.algorithm.parameters = ECParameters.decode(decoded.algorithm.parameters, "der");
        var octPubKey = new Uint8Array(decoded.subjectPublicKey.data);
        var namedCurves = params.getAlgorithmFromOid(decoded.algorithm.parameters.value, params.namedCurves);
        return (0, octenc_1.toJwk)(octPubKey, namedCurves[0], { outputPublic: true });
      } else {
        decoded.privateKeyAlgorithm.parameters = ECParameters.decode(decoded.privateKeyAlgorithm.parameters, "der");
        try {
          decoded.privateKey = ECPrivateKey.decode(decoded.privateKey, "der");
        } catch (e) {
          decoded.privateKey = ECPrivateKeyAlt.decode(decoded.privateKey, "der");
        }
        var octPrivKey = new Uint8Array(decoded.privateKey.privateKey);
        var namedCurves = params.getAlgorithmFromOid(decoded.privateKeyAlgorithm.parameters.value, params.namedCurves);
        if (namedCurves.length < 1)
          throw new Error("UnsupportedCurve");
        return (0, octenc_1.toJwk)(octPrivKey, namedCurves[0], { outputPublic: false });
      }
    };
    exports.toJWK = toJWK;
    var ECParameters = asn1_js_1.default.define("ECParameters", function() {
      this.choice({
        // @ts-ignore
        namedCurve: this.objid()
      });
    });
    var ECPrivateKey = asn1_js_1.default.define("ECPrivateKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").int(),
        // @ts-ignore
        this.key("privateKey").octstr(),
        // @ts-ignore
        this.key("parameters").explicit(0).optional().any(),
        // rfc suggested that this must be implemented
        // @ts-ignore
        this.key("publicKey").explicit(1).optional().bitstr()
        // rfc suggested that this must be implemented
      );
    });
    var ECPrivateKeyAlt = asn1_js_1.default.define("ECPrivateKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").int(),
        // @ts-ignore
        this.key("privateKey").octstr(),
        // this.key('parameters').explicit(0).optional().any(), // rfc suggested that this must be implemented
        // @ts-ignore
        this.key("publicKey").explicit(1).optional().bitstr()
        // rfc suggested that this must be implemented
      );
    });
  }
});

// node_modules/js-crypto-key-utils/dist/asn1rsa.js
var require_asn1rsa = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1rsa.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwk = exports.fromJwk = void 0;
    var asn1_js_1 = __importDefault(require_asn1());
    var js_encoding_utils_1 = __importDefault(require_src());
    var BufferMod = __importStar(require_buffer());
    var Buffer2 = BufferMod.Buffer;
    var params = __importStar(require_params());
    var util_1 = require_util3();
    var fromJwk = function(jwk, type) {
      var publicKeyAlgorithmOid = params.publicKeyAlgorithms["RSA"].oid;
      var parameters = Buffer2.from([5, 0]);
      var algorithm = { algorithm: publicKeyAlgorithmOid, parameters };
      var modulusBytes = js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.n);
      var nLen = modulusBytes.length;
      var modulusLength = nLen % 128 === 0 ? nLen : nLen + (128 - nLen % 128);
      var modulus = new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(modulusBytes, modulusLength));
      var publicExponent = new asn1_js_1.default.bignum(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.e));
      var decoded = {};
      if (type === "public") {
        decoded.subjectPublicKey = {
          unused: 0,
          data: RSAPublicKey.encode({ modulus, publicExponent }, "der")
        };
        decoded.algorithm = algorithm;
      } else if (type === "private") {
        decoded.version = 0;
        decoded.privateKeyAlgorithm = algorithm;
        decoded.privateKey = RSAPrivateKey.encode({
          version: 0,
          modulus,
          publicExponent,
          privateExponent: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.d), modulusLength)),
          prime1: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.p), modulusLength)),
          prime2: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.q), modulusLength)),
          exponent1: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.dp), modulusLength)),
          exponent2: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.dq), modulusLength)),
          coefficient: new asn1_js_1.default.bignum((0, util_1.appendLeadingZeros)(js_encoding_utils_1.default.encoder.decodeBase64Url(jwk.qi), modulusLength))
        }, "der");
      }
      return decoded;
    };
    exports.fromJwk = fromJwk;
    var toJwk = function(decoded, type) {
      if (type === "public") {
        decoded.subjectPublicKey.data = RSAPublicKey.decode(decoded.subjectPublicKey.data, "der");
        var modulus = decoded.subjectPublicKey.data.modulus;
        var publicExponent = decoded.subjectPublicKey.data.publicExponent;
        var nLen = modulus.byteLength();
        var len = nLen % 128 === 0 ? nLen : nLen + (128 - nLen % 128);
        modulus = new Uint8Array(modulus.toArray("be", len));
        publicExponent = new Uint8Array(publicExponent.toArray("be", publicExponent.byteLength()));
        return {
          kty: "RSA",
          n: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(modulus)),
          e: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(publicExponent))
        };
      } else {
        decoded.privateKey = RSAPrivateKey.decode(decoded.privateKey, "der");
        var privateKeyElems_1 = {};
        privateKeyElems_1.modulus = decoded.privateKey.modulus;
        var nLen = privateKeyElems_1.modulus.byteLength();
        var len_1 = nLen % 128 === 0 ? nLen : nLen + (128 - nLen % 128);
        privateKeyElems_1.modulus = new Uint8Array(privateKeyElems_1.modulus.toArray("be", len_1));
        privateKeyElems_1.publicExponent = new Uint8Array(decoded.privateKey.publicExponent.toArray("be", decoded.privateKey.publicExponent.byteLength()));
        privateKeyElems_1.privateExponent = new Uint8Array(decoded.privateKey.privateExponent.toArray("be", len_1));
        var keys = ["prime1", "prime2", "exponent1", "exponent2", "coefficient"];
        keys.forEach(function(key) {
          privateKeyElems_1[key] = new Uint8Array(decoded.privateKey[key].toArray("be", len_1 >> 1));
        });
        return {
          kty: "RSA",
          n: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.modulus)),
          e: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.publicExponent)),
          d: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.privateExponent)),
          p: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.prime1)),
          q: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.prime2)),
          dp: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.exponent1)),
          dq: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.exponent2)),
          qi: js_encoding_utils_1.default.encoder.encodeBase64Url((0, util_1.pruneLeadingZeros)(privateKeyElems_1.coefficient))
        };
      }
    };
    exports.toJwk = toJwk;
    var RSAPublicKey = asn1_js_1.default.define("RSAPublicKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("modulus").int(),
        // n
        // @ts-ignore
        this.key("publicExponent").int()
        // e
      );
    });
    var RSAPrivateKey = asn1_js_1.default.define("RSAPrivateKey", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("version").int(),
        // 0
        // @ts-ignore
        this.key("modulus").int(),
        // n
        // @ts-ignore
        this.key("publicExponent").int(),
        // e
        // @ts-ignore
        this.key("privateExponent").int(),
        // d
        // @ts-ignore
        this.key("prime1").int(),
        // p
        // @ts-ignore
        this.key("prime2").int(),
        // q
        // @ts-ignore
        this.key("exponent1").int(),
        // d mod (p-1)
        // @ts-ignore
        this.key("exponent2").int(),
        // d mod (q-1)
        // @ts-ignore
        this.key("coefficient").int(),
        // (inverse of q) mod p
        // @ts-ignore
        this.key("otherPrimeInfos").optional().use(OtherPrimeInfos)
      );
    });
    var OtherPrimeInfos = asn1_js_1.default.define("OtherPrimeInfos", function() {
      this.seqof(OtherPrimeInfo);
    });
    var OtherPrimeInfo = asn1_js_1.default.define("OtherPrimeInfo", function() {
      this.seq().obj(
        // @ts-ignore
        this.key("prime").int(),
        // @ts-ignore
        this.key("exponent").int(),
        // @ts-ignore
        this.key("coefficient").int()
      );
    });
  }
});

// node_modules/des.js/lib/des/utils.js
var require_utils6 = __commonJS({
  "node_modules/des.js/lib/des/utils.js"(exports) {
    "use strict";
    exports.readUInt32BE = function readUInt32BE(bytes, off) {
      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
      return res >>> 0;
    };
    exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
      bytes[0 + off] = value >>> 24;
      bytes[1 + off] = value >>> 16 & 255;
      bytes[2 + off] = value >>> 8 & 255;
      bytes[3 + off] = value & 255;
    };
    exports.ip = function ip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
        }
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports.rip = function rip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 0; i < 4; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 4; i < 8; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports.pc1 = function pc1(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 7; i >= 5; i--) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }
      for (var i = 1; i <= 3; i++) {
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports.r28shl = function r28shl(num, shift) {
      return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [
      // inL => outL
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      // inR => outR
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    exports.pc2 = function pc2(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      var len = pc2table.length >>> 1;
      for (var i = 0; i < len; i++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i] & 1;
      }
      for (var i = len; i < pc2table.length; i++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i] & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports.expand = function expand(r, out, off) {
      var outL = 0;
      var outR = 0;
      outL = (r & 1) << 5 | r >>> 27;
      for (var i = 23; i >= 15; i -= 4) {
        outL <<= 6;
        outL |= r >>> i & 63;
      }
      for (var i = 11; i >= 3; i -= 4) {
        outR |= r >>> i & 63;
        outR <<= 6;
      }
      outR |= (r & 31) << 1 | r >>> 31;
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    exports.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i = 0; i < 4; i++) {
        var b = inL >>> 18 - i * 6 & 63;
        var sb = sTable[i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      for (var i = 0; i < 4; i++) {
        var b = inR >>> 18 - i * 6 & 63;
        var sb = sTable[4 * 64 + i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    exports.permute = function permute(num) {
      var out = 0;
      for (var i = 0; i < permuteTable.length; i++) {
        out <<= 1;
        out |= num >>> permuteTable[i] & 1;
      }
      return out >>> 0;
    };
    exports.padSplit = function padSplit(num, size, group) {
      var str = num.toString(2);
      while (str.length < size)
        str = "0" + str;
      var out = [];
      for (var i = 0; i < size; i += group)
        out.push(str.slice(i, i + group));
      return out.join(" ");
    };
  }
});

// node_modules/des.js/lib/des/cipher.js
var require_cipher = __commonJS({
  "node_modules/des.js/lib/des/cipher.js"(exports, module) {
    "use strict";
    var assert = require_minimalistic_assert();
    function Cipher(options) {
      this.options = options;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
      this.padding = options.padding !== false;
    }
    module.exports = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i = 0; i < min; i++)
        this.buffer[this.bufferOff + i] = data[off + i];
      this.bufferOff += min;
      return min;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer) {
      var first;
      if (buffer)
        first = this.update(buffer);
      var last;
      if (this.type === "encrypt")
        last = this._finalEncrypt();
      else
        last = this._finalDecrypt();
      if (first)
        return first.concat(last);
      else
        return last;
    };
    Cipher.prototype._pad = function _pad(buffer, off) {
      if (off === 0)
        return false;
      while (off < buffer.length)
        buffer[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
      return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  }
});

// node_modules/des.js/lib/des/des.js
var require_des = __commonJS({
  "node_modules/des.js/lib/des/des.js"(exports, module) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    var utils4 = require_utils6();
    var Cipher = require_cipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options) {
      Cipher.call(this, options);
      var state = new DESState();
      this._desState = state;
      this.deriveKeys(state, options.key);
    }
    inherits(DES, Cipher);
    module.exports = DES;
    DES.create = function create(options) {
      return new DES(options);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
      state.keys = new Array(16 * 2);
      assert.equal(key.length, this.blockSize, "Invalid key length");
      var kL = utils4.readUInt32BE(key, 0);
      var kR = utils4.readUInt32BE(key, 4);
      utils4.pc1(kL, kR, state.tmp, 0);
      kL = state.tmp[0];
      kR = state.tmp[1];
      for (var i = 0; i < state.keys.length; i += 2) {
        var shift = shiftTable[i >>> 1];
        kL = utils4.r28shl(kL, shift);
        kR = utils4.r28shl(kR, shift);
        utils4.pc2(kL, kR, state.keys, i);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._desState;
      var l = utils4.readUInt32BE(inp, inOff);
      var r = utils4.readUInt32BE(inp, inOff + 4);
      utils4.ip(l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state, l, r, state.tmp, 0);
      else
        this._decrypt(state, l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      utils4.writeUInt32BE(out, l, outOff);
      utils4.writeUInt32BE(out, r, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer, off) {
      if (this.padding === false) {
        return false;
      }
      var value = buffer.length - off;
      for (var i = off; i < buffer.length; i++)
        buffer[i] = value;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer) {
      if (this.padding === false) {
        return buffer;
      }
      var pad = buffer[buffer.length - 1];
      for (var i = buffer.length - pad; i < buffer.length; i++)
        assert.equal(buffer[i], pad);
      return buffer.slice(0, buffer.length - pad);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
      var l = lStart;
      var r = rStart;
      for (var i = 0; i < state.keys.length; i += 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils4.expand(r, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils4.substitute(keyL, keyR);
        var f2 = utils4.permute(s);
        var t = r;
        r = (l ^ f2) >>> 0;
        l = t;
      }
      utils4.rip(r, l, out, off);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
      var l = rStart;
      var r = lStart;
      for (var i = state.keys.length - 2; i >= 0; i -= 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils4.expand(l, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils4.substitute(keyL, keyR);
        var f2 = utils4.permute(s);
        var t = l;
        l = (r ^ f2) >>> 0;
        r = t;
      }
      utils4.rip(l, r, out, off);
    };
  }
});

// node_modules/des.js/lib/des/cbc.js
var require_cbc = __commonJS({
  "node_modules/des.js/lib/des/cbc.js"(exports) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    var proto = {};
    function CBCState(iv) {
      assert.equal(iv.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i = 0; i < this.iv.length; i++)
        this.iv[i] = iv[i];
    }
    function instantiate(Base) {
      function CBC(options) {
        Base.call(this, options);
        this._cbcInit();
      }
      inherits(CBC, Base);
      var keys = Object.keys(proto);
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        CBC.prototype[key] = proto[key];
      }
      CBC.create = function create(options) {
        return new CBC(options);
      };
      return CBC;
    }
    exports.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state = new CBCState(this.options.iv);
      this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv = state.iv;
      if (this.type === "encrypt") {
        for (var i = 0; i < this.blockSize; i++)
          iv[i] ^= inp[inOff + i];
        superProto._update.call(this, iv, 0, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = out[outOff + i];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          out[outOff + i] ^= iv[i];
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = inp[inOff + i];
      }
    };
  }
});

// node_modules/des.js/lib/des/ede.js
var require_ede = __commonJS({
  "node_modules/des.js/lib/des/ede.js"(exports, module) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    var Cipher = require_cipher();
    var DES = require_des();
    function EDEState(type, key) {
      assert.equal(key.length, 24, "Invalid key length");
      var k1 = key.slice(0, 8);
      var k2 = key.slice(8, 16);
      var k3 = key.slice(16, 24);
      if (type === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k1 }),
          DES.create({ type: "decrypt", key: k2 }),
          DES.create({ type: "encrypt", key: k3 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k3 }),
          DES.create({ type: "encrypt", key: k2 }),
          DES.create({ type: "decrypt", key: k1 })
        ];
      }
    }
    function EDE(options) {
      Cipher.call(this, options);
      var state = new EDEState(this.type, this.options.key);
      this._edeState = state;
    }
    inherits(EDE, Cipher);
    module.exports = EDE;
    EDE.create = function create(options) {
      return new EDE(options);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._edeState;
      state.ciphers[0]._update(inp, inOff, out, outOff);
      state.ciphers[1]._update(out, outOff, out, outOff);
      state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
  }
});

// node_modules/des.js/lib/des.js
var require_des2 = __commonJS({
  "node_modules/des.js/lib/des.js"(exports) {
    "use strict";
    exports.utils = require_utils6();
    exports.Cipher = require_cipher();
    exports.DES = require_des();
    exports.CBC = require_cbc();
    exports.EDE = require_ede();
  }
});

// node_modules/js-crypto-env/dist/index.js
var require_dist = __commonJS({
  "node_modules/js-crypto-env/dist/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCrypto = exports.getRootWebCrypto = exports.getWebCrypto = exports.getNodeCrypto = void 0;
    var getNodeCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return void 0;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return void 0;
      } else
        return require_crypto();
    };
    exports.getNodeCrypto = getNodeCrypto;
    var getWebCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return window.crypto.subtle;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return crypto.subtle;
      }
      return void 0;
    };
    exports.getWebCrypto = getWebCrypto;
    var getRootWebCrypto = function() {
      if (typeof window !== "undefined" && window.crypto) {
        return window.crypto;
      } else if (typeof window === "undefined" && typeof crypto !== "undefined") {
        return crypto;
      }
      return void 0;
    };
    exports.getRootWebCrypto = getRootWebCrypto;
    var getCrypto = function() {
      var webCrypto = getWebCrypto();
      var nodeCrypto6 = getNodeCrypto();
      if (typeof nodeCrypto6 !== "undefined")
        return { name: "nodeCrypto", crypto: nodeCrypto6 };
      else if (typeof webCrypto !== "undefined")
        return { name: "webCrypto", crypto: webCrypto };
      else
        return { name: void 0 };
    };
    exports.getCrypto = getCrypto;
    exports.default = { getNodeCrypto, getWebCrypto, getRootWebCrypto, getCrypto };
  }
});

// node_modules/js-crypto-hash/dist/params.js
var require_params2 = __commonJS({
  "node_modules/js-crypto-hash/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var params = {
      hashes: {
        "SHA3-512": { nodeName: "sha3-512", hashSize: 64 },
        "SHA3-384": { nodeName: "sha3-384", hashSize: 48 },
        "SHA3-256": { nodeName: "sha3-256", hashSize: 32 },
        "SHA3-224": { nodeName: "sha3-224", hashSize: 28 },
        "SHA-256": { nodeName: "sha256", hashSize: 32 },
        "SHA-384": { nodeName: "sha384", hashSize: 48 },
        "SHA-512": { nodeName: "sha512", hashSize: 64 },
        "SHA-1": { nodeName: "sha1", hashSize: 20 },
        "MD5": { nodeName: "md5", hashSize: 16 }
        // SHOULD NOT USE
      }
    };
    exports.default = params;
  }
});

// node_modules/crypt/crypt.js
var require_crypt = __commonJS({
  "node_modules/crypt/crypt.js"(exports, module) {
    (function() {
      var base64map = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", crypt = {
        // Bit-wise rotation left
        rotl: function(n, b) {
          return n << b | n >>> 32 - b;
        },
        // Bit-wise rotation right
        rotr: function(n, b) {
          return n << 32 - b | n >>> b;
        },
        // Swap big-endian to little-endian and vice versa
        endian: function(n) {
          if (n.constructor == Number) {
            return crypt.rotl(n, 8) & 16711935 | crypt.rotl(n, 24) & 4278255360;
          }
          for (var i = 0; i < n.length; i++)
            n[i] = crypt.endian(n[i]);
          return n;
        },
        // Generate an array of any length of random bytes
        randomBytes: function(n) {
          for (var bytes = []; n > 0; n--)
            bytes.push(Math.floor(Math.random() * 256));
          return bytes;
        },
        // Convert a byte array to big-endian 32-bit words
        bytesToWords: function(bytes) {
          for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)
            words[b >>> 5] |= bytes[i] << 24 - b % 32;
          return words;
        },
        // Convert big-endian 32-bit words to a byte array
        wordsToBytes: function(words) {
          for (var bytes = [], b = 0; b < words.length * 32; b += 8)
            bytes.push(words[b >>> 5] >>> 24 - b % 32 & 255);
          return bytes;
        },
        // Convert a byte array to a hex string
        bytesToHex: function(bytes) {
          for (var hex = [], i = 0; i < bytes.length; i++) {
            hex.push((bytes[i] >>> 4).toString(16));
            hex.push((bytes[i] & 15).toString(16));
          }
          return hex.join("");
        },
        // Convert a hex string to a byte array
        hexToBytes: function(hex) {
          for (var bytes = [], c = 0; c < hex.length; c += 2)
            bytes.push(parseInt(hex.substr(c, 2), 16));
          return bytes;
        },
        // Convert a byte array to a base-64 string
        bytesToBase64: function(bytes) {
          for (var base64 = [], i = 0; i < bytes.length; i += 3) {
            var triplet = bytes[i] << 16 | bytes[i + 1] << 8 | bytes[i + 2];
            for (var j = 0; j < 4; j++)
              if (i * 8 + j * 6 <= bytes.length * 8)
                base64.push(base64map.charAt(triplet >>> 6 * (3 - j) & 63));
              else
                base64.push("=");
          }
          return base64.join("");
        },
        // Convert a base-64 string to a byte array
        base64ToBytes: function(base64) {
          base64 = base64.replace(/[^A-Z0-9+\/]/ig, "");
          for (var bytes = [], i = 0, imod4 = 0; i < base64.length; imod4 = ++i % 4) {
            if (imod4 == 0)
              continue;
            bytes.push((base64map.indexOf(base64.charAt(i - 1)) & Math.pow(2, -2 * imod4 + 8) - 1) << imod4 * 2 | base64map.indexOf(base64.charAt(i)) >>> 6 - imod4 * 2);
          }
          return bytes;
        }
      };
      module.exports = crypt;
    })();
  }
});

// node_modules/charenc/charenc.js
var require_charenc = __commonJS({
  "node_modules/charenc/charenc.js"(exports, module) {
    var charenc = {
      // UTF-8 encoding
      utf8: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));
        }
      },
      // Binary encoding
      bin: {
        // Convert a string to a byte array
        stringToBytes: function(str) {
          for (var bytes = [], i = 0; i < str.length; i++)
            bytes.push(str.charCodeAt(i) & 255);
          return bytes;
        },
        // Convert a byte array to a string
        bytesToString: function(bytes) {
          for (var str = [], i = 0; i < bytes.length; i++)
            str.push(String.fromCharCode(bytes[i]));
          return str.join("");
        }
      }
    };
    module.exports = charenc;
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports, module) {
    module.exports = function(obj) {
      return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
    };
    function isBuffer(obj) {
      return !!obj.constructor && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    }
    function isSlowBuffer(obj) {
      return typeof obj.readFloatLE === "function" && typeof obj.slice === "function" && isBuffer(obj.slice(0, 0));
    }
  }
});

// node_modules/md5/md5.js
var require_md5 = __commonJS({
  "node_modules/md5/md5.js"(exports, module) {
    (function() {
      var crypt = require_crypt(), utf8 = require_charenc().utf8, isBuffer = require_is_buffer(), bin = require_charenc().bin, md52 = function(message, options) {
        if (message.constructor == String)
          if (options && options.encoding === "binary")
            message = bin.stringToBytes(message);
          else
            message = utf8.stringToBytes(message);
        else if (isBuffer(message))
          message = Array.prototype.slice.call(message, 0);
        else if (!Array.isArray(message) && message.constructor !== Uint8Array)
          message = message.toString();
        var m = crypt.bytesToWords(message), l = message.length * 8, a = 1732584193, b = -271733879, c = -1732584194, d = 271733878;
        for (var i = 0; i < m.length; i++) {
          m[i] = (m[i] << 8 | m[i] >>> 24) & 16711935 | (m[i] << 24 | m[i] >>> 8) & 4278255360;
        }
        m[l >>> 5] |= 128 << l % 32;
        m[(l + 64 >>> 9 << 4) + 14] = l;
        var FF = md52._ff, GG = md52._gg, HH = md52._hh, II = md52._ii;
        for (var i = 0; i < m.length; i += 16) {
          var aa = a, bb = b, cc = c, dd = d;
          a = FF(a, b, c, d, m[i + 0], 7, -680876936);
          d = FF(d, a, b, c, m[i + 1], 12, -389564586);
          c = FF(c, d, a, b, m[i + 2], 17, 606105819);
          b = FF(b, c, d, a, m[i + 3], 22, -1044525330);
          a = FF(a, b, c, d, m[i + 4], 7, -176418897);
          d = FF(d, a, b, c, m[i + 5], 12, 1200080426);
          c = FF(c, d, a, b, m[i + 6], 17, -1473231341);
          b = FF(b, c, d, a, m[i + 7], 22, -45705983);
          a = FF(a, b, c, d, m[i + 8], 7, 1770035416);
          d = FF(d, a, b, c, m[i + 9], 12, -1958414417);
          c = FF(c, d, a, b, m[i + 10], 17, -42063);
          b = FF(b, c, d, a, m[i + 11], 22, -1990404162);
          a = FF(a, b, c, d, m[i + 12], 7, 1804603682);
          d = FF(d, a, b, c, m[i + 13], 12, -40341101);
          c = FF(c, d, a, b, m[i + 14], 17, -1502002290);
          b = FF(b, c, d, a, m[i + 15], 22, 1236535329);
          a = GG(a, b, c, d, m[i + 1], 5, -165796510);
          d = GG(d, a, b, c, m[i + 6], 9, -1069501632);
          c = GG(c, d, a, b, m[i + 11], 14, 643717713);
          b = GG(b, c, d, a, m[i + 0], 20, -373897302);
          a = GG(a, b, c, d, m[i + 5], 5, -701558691);
          d = GG(d, a, b, c, m[i + 10], 9, 38016083);
          c = GG(c, d, a, b, m[i + 15], 14, -660478335);
          b = GG(b, c, d, a, m[i + 4], 20, -405537848);
          a = GG(a, b, c, d, m[i + 9], 5, 568446438);
          d = GG(d, a, b, c, m[i + 14], 9, -1019803690);
          c = GG(c, d, a, b, m[i + 3], 14, -187363961);
          b = GG(b, c, d, a, m[i + 8], 20, 1163531501);
          a = GG(a, b, c, d, m[i + 13], 5, -1444681467);
          d = GG(d, a, b, c, m[i + 2], 9, -51403784);
          c = GG(c, d, a, b, m[i + 7], 14, 1735328473);
          b = GG(b, c, d, a, m[i + 12], 20, -1926607734);
          a = HH(a, b, c, d, m[i + 5], 4, -378558);
          d = HH(d, a, b, c, m[i + 8], 11, -2022574463);
          c = HH(c, d, a, b, m[i + 11], 16, 1839030562);
          b = HH(b, c, d, a, m[i + 14], 23, -35309556);
          a = HH(a, b, c, d, m[i + 1], 4, -1530992060);
          d = HH(d, a, b, c, m[i + 4], 11, 1272893353);
          c = HH(c, d, a, b, m[i + 7], 16, -155497632);
          b = HH(b, c, d, a, m[i + 10], 23, -1094730640);
          a = HH(a, b, c, d, m[i + 13], 4, 681279174);
          d = HH(d, a, b, c, m[i + 0], 11, -358537222);
          c = HH(c, d, a, b, m[i + 3], 16, -722521979);
          b = HH(b, c, d, a, m[i + 6], 23, 76029189);
          a = HH(a, b, c, d, m[i + 9], 4, -640364487);
          d = HH(d, a, b, c, m[i + 12], 11, -421815835);
          c = HH(c, d, a, b, m[i + 15], 16, 530742520);
          b = HH(b, c, d, a, m[i + 2], 23, -995338651);
          a = II(a, b, c, d, m[i + 0], 6, -198630844);
          d = II(d, a, b, c, m[i + 7], 10, 1126891415);
          c = II(c, d, a, b, m[i + 14], 15, -1416354905);
          b = II(b, c, d, a, m[i + 5], 21, -57434055);
          a = II(a, b, c, d, m[i + 12], 6, 1700485571);
          d = II(d, a, b, c, m[i + 3], 10, -1894986606);
          c = II(c, d, a, b, m[i + 10], 15, -1051523);
          b = II(b, c, d, a, m[i + 1], 21, -2054922799);
          a = II(a, b, c, d, m[i + 8], 6, 1873313359);
          d = II(d, a, b, c, m[i + 15], 10, -30611744);
          c = II(c, d, a, b, m[i + 6], 15, -1560198380);
          b = II(b, c, d, a, m[i + 13], 21, 1309151649);
          a = II(a, b, c, d, m[i + 4], 6, -145523070);
          d = II(d, a, b, c, m[i + 11], 10, -1120210379);
          c = II(c, d, a, b, m[i + 2], 15, 718787259);
          b = II(b, c, d, a, m[i + 9], 21, -343485551);
          a = a + aa >>> 0;
          b = b + bb >>> 0;
          c = c + cc >>> 0;
          d = d + dd >>> 0;
        }
        return crypt.endian([a, b, c, d]);
      };
      md52._ff = function(a, b, c, d, x, s, t) {
        var n = a + (b & c | ~b & d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._gg = function(a, b, c, d, x, s, t) {
        var n = a + (b & d | c & ~d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._hh = function(a, b, c, d, x, s, t) {
        var n = a + (b ^ c ^ d) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._ii = function(a, b, c, d, x, s, t) {
        var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;
        return (n << s | n >>> 32 - s) + b;
      };
      md52._blocksize = 16;
      md52._digestsize = 16;
      module.exports = function(message, options) {
        if (message === void 0 || message === null)
          throw new Error("Illegal argument " + message);
        var digestbytes = crypt.wordsToBytes(md52(message, options));
        return options && options.asBytes ? digestbytes : options && options.asString ? bin.bytesToString(digestbytes) : crypt.bytesToHex(digestbytes);
      };
    })();
  }
});

// node_modules/sha3/sponge/permute/copy/index.js
var require_copy3 = __commonJS({
  "node_modules/sha3/sponge/permute/copy/index.js"(exports, module) {
    "use strict";
    var copy = function copy2(I, i) {
      return function(O, o) {
        var oi = o * 2;
        var ii = i * 2;
        O[oi] = I[ii];
        O[oi + 1] = I[ii + 1];
      };
    };
    module.exports = copy;
  }
});

// node_modules/sha3/sponge/permute/chi/index.js
var require_chi = __commonJS({
  "node_modules/sha3/sponge/permute/chi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _copy = _interopRequireDefault(require_copy3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var chi = function chi2(_ref) {
      var A = _ref.A, C = _ref.C;
      for (var y = 0; y < 25; y += 5) {
        for (var x = 0; x < 5; x++) {
          (0, _copy["default"])(A, y + x)(C, x);
        }
        for (var _x = 0; _x < 5; _x++) {
          var xy = (y + _x) * 2;
          var x1 = (_x + 1) % 5 * 2;
          var x2 = (_x + 2) % 5 * 2;
          A[xy] ^= ~C[x1] & C[x2];
          A[xy + 1] ^= ~C[x1 + 1] & C[x2 + 1];
        }
      }
    };
    var _default = chi;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/iota/round-constants/index.js
var require_round_constants = __commonJS({
  "node_modules/sha3/sponge/permute/iota/round-constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var ROUND_CONSTANTS = new Uint32Array([0, 1, 0, 32898, 2147483648, 32906, 2147483648, 2147516416, 0, 32907, 0, 2147483649, 2147483648, 2147516545, 2147483648, 32777, 0, 138, 0, 136, 0, 2147516425, 0, 2147483658, 0, 2147516555, 2147483648, 139, 2147483648, 32905, 2147483648, 32771, 2147483648, 32770, 2147483648, 128, 0, 32778, 2147483648, 2147483658, 2147483648, 2147516545, 2147483648, 32896, 0, 2147483649, 2147483648, 2147516424]);
    var _default = ROUND_CONSTANTS;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/iota/index.js
var require_iota = __commonJS({
  "node_modules/sha3/sponge/permute/iota/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _roundConstants = _interopRequireDefault(require_round_constants());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var iota = function iota2(_ref) {
      var A = _ref.A, roundIndex = _ref.roundIndex;
      var i = roundIndex * 2;
      A[0] ^= _roundConstants["default"][i];
      A[1] ^= _roundConstants["default"][i + 1];
    };
    var _default = iota;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js
var require_pi_shuffles = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/pi-shuffles/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var PI_SHUFFLES = [10, 7, 11, 17, 18, 3, 5, 16, 8, 21, 24, 4, 15, 23, 19, 13, 12, 2, 20, 14, 22, 9, 6, 1];
    var _default = PI_SHUFFLES;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js
var require_rho_offsets = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/rho-offsets/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var RHO_OFFSETS = [1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44];
    var _default = RHO_OFFSETS;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/rho-pi/index.js
var require_rho_pi = __commonJS({
  "node_modules/sha3/sponge/permute/rho-pi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _piShuffles = _interopRequireDefault(require_pi_shuffles());
    var _rhoOffsets = _interopRequireDefault(require_rho_offsets());
    var _copy = _interopRequireDefault(require_copy3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var rhoPi = function rhoPi2(_ref) {
      var A = _ref.A, C = _ref.C, W = _ref.W;
      (0, _copy["default"])(A, 1)(W, 0);
      var H = 0;
      var L = 0;
      var Wi = 0;
      var ri = 32;
      for (var i = 0; i < 24; i++) {
        var j = _piShuffles["default"][i];
        var r = _rhoOffsets["default"][i];
        (0, _copy["default"])(A, j)(C, 0);
        H = W[0];
        L = W[1];
        ri = 32 - r;
        Wi = r < 32 ? 0 : 1;
        W[Wi] = H << r | L >>> ri;
        W[(Wi + 1) % 2] = L << r | H >>> ri;
        (0, _copy["default"])(W, 0)(A, j);
        (0, _copy["default"])(C, 0)(W, 0);
      }
    };
    var _default = rhoPi;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/theta/index.js
var require_theta = __commonJS({
  "node_modules/sha3/sponge/permute/theta/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _copy = _interopRequireDefault(require_copy3());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var theta = function theta2(_ref) {
      var A = _ref.A, C = _ref.C, D = _ref.D, W = _ref.W;
      var H = 0;
      var L = 0;
      for (var x = 0; x < 5; x++) {
        var x20 = x * 2;
        var x21 = (x + 5) * 2;
        var x22 = (x + 10) * 2;
        var x23 = (x + 15) * 2;
        var x24 = (x + 20) * 2;
        C[x20] = A[x20] ^ A[x21] ^ A[x22] ^ A[x23] ^ A[x24];
        C[x20 + 1] = A[x20 + 1] ^ A[x21 + 1] ^ A[x22 + 1] ^ A[x23 + 1] ^ A[x24 + 1];
      }
      for (var _x = 0; _x < 5; _x++) {
        (0, _copy["default"])(C, (_x + 1) % 5)(W, 0);
        H = W[0];
        L = W[1];
        W[0] = H << 1 | L >>> 31;
        W[1] = L << 1 | H >>> 31;
        D[_x * 2] = C[(_x + 4) % 5 * 2] ^ W[0];
        D[_x * 2 + 1] = C[(_x + 4) % 5 * 2 + 1] ^ W[1];
        for (var y = 0; y < 25; y += 5) {
          A[(y + _x) * 2] ^= D[_x * 2];
          A[(y + _x) * 2 + 1] ^= D[_x * 2 + 1];
        }
      }
    };
    var _default = theta;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/permute/index.js
var require_permute = __commonJS({
  "node_modules/sha3/sponge/permute/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _chi = _interopRequireDefault(require_chi());
    var _iota = _interopRequireDefault(require_iota());
    var _rhoPi = _interopRequireDefault(require_rho_pi());
    var _theta = _interopRequireDefault(require_theta());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var permute = function permute2() {
      var C = new Uint32Array(10);
      var D = new Uint32Array(10);
      var W = new Uint32Array(2);
      return function(A) {
        for (var roundIndex = 0; roundIndex < 24; roundIndex++) {
          (0, _theta["default"])({ A, C, D, W });
          (0, _rhoPi["default"])({ A, C, W });
          (0, _chi["default"])({ A, C });
          (0, _iota["default"])({ A, roundIndex });
        }
        C.fill(0);
        D.fill(0);
        W.fill(0);
      };
    };
    var _default = permute;
    exports["default"] = _default;
  }
});

// node_modules/sha3/sponge/index.js
var require_sponge = __commonJS({
  "node_modules/sha3/sponge/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = void 0;
    var _buffer = require_buffer();
    var _permute = _interopRequireDefault(require_permute());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var xorWords = function xorWords2(I, O) {
      for (var i = 0; i < I.length; i += 8) {
        var o = i / 4;
        O[o] ^= I[i + 7] << 24 | I[i + 6] << 16 | I[i + 5] << 8 | I[i + 4];
        O[o + 1] ^= I[i + 3] << 24 | I[i + 2] << 16 | I[i + 1] << 8 | I[i];
      }
      return O;
    };
    var readWords = function readWords2(I, O) {
      for (var o = 0; o < O.length; o += 8) {
        var i = o / 4;
        O[o] = I[i + 1];
        O[o + 1] = I[i + 1] >>> 8;
        O[o + 2] = I[i + 1] >>> 16;
        O[o + 3] = I[i + 1] >>> 24;
        O[o + 4] = I[i];
        O[o + 5] = I[i] >>> 8;
        O[o + 6] = I[i] >>> 16;
        O[o + 7] = I[i] >>> 24;
      }
      return O;
    };
    var Sponge = function Sponge2(_ref) {
      var _this = this;
      var capacity = _ref.capacity, padding = _ref.padding;
      var keccak = (0, _permute["default"])();
      var stateSize = 200;
      var blockSize = capacity / 8;
      var queueSize = stateSize - capacity / 4;
      var queueOffset = 0;
      var state = new Uint32Array(stateSize / 4);
      var queue = _buffer.Buffer.allocUnsafe(queueSize);
      this.absorb = function(buffer) {
        for (var i = 0; i < buffer.length; i++) {
          queue[queueOffset] = buffer[i];
          queueOffset += 1;
          if (queueOffset >= queueSize) {
            xorWords(queue, state);
            keccak(state);
            queueOffset = 0;
          }
        }
        return _this;
      };
      this.squeeze = function() {
        var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var output = { buffer: options.buffer || _buffer.Buffer.allocUnsafe(blockSize), padding: options.padding || padding, queue: _buffer.Buffer.allocUnsafe(queue.length), state: new Uint32Array(state.length) };
        queue.copy(output.queue);
        for (var i = 0; i < state.length; i++) {
          output.state[i] = state[i];
        }
        output.queue.fill(0, queueOffset);
        output.queue[queueOffset] |= output.padding;
        output.queue[queueSize - 1] |= 128;
        xorWords(output.queue, output.state);
        for (var offset = 0; offset < output.buffer.length; offset += queueSize) {
          keccak(output.state);
          readWords(output.state, output.buffer.slice(offset, offset + queueSize));
        }
        return output.buffer;
      };
      this.reset = function() {
        queue.fill(0);
        state.fill(0);
        queueOffset = 0;
        return _this;
      };
      return this;
    };
    var _default = Sponge;
    exports["default"] = _default;
  }
});

// node_modules/sha3/index.js
var require_sha3 = __commonJS({
  "node_modules/sha3/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports["default"] = exports.SHAKE = exports.SHA3Hash = exports.SHA3 = exports.Keccak = void 0;
    var _buffer = require_buffer();
    var _sponge = _interopRequireDefault(require_sponge());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { "default": obj };
    }
    var createHash = function createHash2(_ref) {
      var allowedSizes = _ref.allowedSizes, defaultSize = _ref.defaultSize, padding = _ref.padding;
      return function Hash() {
        var _this = this;
        var size = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : defaultSize;
        if (!this || this.constructor !== Hash) {
          return new Hash(size);
        }
        if (allowedSizes && !allowedSizes.includes(size)) {
          throw new Error("Unsupported hash length");
        }
        var sponge = new _sponge["default"]({ capacity: size });
        this.update = function(input) {
          var encoding = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "utf8";
          if (_buffer.Buffer.isBuffer(input)) {
            sponge.absorb(input);
            return _this;
          }
          if (typeof input === "string") {
            return _this.update(_buffer.Buffer.from(input, encoding));
          }
          throw new TypeError("Not a string or buffer");
        };
        this.digest = function() {
          var formatOrOptions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "binary";
          var options = typeof formatOrOptions === "string" ? { format: formatOrOptions } : formatOrOptions;
          var buffer = sponge.squeeze({ buffer: options.buffer, padding: options.padding || padding });
          if (options.format && options.format !== "binary") {
            return buffer.toString(options.format);
          }
          return buffer;
        };
        this.reset = function() {
          sponge.reset();
          return _this;
        };
        return this;
      };
    };
    var Keccak = createHash({ allowedSizes: [224, 256, 384, 512], defaultSize: 512, padding: 1 });
    exports.Keccak = Keccak;
    var SHA3 = createHash({ allowedSizes: [224, 256, 384, 512], defaultSize: 512, padding: 6 });
    exports.SHA3 = SHA3;
    var SHAKE = createHash({ allowedSizes: [128, 256], defaultSize: 256, padding: 31 });
    exports.SHAKE = SHAKE;
    var SHA3Hash = Keccak;
    exports.SHA3Hash = SHA3Hash;
    SHA3.SHA3Hash = SHA3Hash;
    var _default = SHA3;
    exports["default"] = _default;
  }
});

// node_modules/js-crypto-hash/dist/hash.js
var require_hash2 = __commonJS({
  "node_modules/js-crypto-hash/dist/hash.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compute = void 0;
    var util = __importStar(require_dist());
    var params_1 = __importDefault(require_params2());
    var md5_1 = __importDefault(require_md5());
    var sha3_1 = require_sha3();
    var jsHash = __importStar(require_hash());
    var compute = function(msg, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, msgHash, errMsg, native, e_1, e_2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              env = util.getCrypto();
              native = true;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 5, , 6]);
              if (!(env.name === "webCrypto" && typeof env.crypto.digest === "function"))
                return [3, 3];
              return [4, env.crypto.digest(hash, msg)];
            case 2:
              msgHash = _a.sent();
              return [3, 4];
            case 3:
              if (env.name === "nodeCrypto") {
                msgHash = nodedigest(hash, msg, env.crypto);
              } else
                native = false;
              _a.label = 4;
            case 4:
              return [3, 6];
            case 5:
              e_1 = _a.sent();
              if (e_1 instanceof Error) {
                errMsg = e_1.message;
              }
              native = false;
              return [3, 6];
            case 6:
              if (!!native)
                return [3, 10];
              _a.label = 7;
            case 7:
              _a.trys.push([7, 9, , 10]);
              return [4, purejs(hash, msg)];
            case 8:
              msgHash = _a.sent();
              return [3, 10];
            case 9:
              e_2 = _a.sent();
              if (e_2 instanceof Error) {
                errMsg = "".concat(typeof errMsg === "undefined" ? "" : errMsg, " => ").concat(e_2.message);
                throw new Error("UnsupportedEnvironment: ".concat(errMsg));
              } else {
                throw new Error("UnsupportedEnvironment");
              }
              return [3, 10];
            case 10:
              return [2, new Uint8Array(msgHash)];
          }
        });
      });
    };
    exports.compute = compute;
    var nodedigest = function(hash, msg, nodeCrypto6) {
      var alg = params_1.default.hashes[hash].nodeName;
      var hashFunc = nodeCrypto6.createHash(alg);
      hashFunc.update(msg);
      return hashFunc.digest();
    };
    var purejs = function(hash, msg) {
      return __awaiter(void 0, void 0, void 0, function() {
        var h, sha3Len, sha3obj, Buffer_1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (!(hash === "MD5"))
                return [3, 1];
              h = (0, md5_1.default)(Array.from(msg), { asBytes: true });
              return [3, 4];
            case 1:
              if (!(["SHA3-512", "SHA3-384", "SHA3-256", "SHA3-224"].indexOf(hash) >= 0))
                return [3, 3];
              sha3Len = params_1.default.hashes[hash].hashSize * 8;
              sha3obj = new sha3_1.SHA3(sha3Len);
              return [4, Promise.resolve().then(function() {
                return __importStar(require_buffer());
              })];
            case 2:
              Buffer_1 = _a.sent().Buffer;
              sha3obj.update(Buffer_1.from(msg));
              h = sha3obj.digest("binary");
              return [3, 4];
            case 3:
              h = jsHash[params_1.default.hashes[hash].nodeName]().update(msg).digest();
              _a.label = 4;
            case 4:
              return [2, new Uint8Array(h)];
          }
        });
      });
    };
  }
});

// node_modules/js-crypto-hash/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/js-crypto-hash/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.compute = void 0;
    var hash = __importStar(require_hash2());
    exports.compute = hash.compute;
    exports.default = { compute: exports.compute };
  }
});

// node_modules/js-crypto-hmac/dist/params.js
var require_params3 = __commonJS({
  "node_modules/js-crypto-hmac/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var params = {
      hashes: {
        "SHA3-512": { nodeName: "sha3-512", hashSize: 64, blockSize: 72 },
        "SHA3-384": { nodeName: "sha3-384", hashSize: 48, blockSize: 104 },
        "SHA3-256": { nodeName: "sha3-256", hashSize: 32, blockSize: 136 },
        "SHA3-224": { nodeName: "sha3-224", hashSize: 28, blockSize: 144 },
        "SHA-256": { nodeName: "sha256", hashSize: 32, blockSize: 64 },
        "SHA-384": { nodeName: "sha384", hashSize: 48, blockSize: 128 },
        "SHA-512": { nodeName: "sha512", hashSize: 64, blockSize: 128 },
        "SHA-1": { nodeName: "sha1", hashSize: 20, blockSize: 64 },
        "MD5": { nodeName: "md5", hashSize: 16, blockSize: 64 }
      }
    };
    exports.default = params;
  }
});

// node_modules/js-crypto-hmac/dist/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/js-crypto-hmac/dist/hmac.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.compute = void 0;
    var params_1 = __importDefault(require_params3());
    var util = __importStar(require_dist());
    var js_crypto_hash_1 = __importDefault(require_dist2());
    var compute = function(key, data, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var env, msgKeyedHash, errMsg, native, keyObj, f2, e_1, e_2;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              env = util.getCrypto();
              native = true;
              _a.label = 1;
            case 1:
              _a.trys.push([1, 6, , 7]);
              if (!(env.name === "webCrypto" && typeof env.crypto.importKey === "function" && typeof env.crypto.sign === "function"))
                return [3, 4];
              return [4, env.crypto.importKey("raw", key, {
                name: "HMAC",
                hash: { name: hash }
              }, false, ["sign", "verify"])];
            case 2:
              keyObj = _a.sent();
              return [4, env.crypto.sign({ name: "HMAC", hash: { name: hash } }, keyObj, data)];
            case 3:
              msgKeyedHash = _a.sent();
              return [3, 5];
            case 4:
              if (env.name === "nodeCrypto") {
                f2 = env.crypto.createHmac(params_1.default.hashes[hash].nodeName, key);
                msgKeyedHash = f2.update(data).digest();
              } else
                native = false;
              _a.label = 5;
            case 5:
              return [3, 7];
            case 6:
              e_1 = _a.sent();
              if (e_1 instanceof Error) {
                errMsg = e_1.message;
              }
              native = false;
              return [3, 7];
            case 7:
              if (!!native)
                return [3, 11];
              _a.label = 8;
            case 8:
              _a.trys.push([8, 10, , 11]);
              return [4, purejs(key, data, hash)];
            case 9:
              msgKeyedHash = _a.sent();
              return [3, 11];
            case 10:
              e_2 = _a.sent();
              if (e_2 instanceof Error) {
                errMsg = "".concat(errMsg, " => ").concat(e_2.message);
                throw new Error("UnsupportedEnvironments: ".concat(errMsg));
              } else {
                throw new Error("UnsupportedEnvironments");
              }
              return [3, 11];
            case 11:
              return [2, new Uint8Array(msgKeyedHash)];
          }
        });
      });
    };
    exports.compute = compute;
    var purejs = function(key, data, hash) {
      return __awaiter(void 0, void 0, void 0, function() {
        var B, L, K, KxorIpad, KxorOpad, inner, hashedInner, outer;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              B = params_1.default.hashes[hash].blockSize;
              L = params_1.default.hashes[hash].hashSize;
              if (!(key.length > B))
                return [3, 2];
              return [4, js_crypto_hash_1.default.compute(key, hash)];
            case 1:
              key = _a.sent();
              _a.label = 2;
            case 2:
              K = new Uint8Array(B);
              K.set(key);
              KxorIpad = K.map(function(k) {
                return 255 & (54 ^ k);
              });
              KxorOpad = K.map(function(k) {
                return 255 & (92 ^ k);
              });
              inner = new Uint8Array(B + data.length);
              inner.set(KxorIpad);
              inner.set(data, B);
              return [4, js_crypto_hash_1.default.compute(inner, hash)];
            case 3:
              hashedInner = _a.sent();
              outer = new Uint8Array(B + L);
              outer.set(KxorOpad);
              outer.set(hashedInner, B);
              return [2, js_crypto_hash_1.default.compute(outer, hash)];
          }
        });
      });
    };
    var verify = function(key, data, mac, hash) {
      if (hash === void 0) {
        hash = "SHA-256";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var newMac;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              return [4, (0, exports.compute)(key, data, hash)];
            case 1:
              newMac = _a.sent();
              return [2, mac.toString() === newMac.toString()];
          }
        });
      });
    };
    exports.verify = verify;
  }
});

// node_modules/js-crypto-hmac/dist/index.js
var require_dist3 = __commonJS({
  "node_modules/js-crypto-hmac/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verify = exports.compute = void 0;
    var hmac = __importStar(require_hmac2());
    exports.compute = hmac.compute;
    exports.verify = hmac.verify;
    exports.default = { compute: exports.compute, verify: exports.verify };
  }
});

// node_modules/js-crypto-pbkdf/dist/params.js
var require_params4 = __commonJS({
  "node_modules/js-crypto-pbkdf/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var params = {
      hashes: {
        "SHA3-512": { hashSize: 64 },
        "SHA3-384": { hashSize: 48 },
        "SHA3-256": { hashSize: 32 },
        "SHA3-224": { hashSize: 28 },
        "SHA-256": { hashSize: 32 },
        "SHA-384": { hashSize: 48 },
        "SHA-512": { hashSize: 64 },
        "SHA-1": { hashSize: 20 },
        "MD5": { hashSize: 16 }
        // SHOULD NOT USE
      }
    };
    exports.default = params;
  }
});

// node_modules/js-crypto-pbkdf/dist/pbkdf.js
var require_pbkdf = __commonJS({
  "node_modules/js-crypto-pbkdf/dist/pbkdf.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf1 = exports.pbkdf2 = void 0;
    var js_encoding_utils_1 = __importDefault(require_src());
    var js_crypto_hash_1 = __importDefault(require_dist2());
    var js_crypto_hmac_1 = __importDefault(require_dist3());
    var params_1 = __importDefault(require_params4());
    var pbkdf2 = function(p, s, c, dkLen, hash) {
      return __awaiter(void 0, void 0, void 0, function() {
        var uintP, hLen, l, r, funcF, Tis, DK, i, TisResolved;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (c <= 0)
                throw new Error("InvalidIterationCount");
              if (dkLen <= 0)
                throw new Error("InvalidDerivedKeyLength");
              uintP = typeof p === "string" ? js_encoding_utils_1.default.encoder.stringToArrayBuffer(p) : p;
              hLen = params_1.default.hashes[hash].hashSize;
              if (dkLen > (Math.pow(2, 32) - 1) * hLen)
                throw new Error("DerivedKeyTooLong");
              l = Math.ceil(dkLen / hLen);
              r = dkLen - (l - 1) * hLen;
              funcF = function(i2) {
                return __awaiter(void 0, void 0, void 0, function() {
                  var seed, u, outputF, j;
                  return __generator(this, function(_a2) {
                    switch (_a2.label) {
                      case 0:
                        seed = new Uint8Array(s.length + 4);
                        seed.set(s);
                        seed.set(nwbo(i2 + 1, 4), s.length);
                        return [4, js_crypto_hmac_1.default.compute(uintP, seed, hash)];
                      case 1:
                        u = _a2.sent();
                        outputF = new Uint8Array(u);
                        j = 1;
                        _a2.label = 2;
                      case 2:
                        if (!(j < c))
                          return [3, 5];
                        return [4, js_crypto_hmac_1.default.compute(uintP, u, hash)];
                      case 3:
                        u = _a2.sent();
                        outputF = u.map(function(elem, idx) {
                          return elem ^ outputF[idx];
                        });
                        _a2.label = 4;
                      case 4:
                        j++;
                        return [3, 2];
                      case 5:
                        return [2, { index: i2, value: outputF }];
                    }
                  });
                });
              };
              Tis = [];
              DK = new Uint8Array(dkLen);
              for (i = 0; i < l; i++)
                Tis.push(funcF(i));
              return [4, Promise.all(Tis)];
            case 1:
              TisResolved = _a.sent();
              TisResolved.forEach(function(elem) {
                if (elem.index !== l - 1)
                  DK.set(elem.value, elem.index * hLen);
                else
                  DK.set(elem.value.slice(0, r), elem.index * hLen);
              });
              return [2, DK];
          }
        });
      });
    };
    exports.pbkdf2 = pbkdf2;
    var nwbo = function(num, len) {
      var arr = new Uint8Array(len);
      for (var i = 0; i < len; i++)
        arr[i] = num >> (len - i - 1) * 8;
      return arr;
    };
    var pbkdf1 = function(p, s, c, dkLen, hash) {
      return __awaiter(void 0, void 0, void 0, function() {
        var seed, i;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (c <= 0)
                throw new Error("InvalidIterationCount");
              if (dkLen <= 0)
                throw new Error("InvalidDerivedKeyLength");
              if (typeof p === "string")
                p = js_encoding_utils_1.default.encoder.stringToArrayBuffer(p);
              if (dkLen > params_1.default.hashes[hash].hashSize)
                throw new Error("DerivedKeyTooLong");
              seed = new Uint8Array(p.length + s.length);
              seed.set(p);
              seed.set(s, p.length);
              i = 0;
              _a.label = 1;
            case 1:
              if (!(i < c))
                return [3, 4];
              return [4, js_crypto_hash_1.default.compute(seed, hash)];
            case 2:
              seed = _a.sent();
              _a.label = 3;
            case 3:
              i++;
              return [3, 1];
            case 4:
              return [2, seed.slice(0, dkLen)];
          }
        });
      });
    };
    exports.pbkdf1 = pbkdf1;
  }
});

// node_modules/js-crypto-pbkdf/dist/index.js
var require_dist4 = __commonJS({
  "node_modules/js-crypto-pbkdf/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf1 = exports.pbkdf2 = void 0;
    var pbkdf = __importStar(require_pbkdf());
    exports.pbkdf2 = pbkdf.pbkdf2;
    exports.pbkdf1 = pbkdf.pbkdf1;
    exports.default = { pbkdf2: exports.pbkdf2, pbkdf1: exports.pbkdf1 };
  }
});

// node_modules/js-crypto-aes/dist/params.js
var require_params5 = __commonJS({
  "node_modules/js-crypto-aes/dist/params.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ciphers = {
      "AES-GCM": {
        nodePrefix: "aes-",
        nodeSuffix: "-gcm",
        ivLength: 12,
        tagLength: 16,
        staticIvLength: true
        // if true, IV length must be always ivLength.
      },
      "AES-CBC": {
        nodePrefix: "aes-",
        nodeSuffix: "-cbc",
        ivLength: 16,
        staticIvLength: true
      },
      "AES-CTR": {
        nodePrefix: "aes-",
        nodeSuffix: "-ctr",
        ivLength: 12,
        staticIvLength: false
      }
    };
    var wrapKeys = {
      "AES-KW": {
        nodePrefix: "id-aes",
        nodeSuffix: "-wrap",
        ivLength: 8,
        staticIvLength: true,
        defaultIv: new Uint8Array([166, 166, 166, 166, 166, 166, 166, 166])
      }
    };
    exports.default = { ciphers, wrapKeys };
  }
});

// node_modules/js-crypto-aes/dist/nodeapi.js
var require_nodeapi = __commonJS({
  "node_modules/js-crypto-aes/dist/nodeapi.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.unwrapKey = exports.wrapKey = void 0;
    var params_1 = __importDefault(require_params5());
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a, nodeCrypto6) {
      var name = _a.name, iv = _a.iv;
      return (0, exports.encrypt)(keyToBeWrapped, wrappingKey, { name, iv }, nodeCrypto6, true);
    };
    exports.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, unwrappingKey, _a, nodeCrypto6) {
      var name = _a.name, iv = _a.iv;
      return (0, exports.decrypt)(wrappedKey, unwrappingKey, { name, iv }, nodeCrypto6, true);
    };
    exports.unwrapKey = unwrapKey;
    var encrypt = function(msg, key, _a, nodeCrypto6, wrapKey2) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      if (wrapKey2 === void 0) {
        wrapKey2 = false;
      }
      var alg = getNodeName(name, key.byteLength, wrapKey2 ? params_1.default.wrapKeys : params_1.default.ciphers);
      var cipher;
      switch (name) {
        case "AES-GCM": {
          cipher = nodeCrypto6.createCipheriv(alg, key, iv, { authTagLength: tagLength });
          cipher.setAAD(additionalData);
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          var counter = new Uint8Array(16);
          counter.set(iv);
          counter[15] += 1;
          cipher = nodeCrypto6.createCipheriv(alg, key, counter);
          break;
        }
        default: {
          cipher = nodeCrypto6.createCipheriv(alg, key, iv);
          break;
        }
      }
      var body;
      var final;
      var tag;
      try {
        body = new Uint8Array(cipher.update(msg));
        final = new Uint8Array(cipher.final());
        tag = new Uint8Array([]);
        if (name === "AES-GCM")
          tag = new Uint8Array(cipher.getAuthTag());
      } catch (e) {
        throw new Error("NodeCrypto_EncryptionFailure");
      }
      var data = new Uint8Array(body.length + final.length + tag.length);
      data.set(body);
      data.set(final, body.length);
      data.set(tag, body.length + final.length);
      return data;
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, key, _a, nodeCrypto6, unwrapKey2) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      if (unwrapKey2 === void 0) {
        unwrapKey2 = false;
      }
      var alg = getNodeName(name, key.byteLength, unwrapKey2 ? params_1.default.wrapKeys : params_1.default.ciphers);
      var decipher;
      var body;
      switch (name) {
        case "AES-GCM": {
          decipher = nodeCrypto6.createDecipheriv(alg, key, iv, { authTagLength: tagLength });
          decipher.setAAD(additionalData);
          body = data.slice(0, data.length - tagLength);
          var tag = data.slice(data.length - tagLength);
          decipher.setAuthTag(tag);
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          var counter = new Uint8Array(16);
          counter.set(iv);
          counter[15] += 1;
          decipher = nodeCrypto6.createDecipheriv(alg, key, counter);
          body = data;
          break;
        }
        default: {
          decipher = nodeCrypto6.createDecipheriv(alg, key, iv);
          body = data;
          break;
        }
      }
      var decryptedBody;
      var final;
      try {
        decryptedBody = decipher.update(body);
        final = decipher.final();
      } catch (e) {
        throw new Error("NodeCrypto_DecryptionFailure");
      }
      var msg = new Uint8Array(final.length + decryptedBody.length);
      msg.set(decryptedBody);
      msg.set(final, decryptedBody.length);
      return msg;
    };
    exports.decrypt = decrypt;
    var getNodeName = function(name, keyLength, dict) {
      var alg = dict[name].nodePrefix;
      alg = "".concat(alg).concat((keyLength * 8).toString());
      return alg + dict[name].nodeSuffix;
    };
  }
});

// node_modules/js-crypto-aes/dist/webapi.js
var require_webapi = __commonJS({
  "node_modules/js-crypto-aes/dist/webapi.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decrypt = exports.encrypt = exports.unwrapKey = exports.wrapKey = void 0;
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a, webCrypto) {
      var name = _a.name, iv = _a.iv;
      return __awaiter(void 0, void 0, void 0, function() {
        var kek, cek, data, e_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 4, , 5]);
              return [4, webCrypto.importKey("raw", wrappingKey, { name }, false, ["wrapKey", "unwrapKey"])];
            case 1:
              kek = _b.sent();
              return [4, webCrypto.importKey("raw", keyToBeWrapped, { name }, true, ["wrapKey", "unwrapKey"])];
            case 2:
              cek = _b.sent();
              return [4, webCrypto.wrapKey("raw", cek, kek, { name, iv })];
            case 3:
              data = _b.sent();
              return [2, new Uint8Array(data)];
            case 4:
              e_1 = _b.sent();
              if (e_1 instanceof Error) {
                throw new Error("WebCrypto_FailedToWrapKey - ".concat(e_1.message));
              } else {
                throw new Error("WebCrypto_FailedToWrapKey");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, unwrappingKey, _a, webCrypto) {
      var name = _a.name, iv = _a.iv;
      return __awaiter(void 0, void 0, void 0, function() {
        var kek, cek, _b, e_2;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              _c.trys.push([0, 4, , 5]);
              return [4, webCrypto.importKey("raw", unwrappingKey, { name }, false, ["wrapKey", "unwrapKey"])];
            case 1:
              kek = _c.sent();
              return [4, webCrypto.unwrapKey("raw", wrappedKey, kek, { name, iv }, { name: "AES-GCM" }, true, ["encrypt", "decrypt"])];
            case 2:
              cek = _c.sent();
              _b = Uint8Array.bind;
              return [4, webCrypto.exportKey("raw", cek)];
            case 3:
              return [2, new (_b.apply(Uint8Array, [void 0, _c.sent()]))()];
            case 4:
              e_2 = _c.sent();
              if (e_2 instanceof Error) {
                throw new Error("WebCrypto_FailedToUnwrapKey - ".concat(e_2.message));
              } else {
                throw new Error("WebCrypto_FailedToUnwrapKey");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.unwrapKey = unwrapKey;
    var encrypt = function(msg, key, _a, webCrypto) {
      var _b = _a.name, name = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var encryptionConfig, sessionKeyObj, data, e_3;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              encryptionConfig = setCipherParams({ name, iv, additionalData, tagLength });
              _c.label = 1;
            case 1:
              _c.trys.push([1, 4, , 5]);
              return [4, webCrypto.importKey("raw", key, encryptionConfig, false, ["encrypt", "decrypt"])];
            case 2:
              sessionKeyObj = _c.sent();
              return [4, webCrypto.encrypt(encryptionConfig, sessionKeyObj, msg)];
            case 3:
              data = _c.sent();
              return [2, new Uint8Array(data)];
            case 4:
              e_3 = _c.sent();
              if (e_3 instanceof Error) {
                throw new Error("WebCrypto_EncryptionFailure: ".concat(e_3.message));
              } else {
                throw new Error("WebCrypto_EncryptionFailure");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, key, _a, webCrypto) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var decryptionConfig, sessionKeyObj, msg, e_4;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              decryptionConfig = setCipherParams({ name, iv, additionalData, tagLength });
              _b.label = 1;
            case 1:
              _b.trys.push([1, 4, , 5]);
              return [4, webCrypto.importKey("raw", key, decryptionConfig, false, ["encrypt", "decrypt"])];
            case 2:
              sessionKeyObj = _b.sent();
              return [4, webCrypto.decrypt(decryptionConfig, sessionKeyObj, data)];
            case 3:
              msg = _b.sent();
              return [2, new Uint8Array(msg)];
            case 4:
              e_4 = _b.sent();
              if (e_4 instanceof Error) {
                throw new Error("WebCrypto_DecryptionFailure: ".concat(e_4.message));
              } else {
                throw new Error("WebCrypto_DecryptionFailure");
              }
              return [3, 5];
            case 5:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.decrypt = decrypt;
    var setCipherParams = function(_a) {
      var name = _a.name, iv = _a.iv, additionalData = _a.additionalData, tagLength = _a.tagLength;
      var alg = { name, iv, additionalData, tagLength };
      switch (name) {
        case "AES-GCM": {
          alg.tagLength = tagLength * 8;
          break;
        }
        case "AES-CBC": {
          break;
        }
        case "AES-CTR": {
          if (iv.length === 0 || iv.length > 16)
            throw new Error("InvalidIVLength");
          alg.counter = new Uint8Array(16);
          alg.counter.set(iv);
          alg.counter[15] += 1;
          alg.length = 128;
          break;
        }
      }
      return alg;
    };
  }
});

// node_modules/js-crypto-aes/dist/aes.js
var require_aes = __commonJS({
  "node_modules/js-crypto-aes/dist/aes.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwrapKey = exports.wrapKey = exports.decrypt = exports.encrypt = void 0;
    var util = __importStar(require_dist());
    var nodeapi = __importStar(require_nodeapi());
    var webapi = __importStar(require_webapi());
    var params_1 = __importDefault(require_params5());
    var assertAlgorithms = function(_a) {
      var name = _a.name, iv = _a.iv, tagLength = _a.tagLength;
      if (params_1.default.ciphers[name].ivLength) {
        if (!(iv instanceof Uint8Array))
          throw new Error("InvalidArguments");
        if (iv.byteLength < 2 || iv.byteLength > 16)
          throw new Error("InvalidIVLength");
        if (params_1.default.ciphers[name].staticIvLength && params_1.default.ciphers[name].ivLength !== iv.byteLength)
          throw new Error("InvalidIVLength");
      }
      if (params_1.default.ciphers[name].tagLength && tagLength) {
        if (!Number.isInteger(tagLength))
          throw new Error("InvalidArguments");
        if (tagLength < 4 || tagLength > 16)
          throw new Error("InvalidTagLength");
      }
    };
    var encrypt = function(msg, key, _a) {
      var _b = _a.name, name = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var env;
        return __generator(this, function(_d) {
          assertAlgorithms({ name, iv, tagLength });
          if (params_1.default.ciphers[name].tagLength && !tagLength)
            tagLength = params_1.default.ciphers[name].tagLength;
          env = util.getCrypto();
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.encrypt !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.encrypt(msg, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.encrypt(msg, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else
            throw new Error("UnsupportedEnvironment");
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.encrypt = encrypt;
    var decrypt = function(data, key, _a) {
      var _b = _a.name, name = _b === void 0 ? "AES-GCM" : _b, iv = _a.iv, _c = _a.additionalData, additionalData = _c === void 0 ? new Uint8Array([]) : _c, tagLength = _a.tagLength;
      return __awaiter(void 0, void 0, void 0, function() {
        var env;
        return __generator(this, function(_d) {
          assertAlgorithms({ name, iv, tagLength });
          if (params_1.default.ciphers[name].tagLength && !tagLength)
            tagLength = params_1.default.ciphers[name].tagLength;
          env = util.getCrypto();
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.decrypt !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.decrypt(data, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.decrypt(data, key, { name, iv, additionalData, tagLength }, env.crypto)];
          } else
            throw new Error("UnsupportedEnvironment");
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.decrypt = decrypt;
    var wrapKey = function(keyToBeWrapped, wrappingKey, _a) {
      var name = _a.name;
      return __awaiter(void 0, void 0, void 0, function() {
        var env, iv;
        return __generator(this, function(_b) {
          if (keyToBeWrapped.length % 8 > 0)
            throw new Error("WrappedKeyMustBeMultipleOf8");
          env = util.getCrypto();
          iv = params_1.default.wrapKeys["AES-KW"].defaultIv;
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.wrapKey !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.wrapKey(keyToBeWrapped, wrappingKey, { name, iv }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.wrapKey(keyToBeWrapped, wrappingKey, { name, iv }, env.crypto)];
          } else {
            throw new Error("UnsupportedEnvironment");
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.wrapKey = wrapKey;
    var unwrapKey = function(wrappedKey, wrappingKey, _a) {
      var name = _a.name;
      return __awaiter(void 0, void 0, void 0, function() {
        var env, iv;
        return __generator(this, function(_b) {
          env = util.getCrypto();
          iv = params_1.default.wrapKeys["AES-KW"].defaultIv;
          if (env.name === "webCrypto") {
            if (typeof env.crypto.importKey !== "function" || typeof env.crypto.unwrapKey !== "function")
              throw new Error("UnsupportedWebCrypto");
            return [2, webapi.unwrapKey(wrappedKey, wrappingKey, { name, iv }, env.crypto)];
          } else if (env.name === "nodeCrypto") {
            return [2, nodeapi.unwrapKey(wrappedKey, wrappingKey, { name, iv }, env.crypto)];
          } else {
            throw new Error("UnsupportedEnvironment");
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    exports.unwrapKey = unwrapKey;
  }
});

// node_modules/js-crypto-aes/dist/index.js
var require_dist5 = __commonJS({
  "node_modules/js-crypto-aes/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unwrapKey = exports.wrapKey = exports.decrypt = exports.encrypt = void 0;
    var aes = __importStar(require_aes());
    exports.encrypt = aes.encrypt;
    exports.decrypt = aes.decrypt;
    exports.wrapKey = aes.wrapKey;
    exports.unwrapKey = aes.unwrapKey;
    exports.default = { encrypt: exports.encrypt, decrypt: exports.decrypt, wrapKey: exports.wrapKey, unwrapKey: exports.unwrapKey };
  }
});

// node_modules/js-crypto-random/dist/random.js
var require_random = __commonJS({
  "node_modules/js-crypto-random/dist/random.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRandomBytes = exports.getRandomSampledString = exports.getRandomAsciiString = exports.getRandomString = void 0;
    var util = __importStar(require_dist());
    var getRandomString = function(len) {
      var array = (0, exports.getRandomBytes)(len);
      var types = (0, exports.getRandomBytes)(len);
      var finalString = "";
      for (var i = 0; i < len; i++) {
        types[i] = types[i] % 3;
        array[i] = types[i] === 0 ? array[i] % 10 + 48 : array[i] % 26 + (types[i] === 1 ? 65 : 97);
        finalString += String.fromCharCode(array[i]);
      }
      return finalString;
    };
    exports.getRandomString = getRandomString;
    var getRandomAsciiString = function(len) {
      var array = (0, exports.getRandomBytes)(len);
      var finalString = "";
      for (var i = 0; i < len; i++) {
        array[i] = array[i] % 94 + 32;
        finalString += String.fromCharCode(array[i]);
      }
      return finalString;
    };
    exports.getRandomAsciiString = getRandomAsciiString;
    var getRandomSampledString = function(len, candidates) {
      var candidateLen = candidates.length;
      if (candidateLen === 0)
        return "";
      var array = (0, exports.getRandomBytes)(len);
      var finalString = "";
      for (var i = 0; i < len; i++) {
        finalString += candidates[array[i] % candidateLen];
      }
      return finalString;
    };
    exports.getRandomSampledString = getRandomSampledString;
    var getRandomBytes = function(len) {
      var webCrypto = util.getRootWebCrypto();
      var nodeCrypto6 = util.getNodeCrypto();
      if (typeof webCrypto !== "undefined" && typeof webCrypto.getRandomValues === "function") {
        var array = new Uint8Array(len);
        webCrypto.getRandomValues(array);
        return array;
      } else if (typeof nodeCrypto6 !== "undefined") {
        return new Uint8Array(nodeCrypto6.randomBytes(len));
      } else {
        throw new Error("UnsupportedEnvironment");
      }
    };
    exports.getRandomBytes = getRandomBytes;
  }
});

// node_modules/js-crypto-random/dist/index.js
var require_dist6 = __commonJS({
  "node_modules/js-crypto-random/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRandomSampledString = exports.getRandomString = exports.getRandomAsciiString = exports.getRandomBytes = void 0;
    var random = __importStar(require_random());
    exports.getRandomBytes = random.getRandomBytes;
    exports.getRandomAsciiString = random.getRandomAsciiString;
    exports.getRandomString = random.getRandomString;
    exports.getRandomSampledString = random.getRandomSampledString;
    exports.default = { getRandomBytes: exports.getRandomBytes, getRandomAsciiString: exports.getRandomAsciiString, getRandomString: exports.getRandomString, getRandomSampledString: exports.getRandomSampledString };
  }
});

// node_modules/js-crypto-key-utils/dist/rfc8018.js
var require_rfc8018 = __commonJS({
  "node_modules/js-crypto-key-utils/dist/rfc8018.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptEncryptedPrivateKeyInfo = exports.encryptEncryptedPrivateKeyInfo = void 0;
    var params = __importStar(require_params());
    var asn1def_1 = require_asn1def();
    var des_js_1 = __importDefault(require_des2());
    var BufferMod = __importStar(require_buffer());
    var asn1_js_1 = __importDefault(require_asn1());
    var js_encoding_utils_1 = __importDefault(require_src());
    var js_crypto_pbkdf_1 = __importDefault(require_dist4());
    var js_crypto_aes_1 = __importDefault(require_dist5());
    var js_crypto_random_1 = __importDefault(require_dist6());
    var Buffer2 = BufferMod.Buffer;
    var BN = asn1_js_1.default.bignum;
    var encryptEncryptedPrivateKeyInfo = function(binKey, options) {
      if (options === void 0) {
        options = { passphrase: "" };
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var kdfAlgorithm, encryptedPBES2, encryptedPBES1;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (typeof options.algorithm === "undefined")
                options.algorithm = "pbes2";
              if (typeof options.iterationCount === "undefined")
                options.iterationCount = 2048;
              if (!(options.algorithm === "pbes2"))
                return [3, 2];
              if (typeof options.cipher === "undefined")
                options.cipher = "aes256-cbc";
              if (typeof options.prf === "undefined")
                options.prf = "hmacWithSHA256";
              kdfAlgorithm = "pbkdf2";
              return [4, encryptPBES2(binKey, options.passphrase, kdfAlgorithm, options.prf, options.iterationCount, options.cipher)];
            case 1:
              encryptedPBES2 = _a.sent();
              return [2, encodePBES2(encryptedPBES2)];
            case 2:
              return [4, encryptPBES1(binKey, options.passphrase, options.algorithm, options.iterationCount)];
            case 3:
              encryptedPBES1 = _a.sent();
              encryptedPBES1.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[encryptedPBES1.encryptionAlgorithm.algorithm].oid;
              encryptedPBES1.encryptionAlgorithm.parameters = asn1def_1.PBEParameter.encode(encryptedPBES1.encryptionAlgorithm.parameters, "der");
              return [2, asn1def_1.EncryptedPrivateKeyInfo.encode(encryptedPBES1, "der")];
          }
        });
      });
    };
    exports.encryptEncryptedPrivateKeyInfo = encryptEncryptedPrivateKeyInfo;
    var decryptEncryptedPrivateKeyInfo = function(epki, passphrase) {
      return __awaiter(void 0, void 0, void 0, function() {
        var decoded;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              decoded = {};
              decoded.encryptionAlgorithm = {
                algorithm: params.getAlgorithmFromOidStrict(epki.encryptionAlgorithm.algorithm, params.passwordBasedEncryptionSchemes)
              };
              if (decoded.encryptionAlgorithm.algorithm === "pbes2") {
                decoded.encryptionAlgorithm.parameters = decodePBES2(epki.encryptionAlgorithm.parameters);
              } else {
                decoded.encryptionAlgorithm.parameters = asn1def_1.PBEParameter.decode(epki.encryptionAlgorithm.parameters, "der");
              }
              decoded.encryptedData = epki.encryptedData;
              if (!(decoded.encryptionAlgorithm.algorithm === "pbes2"))
                return [3, 2];
              return [4, decryptPBES2(decoded, passphrase)];
            case 1:
              return [2, _a.sent()];
            case 2:
              return [4, decryptPBES1(decoded, passphrase)];
            case 3:
              return [2, _a.sent()];
          }
        });
      });
    };
    exports.decryptEncryptedPrivateKeyInfo = decryptEncryptedPrivateKeyInfo;
    var encodePBES2 = function(decoded) {
      var epki = { encryptionAlgorithm: {} };
      epki.encryptionAlgorithm.algorithm = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].oid;
      var kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;
      if (kdf.algorithm === "pbkdf2") {
        kdf.parameters.prf.algorithm = params.pbkdf2Prfs[kdf.parameters.prf.algorithm].oid;
        kdf.parameters = asn1def_1.PBKDF2Params.encode(kdf.parameters, "der");
      } else
        throw new Error("UnsupportedKDF");
      kdf.algorithm = params.keyDerivationFunctions[kdf.algorithm].oid;
      var eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;
      if (Object.keys(asn1def_1.PBES2ESParams).indexOf(eS.algorithm) >= 0) {
        eS.parameters = asn1def_1.PBES2ESParams[eS.algorithm].encode(eS.parameters, "der");
      } else
        throw new Error("UnsupportedCipher");
      eS.algorithm = params.encryptionSchemes[eS.algorithm].oid;
      epki.encryptionAlgorithm.parameters = asn1def_1.PBES2Params.encode({ keyDerivationFunc: kdf, encryptionScheme: eS }, "der");
      epki.encryptedData = decoded.encryptedData;
      return asn1def_1.EncryptedPrivateKeyInfo.encode(epki, "der");
    };
    var decodePBES2 = function(rawParams) {
      var pbes2Params = asn1def_1.PBES2Params.decode(rawParams, "der");
      var kdfAlgorithm = params.getAlgorithmFromOidStrict(pbes2Params.keyDerivationFunc.algorithm, params.keyDerivationFunctions);
      var iterationCount;
      var salt;
      var prf;
      if (kdfAlgorithm === "pbkdf2") {
        var pbkdf2Params = asn1def_1.PBKDF2Params.decode(pbes2Params.keyDerivationFunc.parameters, "der");
        prf = {
          algorithm: params.getAlgorithmFromOidStrict(pbkdf2Params.prf.algorithm, params.pbkdf2Prfs),
          parameters: pbkdf2Params.prf.parameters
        };
        iterationCount = pbkdf2Params.iterationCount;
        salt = { type: pbkdf2Params.salt.type, value: pbkdf2Params.salt.value };
      } else
        throw new Error("UnsupportedKDF");
      var encryptionScheme = params.getAlgorithmFromOidStrict(pbes2Params.encryptionScheme.algorithm, params.encryptionSchemes);
      var encryptionParams;
      if (Object.keys(asn1def_1.PBES2ESParams).indexOf(encryptionScheme) >= 0) {
        encryptionParams = asn1def_1.PBES2ESParams[encryptionScheme].decode(pbes2Params.encryptionScheme.parameters, "der");
      } else
        throw new Error("UnsupportedCipher");
      return {
        keyDerivationFunc: {
          algorithm: kdfAlgorithm,
          parameters: { salt, iterationCount, prf }
        },
        encryptionScheme: {
          algorithm: encryptionScheme,
          parameters: encryptionParams
        }
      };
    };
    var encryptPBES2 = function(binKey, passphrase, kdfAlgorithm, prf, iterationCount, cipher) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pBuffer, salt, keyLength, key, iv, encryptedData, _a, _b, CBC, ct, _c, _d;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              return [4, js_crypto_random_1.default.getRandomBytes(params.keyDerivationFunctions[kdfAlgorithm].defaultSaltLen)];
            case 1:
              salt = _e.sent();
              keyLength = params.encryptionSchemes[cipher].keyLength;
              if (!(kdfAlgorithm === "pbkdf2"))
                return [3, 3];
              return [4, js_crypto_pbkdf_1.default.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash)];
            case 2:
              key = _e.sent();
              return [3, 4];
            case 3:
              throw new Error("UnsupportedKDF");
            case 4:
              if (!(cipher === "des-ede3-cbc"))
                return [3, 6];
              _b = (_a = Buffer2).from;
              return [4, js_crypto_random_1.default.getRandomBytes(params.encryptionSchemes[cipher].ivLength)];
            case 5:
              iv = _b.apply(_a, [_e.sent()]);
              CBC = des_js_1.default.CBC.instantiate(des_js_1.default.EDE);
              ct = CBC.create({ type: "encrypt", key: Buffer2.from(key), iv });
              encryptedData = Buffer2.from(ct.update(binKey).concat(ct.final()));
              return [3, 10];
            case 6:
              if (!(cipher === "aes128-cbc" || cipher === "aes192-cbc" || cipher === "aes256-cbc"))
                return [3, 9];
              return [4, js_crypto_random_1.default.getRandomBytes(params.encryptionSchemes[cipher].ivLength)];
            case 7:
              iv = _e.sent();
              _d = (_c = Buffer2).from;
              return [4, js_crypto_aes_1.default.encrypt(new Uint8Array(binKey), key, { name: "AES-CBC", iv })];
            case 8:
              encryptedData = _d.apply(_c, [_e.sent()]);
              iv = Buffer2.from(iv);
              return [3, 10];
            case 9:
              throw new Error("UnsupportedCipher");
            case 10:
              return [2, {
                encryptedData,
                encryptionAlgorithm: {
                  algorithm: "pbes2",
                  parameters: {
                    keyDerivationFunc: {
                      algorithm: kdfAlgorithm,
                      parameters: {
                        salt: { type: "specified", value: Buffer2.from(salt) },
                        iterationCount: new BN(iterationCount),
                        prf: { algorithm: prf, parameters: Buffer2.from([5, 0]) }
                      }
                    },
                    encryptionScheme: { algorithm: cipher, parameters: iv }
                  }
                }
              }];
          }
        });
      });
    };
    var decryptPBES2 = function(decoded, passphrase) {
      return __awaiter(void 0, void 0, void 0, function() {
        var kdf, eS, keyLength, key, pBuffer, salt, iterationCount, prf, out, iv, CBC, pt, iv, _a, _b;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              kdf = decoded.encryptionAlgorithm.parameters.keyDerivationFunc;
              eS = decoded.encryptionAlgorithm.parameters.encryptionScheme;
              keyLength = params.encryptionSchemes[eS.algorithm].keyLength;
              if (!(kdf.algorithm === "pbkdf2"))
                return [3, 2];
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              if (kdf.parameters.salt.type !== "specified")
                throw new Error("UnsupportedSaltSource");
              salt = new Uint8Array(kdf.parameters.salt.value);
              iterationCount = kdf.parameters.iterationCount.toNumber();
              prf = kdf.parameters.prf.algorithm;
              return [4, js_crypto_pbkdf_1.default.pbkdf2(pBuffer, salt, iterationCount, keyLength, params.pbkdf2Prfs[prf].hash)];
            case 1:
              key = _c.sent();
              return [3, 3];
            case 2:
              throw new Error("UnsupportedKDF");
            case 3:
              if (!(eS.algorithm === "des-ede3-cbc"))
                return [3, 4];
              iv = eS.parameters;
              CBC = des_js_1.default.CBC.instantiate(des_js_1.default.EDE);
              pt = CBC.create({ type: "decrypt", key, iv });
              out = Buffer2.from(pt.update(decoded.encryptedData).concat(pt.final()));
              return [3, 7];
            case 4:
              if (!(eS.algorithm === "aes128-cbc" || eS.algorithm === "aes192-cbc" || eS.algorithm === "aes256-cbc"))
                return [3, 6];
              iv = new Uint8Array(eS.parameters);
              _b = (_a = Buffer2).from;
              return [4, js_crypto_aes_1.default.decrypt(new Uint8Array(decoded.encryptedData), key, { name: "AES-CBC", iv })];
            case 5:
              out = _b.apply(_a, [_c.sent()]);
              return [3, 7];
            case 6:
              throw new Error("UnsupportedEncryptionAlgorithm");
            case 7:
              return [2, asn1def_1.OneAsymmetricKey.decode(out, "der")];
          }
        });
      });
    };
    var encryptPBES1 = function(binKey, passphrase, algorithm, iterationCount) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pBuffer, salt, hash, keyIv, key, iv, encrypt, out, CBC, ct;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              return [4, js_crypto_random_1.default.getRandomBytes(8)];
            case 1:
              salt = _a.sent();
              hash = params.passwordBasedEncryptionSchemes[algorithm].hash;
              return [4, js_crypto_pbkdf_1.default.pbkdf1(pBuffer, salt, iterationCount, 16, hash)];
            case 2:
              keyIv = _a.sent();
              key = keyIv.slice(0, 8);
              iv = keyIv.slice(8, 16);
              encrypt = params.passwordBasedEncryptionSchemes[algorithm].encrypt;
              if (encrypt === "DES-CBC") {
                CBC = des_js_1.default.CBC.instantiate(des_js_1.default.DES);
                ct = CBC.create({ type: "encrypt", key, iv });
                out = Buffer2.from(ct.update(binKey).concat(ct.final()));
              } else
                throw new Error("UnsupportedEncryptionAlgorithm");
              return [2, {
                encryptionAlgorithm: {
                  algorithm,
                  parameters: {
                    salt: Buffer2.from(salt),
                    iterationCount: new BN(iterationCount)
                  }
                },
                encryptedData: out
              }];
          }
        });
      });
    };
    var decryptPBES1 = function(decoded, passphrase) {
      return __awaiter(void 0, void 0, void 0, function() {
        var pBuffer, salt, hash, iterationCount, keyIv, key, iv, encrypt, out, CBC, ct;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              pBuffer = js_encoding_utils_1.default.encoder.stringToArrayBuffer(passphrase);
              salt = new Uint8Array(decoded.encryptionAlgorithm.parameters.salt);
              hash = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].hash;
              iterationCount = decoded.encryptionAlgorithm.parameters.iterationCount.toNumber();
              return [4, js_crypto_pbkdf_1.default.pbkdf1(pBuffer, salt, iterationCount, 16, hash)];
            case 1:
              keyIv = _a.sent();
              key = keyIv.slice(0, 8);
              iv = keyIv.slice(8, 16);
              encrypt = params.passwordBasedEncryptionSchemes[decoded.encryptionAlgorithm.algorithm].encrypt;
              if (encrypt === "DES-CBC") {
                CBC = des_js_1.default.CBC.instantiate(des_js_1.default.DES);
                ct = CBC.create({ type: "decrypt", key, iv });
                out = Buffer2.from(ct.update(decoded.encryptedData).concat(ct.final()));
              } else
                throw new Error("UnsupportedEncryptionAlgorithm");
              return [2, asn1def_1.OneAsymmetricKey.decode(out, "der")];
          }
        });
      });
    };
  }
});

// node_modules/js-crypto-key-utils/dist/asn1enc.js
var require_asn1enc = __commonJS({
  "node_modules/js-crypto-key-utils/dist/asn1enc.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwk = exports.fromJwk = void 0;
    var asn1ec = __importStar(require_asn1ec());
    var asn1rsa = __importStar(require_asn1rsa());
    var params_1 = require_params();
    var js_encoding_utils_1 = __importDefault(require_src());
    var BufferMod = __importStar(require_buffer());
    var asn1def_1 = require_asn1def();
    var rfc8018_1 = require_rfc8018();
    var util_1 = require_util3();
    var Buffer2 = BufferMod.Buffer;
    var fromJwk = function(jwkey, format, _a) {
      var outputPublic = _a.outputPublic, _b = _a.compact, compact = _b === void 0 ? false : _b, encOptions = _a.encOptions;
      return __awaiter(void 0, void 0, void 0, function() {
        var orgType, type, decoded, binKey;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              orgType = (0, util_1.getJwkType)(jwkey);
              type = typeof outputPublic === "boolean" && outputPublic ? "public" : orgType;
              if (jwkey.kty === "EC") {
                decoded = asn1ec.fromJWK(jwkey, type, compact);
              } else if (jwkey.kty === "RSA") {
                decoded = asn1rsa.fromJwk(jwkey, type);
              }
              if (!(type === "public"))
                return [3, 1];
              binKey = asn1def_1.SubjectPublicKeyInfo.encode(decoded, "der");
              return [3, 3];
            case 1:
              binKey = asn1def_1.OneAsymmetricKey.encode(decoded, "der");
              if (!(typeof encOptions !== "undefined" && typeof encOptions.passphrase !== "undefined" && encOptions.passphrase.length > 0))
                return [3, 3];
              return [4, (0, rfc8018_1.encryptEncryptedPrivateKeyInfo)(binKey, encOptions)];
            case 2:
              binKey = _c.sent();
              type = "encryptedPrivate";
              _c.label = 3;
            case 3:
              binKey = new Uint8Array(binKey);
              return [2, format === "pem" ? js_encoding_utils_1.default.formatter.binToPem(binKey, type) : binKey];
          }
        });
      });
    };
    exports.fromJwk = fromJwk;
    var toJwk = function(key, format, _a) {
      var outputPublic = _a.outputPublic, passphrase = _a.passphrase;
      return __awaiter(void 0, void 0, void 0, function() {
        var binKey, decoded, type, keyTypes;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              binKey = format === "pem" ? js_encoding_utils_1.default.formatter.pemToBin(key) : key;
              try {
                decoded = asn1def_1.KeyStructure.decode(Buffer2.from(binKey), "der");
              } catch (e) {
                throw new Error("FailedToDecodeKey");
              }
              if (!(decoded.type === "subjectPublicKeyInfo"))
                return [3, 1];
              type = "public";
              decoded = decoded.value;
              return [3, 4];
            case 1:
              type = typeof outputPublic === "boolean" && outputPublic ? "public" : "private";
              if (!(decoded.type === "encryptedPrivateKeyInfo"))
                return [3, 3];
              return [4, (0, rfc8018_1.decryptEncryptedPrivateKeyInfo)(decoded.value, passphrase)];
            case 2:
              decoded = _b.sent();
              return [3, 4];
            case 3:
              if (decoded.type === "oneAsymmetricKey")
                decoded = decoded.value;
              else
                throw new Error("UnsupportedKeyStructure");
              _b.label = 4;
            case 4:
              keyTypes = (0, params_1.getAlgorithmFromOid)(type === "public" ? decoded.algorithm.algorithm : decoded.privateKeyAlgorithm.algorithm, params_1.publicKeyAlgorithms);
              if (keyTypes.length < 1)
                throw new Error("UnsupportedKey");
              if (keyTypes[0] === "EC") {
                return [2, asn1ec.toJWK(decoded, type)];
              } else if (keyTypes[0] === "RSA") {
                return [2, asn1rsa.toJwk(decoded, type)];
              } else
                throw new Error("InvalidKeyType");
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.toJwk = toJwk;
  }
});

// node_modules/js-crypto-key-utils/dist/converter.js
var require_converter = __commonJS({
  "node_modules/js-crypto-key-utils/dist/converter.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toJwkFrom = exports.fromJwkTo = void 0;
    var asn1enc = __importStar(require_asn1enc());
    var octenc = __importStar(require_octenc());
    var fromJwkTo = function(output, jwkey, options) {
      if (output === void 0) {
        output = "pem";
      }
      if (options === void 0) {
        options = {};
      }
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (jwkey.kty !== "EC" && jwkey.kty !== "RSA")
                throw new Error("UnsupportedKeyType");
              if (jwkey.kty === "EC" && typeof options.compact === "undefined")
                options.compact = false;
              if (output === "oct" && options.output !== "string")
                options.output = "binary";
              if (typeof options.encryptParams === "undefined")
                options.encryptParams = { passphrase: "" };
              if ((output === "der" || output === "pem") && typeof options.encryptParams.passphrase === "undefined")
                options.encryptParams.passphrase = "";
              if (!(output === "der" || output === "pem"))
                return [3, 2];
              return [4, asn1enc.fromJwk(jwkey, output, { outputPublic: options.outputPublic, compact: options.compact, encOptions: options.encryptParams })];
            case 1:
              return [2, _a.sent()];
            case 2:
              if (output === "oct" && jwkey.kty === "EC") {
                return [2, octenc.fromJwk(jwkey, { outputPublic: options.outputPublic, outputFormat: options.output, compact: options.compact })];
              } else
                throw new Error("UnsupportedConversion");
              _a.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.fromJwkTo = fromJwkTo;
    var toJwkFrom = function(input, key, options) {
      if (options === void 0) {
        options = {};
      }
      return __awaiter(void 0, void 0, void 0, function() {
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (input === "oct" && !options.namedCurve)
                throw new Error("InappropriateOptions");
              if ((input === "der" || input === "pem") && typeof options.passphrase === "undefined")
                options.passphrase = "";
              if (!(input === "der" || input === "pem"))
                return [3, 2];
              return [4, asn1enc.toJwk(key, input, { outputPublic: options.outputPublic, passphrase: options.passphrase })];
            case 1:
              return [2, _a.sent()];
            case 2:
              if (input === "oct") {
                return [2, octenc.toJwk(key, options.namedCurve, { outputPublic: options.outputPublic })];
              } else
                throw new Error("UnsupportedConversion");
              _a.label = 3;
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.toJwkFrom = toJwkFrom;
  }
});

// node_modules/js-crypto-key-utils/dist/thumbprint.js
var require_thumbprint = __commonJS({
  "node_modules/js-crypto-key-utils/dist/thumbprint.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getJwkThumbprint = void 0;
    var js_encoding_utils_1 = __importDefault(require_src());
    var js_crypto_hash_1 = __importDefault(require_dist2());
    var BufferMod = __importStar(require_buffer());
    var Buffer2 = BufferMod.Buffer;
    var getJwkThumbprint = function(jwkey, alg, output) {
      if (alg === void 0) {
        alg = "SHA-256";
      }
      if (output === void 0) {
        output = "binary";
      }
      return __awaiter(void 0, void 0, void 0, function() {
        var jsonString, uint8json, thumbPrintBuf;
        return __generator(this, function(_a) {
          switch (_a.label) {
            case 0:
              if (["hex", "binary"].indexOf(output) < 0)
                throw new Error("UnsupportedOutputFormat");
              if (jwkey.kty === "EC") {
                jsonString = JSON.stringify({ crv: jwkey.crv, kty: jwkey.kty, x: jwkey.x, y: jwkey.y });
              } else if (jwkey.kty === "RSA") {
                jsonString = JSON.stringify({ e: jwkey.e, kty: jwkey.kty, n: jwkey.n });
              } else
                throw new Error("UnsupportedKeyType");
              uint8json = new Uint8Array(Buffer2.from(jsonString, "utf8"));
              return [4, js_crypto_hash_1.default.compute(uint8json, alg)];
            case 1:
              thumbPrintBuf = _a.sent();
              if (output === "hex")
                return [2, js_encoding_utils_1.default.encoder.arrayBufferToHexString(thumbPrintBuf)];
              else if (output === "base64")
                return [2, js_encoding_utils_1.default.encoder.encodeBase64(thumbPrintBuf)];
              else
                return [2, thumbPrintBuf];
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    exports.getJwkThumbprint = getJwkThumbprint;
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache2 = this.__data__;
      if (cache2 instanceof ListCache) {
        var pairs = cache2.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache2 = this.__data__ = new MapCache(pairs);
      }
      cache2.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/js-crypto-key-utils/dist/key.js
var require_key3 = __commonJS({
  "node_modules/js-crypto-key-utils/dist/key.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f2, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f2)
          throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _)
          try {
            if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f2 = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Key = void 0;
    var converter_1 = require_converter();
    var thumbprint_1 = require_thumbprint();
    var js_encoding_utils_1 = __importDefault(require_src());
    var util_1 = require_util3();
    var cloneDeep = require_lodash();
    var Key = (
      /** @class */
      function() {
        function Key2(format, key, options) {
          if (options === void 0) {
            options = {};
          }
          var localKey = cloneDeep(key);
          var localOpt = cloneDeep(options);
          this._type = null;
          this._jwk = null;
          this._der = null;
          this._oct = {};
          this._isEncrypted = false;
          this._current = { jwk: false, der: false, oct: false };
          if (format === "jwk") {
            this._setJwk(localKey);
          } else if (format === "der" || format === "pem") {
            if (format === "der" && !(localKey instanceof Uint8Array))
              throw new Error("DerKeyMustBeUint8Array");
            if (format === "pem" && typeof localKey !== "string")
              throw new Error("PemKeyMustBeString");
            this._setAsn1(localKey, format);
          } else if (format === "oct") {
            if (typeof localOpt.namedCurve !== "string")
              throw new Error("namedCurveMustBeSpecified");
            if (!(localKey instanceof Uint8Array))
              throw new Error("OctetKeyMustBeUint8Array");
            this._setSec1(localKey, localOpt.namedCurve);
          } else
            throw new Error("UnsupportedType");
        }
        Key2.prototype._setJwk = function(jwkey) {
          this._type = (0, util_1.getJwkType)(jwkey);
          this._jwk = jwkey;
          if (this._isEncrypted)
            this._der = null;
          this._isEncrypted = false;
          this._setCurrentStatus();
        };
        Key2.prototype._setAsn1 = function(asn1key, format) {
          this._type = (0, util_1.isAsn1Public)(asn1key, format) ? "public" : "private";
          this._isEncrypted = (0, util_1.isAsn1Encrypted)(asn1key, format);
          this._der = format === "pem" ? js_encoding_utils_1.default.formatter.pemToBin(asn1key) : asn1key;
          if (this._isEncrypted) {
            this._jwk = null;
            this._oct = {};
          }
          this._setCurrentStatus();
        };
        Key2.prototype._setSec1 = function(sec1key, namedCurve) {
          this._type = (0, util_1.getSec1KeyType)(sec1key, namedCurve);
          this._oct = { namedCurve, key: sec1key };
          if (this._isEncrypted)
            this._der = null;
          this._isEncrypted = false;
          this._setCurrentStatus();
        };
        Key2.prototype._setCurrentStatus = function() {
          this._current.jwk = this._jwk !== null && (this._jwk.kty === "RSA" || this._jwk.kty === "EC");
          this._current.der = this._der !== null && this._der.length > 0;
          this._current.oct = typeof this._oct.key !== "undefined" && typeof this._oct.namedCurve !== "undefined" && this._oct.key.length > 0;
        };
        Key2.prototype.export = function(format, options) {
          if (format === void 0) {
            format = "jwk";
          }
          if (options === void 0) {
            options = {};
          }
          return __awaiter(this, void 0, void 0, function() {
            var jwkey;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (this._isEncrypted && this._type === "private") {
                    if ((format === "der" || format === "pem") && Object.keys(options).length === 0 && this._current.der) {
                      return [2, format === "pem" ? js_encoding_utils_1.default.formatter.binToPem(this._der, "encryptedPrivate") : this._der];
                    } else
                      throw new Error("DecryptionRequired");
                  }
                  if (!this._current.jwk)
                    return [3, 1];
                  jwkey = this._jwk;
                  return [3, 6];
                case 1:
                  if (!this._current.oct)
                    return [3, 3];
                  return [4, (0, converter_1.toJwkFrom)("oct", this._oct.key, { namedCurve: this._oct.namedCurve })];
                case 2:
                  jwkey = _a.sent();
                  return [3, 6];
                case 3:
                  if (!this._current.der)
                    return [3, 5];
                  return [4, (0, converter_1.toJwkFrom)("der", this._der)];
                case 4:
                  jwkey = _a.sent();
                  return [3, 6];
                case 5:
                  throw new Error("InvalidStatus");
                case 6:
                  this._setJwk(jwkey);
                  if (!(format === "der" || format === "pem"))
                    return [3, 8];
                  return [4, (0, converter_1.fromJwkTo)(format, jwkey, {
                    outputPublic: options.outputPublic,
                    compact: options.compact,
                    //passphrase: options.encryptParams.passphrase,
                    encryptParams: options.encryptParams
                  })];
                case 7:
                  return [2, _a.sent()];
                case 8:
                  if (!(format === "oct"))
                    return [3, 10];
                  return [4, (0, converter_1.fromJwkTo)(format, jwkey, {
                    outputPublic: options.outputPublic,
                    output: options.output,
                    compact: options.compact
                  })];
                case 9:
                  return [2, _a.sent()];
                case 10:
                  return [2, jwkey];
              }
            });
          });
        };
        Key2.prototype.encrypt = function(passphrase) {
          return __awaiter(this, void 0, void 0, function() {
            var options, _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this._isEncrypted)
                    throw new Error("AlreadyEncrypted");
                  options = { encryptParams: { passphrase } };
                  _a = this._setAsn1;
                  return [4, this.export("der", options)];
                case 1:
                  _a.apply(this, [_b.sent(), "der"]);
                  return [2, true];
              }
            });
          });
        };
        Key2.prototype.decrypt = function(passphrase) {
          return __awaiter(this, void 0, void 0, function() {
            var jwkey;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  if (!this._isEncrypted)
                    throw new Error("NotEncrypted");
                  if (!this._current.der)
                    return [3, 2];
                  return [4, (0, converter_1.toJwkFrom)("der", this._der, { passphrase })];
                case 1:
                  jwkey = _a.sent();
                  return [3, 3];
                case 2:
                  throw new Error("FailedToDecrypt");
                case 3:
                  this._setJwk(jwkey);
                  return [2, true];
              }
            });
          });
        };
        Key2.prototype.getJwkThumbprint = function(alg, output) {
          if (alg === void 0) {
            alg = "SHA-256";
          }
          if (output === void 0) {
            output = "binary";
          }
          return __awaiter(this, void 0, void 0, function() {
            var _a;
            return __generator(this, function(_b) {
              switch (_b.label) {
                case 0:
                  if (this._isEncrypted)
                    throw new Error("DecryptionRequired");
                  _a = thumbprint_1.getJwkThumbprint;
                  return [4, this.export("jwk")];
                case 1:
                  return [4, _a.apply(void 0, [_b.sent(), alg, output])];
                case 2:
                  return [2, _b.sent()];
              }
            });
          });
        };
        Object.defineProperty(Key2.prototype, "keyType", {
          // getters
          /**
           * Get keyType in JWK format
           * @return {Promise<String>} - 'RSA' or 'EC'
           * @throws {Error} - Throws if DecryptionRequired.
           */
          get: function() {
            var _this = this;
            if (this._isEncrypted)
              throw new Error("DecryptionRequired");
            return new Promise(function(resolve, reject) {
              _this.export("jwk").then(function(r) {
                resolve(r.kty);
              }).catch(function(e) {
                reject(e);
              });
            });
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "jwkThumbprint", {
          /**
           * Get jwkThumbprint of this key.
           * @return {Promise<Uint8Array>} - Returns binary thumbprint.
           */
          get: function() {
            return this.getJwkThumbprint();
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "isEncrypted", {
          /**
           * Check if this is encrypted.
           * @return {boolean}
           */
          get: function() {
            return this._isEncrypted;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "isPrivate", {
          /**
           * Check if this is a private key.
           * @return {boolean}
           */
          get: function() {
            return this._type === "private";
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "der", {
          /**
           * Returns the key in DER format.
           * @return {Promise<DER>}
           */
          get: function() {
            return this.export("der");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "pem", {
          /**
           * Returns the key in PEM format.
           * @return {Promise<PEM>}
           */
          get: function() {
            return this.export("pem");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "jwk", {
          /**
           * Returns the key in JWK format
           * @return {Promise<JsonWebKey>}
           */
          get: function() {
            return this.export("jwk");
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Key2.prototype, "oct", {
          /**
           * Returns the 'EC' key in Octet SEC1 format.
           * @return {Promise<OctetEC>}
           */
          get: function() {
            return this.export("oct", { output: "string" });
          },
          enumerable: false,
          configurable: true
        });
        return Key2;
      }()
    );
    exports.Key = Key;
  }
});

// node_modules/js-crypto-key-utils/dist/index.js
var require_dist7 = __commonJS({
  "node_modules/js-crypto-key-utils/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Key = void 0;
    var key = __importStar(require_key3());
    exports.Key = key.Key;
    exports.default = { Key: exports.Key };
  }
});

// node_modules/crypto-js/core.js
var require_core = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof __require === "function") {
          try {
            crypto2 = require_crypto();
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder2) {
            return (encoder2 || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/x64-core.js
var require_x64_core = __commonJS({
  "node_modules/crypto-js/x64-core.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        var X64Word = C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        var X64WordArray = C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone = Base.clone.call(this);
            var words = clone.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone;
          }
        });
      })();
      return CryptoJS2;
    });
  }
});

// node_modules/crypto-js/lib-typedarrays.js
var require_lib_typedarrays = __commonJS({
  "node_modules/crypto-js/lib-typedarrays.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  }
});

// node_modules/crypto-js/enc-utf16.js
var require_enc_utf16 = __commonJS({
  "node_modules/crypto-js/enc-utf16.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  }
});

// node_modules/crypto-js/enc-base64.js
var require_enc_base64 = __commonJS({
  "node_modules/crypto-js/enc-base64.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64 = C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  }
});

// node_modules/crypto-js/enc-base64url.js
var require_enc_base64url = __commonJS({
  "node_modules/crypto-js/enc-base64url.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        var Base64url = C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 63));
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j = 0; j < map.length; j++) {
                reverseMap[map.charCodeAt(j)] = j;
              }
            }
            var paddingChar = map.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  }
});

// node_modules/crypto-js/md5.js
var require_md52 = __commonJS({
  "node_modules/crypto-js/md5.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M[offset + 0];
            var M_offset_1 = M[offset + 1];
            var M_offset_2 = M[offset + 2];
            var M_offset_3 = M[offset + 3];
            var M_offset_4 = M[offset + 4];
            var M_offset_5 = M[offset + 5];
            var M_offset_6 = M[offset + 6];
            var M_offset_7 = M[offset + 7];
            var M_offset_8 = M[offset + 8];
            var M_offset_9 = M[offset + 9];
            var M_offset_10 = M[offset + 10];
            var M_offset_11 = M[offset + 11];
            var M_offset_12 = M[offset + 12];
            var M_offset_13 = M[offset + 13];
            var M_offset_14 = M[offset + 14];
            var M_offset_15 = M[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            a = FF(a, b, c, d, M_offset_0, 7, T[0]);
            d = FF(d, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d, M_offset_4, 7, T[4]);
            d = FF(d, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d, M_offset_8, 7, T[8]);
            d = FF(d, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d, M_offset_12, 7, T[12]);
            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d, M_offset_1, 5, T[16]);
            d = GG(d, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d, M_offset_5, 5, T[20]);
            d = GG(d, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d, M_offset_9, 5, T[24]);
            d = GG(d, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d, M_offset_13, 5, T[28]);
            d = GG(d, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d, M_offset_5, 4, T[32]);
            d = HH(d, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d, M_offset_1, 4, T[36]);
            d = HH(d, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d, M_offset_13, 4, T[40]);
            d = HH(d, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d, M_offset_9, 4, T[44]);
            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d, M_offset_0, 6, T[48]);
            d = II(d, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d, M_offset_12, 6, T[52]);
            d = II(d, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d, M_offset_8, 6, T[56]);
            d = II(d, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d, M_offset_4, 6, T[60]);
            d = II(d, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function FF(a, b, c, d, x, s, t) {
          var n = a + (b & c | ~b & d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function GG(a, b, c, d, x, s, t) {
          var n = a + (b & d | c & ~d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function HH(a, b, c, d, x, s, t) {
          var n = a + (b ^ c ^ d) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        function II(a, b, c, d, x, s, t) {
          var n = a + (c ^ (b | ~d)) + x + t;
          return (n << s | n >>> 32 - s) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS2.MD5;
    });
  }
});

// node_modules/crypto-js/sha1.js
var require_sha1 = __commonJS({
  "node_modules/crypto-js/sha1.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t += (b & c | ~b & d) + 1518500249;
              } else if (i < 40) {
                t += (b ^ c ^ d) + 1859775393;
              } else if (i < 60) {
                t += (b & c | b & d | c & d) - 1894007588;
              } else {
                t += (b ^ c ^ d) - 899497514;
              }
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f2 = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f2 ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f2;
              f2 = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f2 | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  }
});

// node_modules/crypto-js/sha224.js
var require_sha224 = __commonJS({
  "node_modules/crypto-js/sha224.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash = SHA256._doFinalize.call(this);
            hash.sigBytes -= 4;
            return hash;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  }
});

// node_modules/crypto-js/sha512.js
var require_sha512 = __commonJS({
  "node_modules/crypto-js/sha512.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M, offset) {
            var H = this._hash.words;
            var H0 = H[0];
            var H1 = H[1];
            var H2 = H[2];
            var H3 = H[3];
            var H4 = H[4];
            var H5 = H[5];
            var H6 = H[6];
            var H7 = H[7];
            var H0h = H0.high;
            var H0l = H0.low;
            var H1h = H1.high;
            var H1l = H1.low;
            var H2h = H2.high;
            var H2l = H2.low;
            var H3h = H3.high;
            var H3l = H3.low;
            var H4h = H4.high;
            var H4l = H4.low;
            var H5h = H5.high;
            var H5l = H5.low;
            var H6h = H6.high;
            var H6l = H6.low;
            var H7h = H7.high;
            var H7l = H7.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi = W[i];
              if (i < 16) {
                Wih = Wi.high = M[offset + i * 2] | 0;
                Wil = Wi.low = M[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H0.low = H0l + al;
            H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H1.low = H1l + bl;
            H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H2.low = H2l + cl;
            H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H3.low = H3l + dl;
            H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H4.low = H4l + el;
            H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H5.low = H5l + fl;
            H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H6.low = H6l + gl;
            H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H7.low = H7l + hl;
            H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var hash = this._hash.toX32();
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  }
});

// node_modules/crypto-js/sha384.js
var require_sha384 = __commonJS({
  "node_modules/crypto-js/sha384.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_sha512());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./sha512"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash = SHA512._doFinalize.call(this);
            hash.sigBytes -= 16;
            return hash;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  }
});

// node_modules/crypto-js/sha3.js
var require_sha32 = __commonJS({
  "node_modules/crypto-js/sha3.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y = 0;
          for (var t = 0; t < 24; t++) {
            RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
            var newX = y % 5;
            var newY = (2 * x + 3 * y) % 5;
            x = newX;
            y = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y = 0; y < 5; y++) {
              PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j = 0; j < 7; j++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state = this._state = [];
            for (var i = 0; i < 25; i++) {
              state[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M, offset) {
            var state = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M[offset + 2 * i];
              var M2i1 = M[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y = 0; y < 5; y++) {
                  var lane = state[x + 5 * y];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  var laneIndex = x + 5 * y;
                  var lane = state[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data.sigBytes = dataWords.length * 4;
            this._process();
            var state = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            var state = clone._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state[i] = state[i].clone();
            }
            return clone;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  }
});

// node_modules/crypto-js/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/crypto-js/ripemd160.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M[offset_i];
              M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t;
            for (var i = 0; i < 80; i += 1) {
              t = al + M[offset + zl[i]] | 0;
              if (i < 16) {
                t += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t += f4(bl, cl, dl) + hl[3];
              } else {
                t += f5(bl, cl, dl) + hl[4];
              }
              t = t | 0;
              t = rotl(t, sl[i]);
              t = t + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t;
              t = ar + M[offset + zr[i]] | 0;
              if (i < 16) {
                t += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t += f2(br, cr, dr) + hr[3];
              } else {
                t += f1(br, cr, dr) + hr[4];
              }
              t = t | 0;
              t = rotl(t, sr[i]);
              t = t + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t;
            }
            t = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash = this._hash;
            var H = hash.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        function f1(x, y, z) {
          return x ^ y ^ z;
        }
        function f2(x, y, z) {
          return x & y | ~x & z;
        }
        function f3(x, y, z) {
          return (x | ~y) ^ z;
        }
        function f4(x, y, z) {
          return x & z | y & ~z;
        }
        function f5(x, y, z) {
          return x ^ (y | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })(Math);
      return CryptoJS2.RIPEMD160;
    });
  }
});

// node_modules/crypto-js/hmac.js
var require_hmac3 = __commonJS({
  "node_modules/crypto-js/hmac.js"(exports, module) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        var HMAC = C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac;
          }
        });
      })();
    });
  }
});

// node_modules/crypto-js/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/crypto-js/pbkdf2.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha256(), require_hmac3());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha256", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac.update(salt).finalize(blockIndex);
              hmac.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac.finalize(intermediate);
                hmac.reset();
                var intermediateWords = intermediate.words;
                for (var j = 0; j < blockWordsLength; j++) {
                  blockWords[j] ^= intermediateWords[j];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  }
});

// node_modules/crypto-js/evpkdf.js
var require_evpkdf = __commonJS({
  "node_modules/crypto-js/evpkdf.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_sha1(), require_hmac3());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./sha1", "./hmac"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  }
});

// node_modules/crypto-js/cipher-core.js
var require_cipher_core = __commonJS({
  "node_modules/crypto-js/cipher-core.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_evpkdf());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./evpkdf"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        var StreamCipher = C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv) {
            return this.Encryptor.create(cipher, iv);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv) {
            return this.Decryptor.create(cipher, iv);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv) {
            this._cipher = cipher;
            this._iv = iv;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv = this._iv;
            if (iv) {
              block = iv;
              this._iv = undefined2;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data) {
            var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
            data.sigBytes -= nPaddingBytes;
          }
        };
        var BlockCipher = C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv && iv.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv && iv.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format) {
            if (typeof ciphertext == "string") {
              return format.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  }
});

// node_modules/crypto-js/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/crypto-js/mode-cfb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv = this._iv;
          if (iv) {
            keystream = iv.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  }
});

// node_modules/crypto-js/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/crypto-js/mode-ctr.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  }
});

// node_modules/crypto-js/mode-ctr-gladman.js
var require_mode_ctr_gladman = __commonJS({
  "node_modules/crypto-js/mode-ctr-gladman.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var counter = this._counter;
            if (iv) {
              counter = this._counter = iv.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  }
});

// node_modules/crypto-js/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/crypto-js/mode-ofb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv = this._iv;
            var keystream = this._keystream;
            if (iv) {
              keystream = this._keystream = iv.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  }
});

// node_modules/crypto-js/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/crypto-js/mode-ecb.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  }
});

// node_modules/crypto-js/pad-ansix923.js
var require_pad_ansix923 = __commonJS({
  "node_modules/crypto-js/pad-ansix923.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data, blockSize) {
          var dataSigBytes = data.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data.clamp();
          data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data.sigBytes += nPaddingBytes;
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  }
});

// node_modules/crypto-js/pad-iso10126.js
var require_pad_iso10126 = __commonJS({
  "node_modules/crypto-js/pad-iso10126.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;
          data.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data) {
          var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 255;
          data.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  }
});

// node_modules/crypto-js/pad-iso97971.js
var require_pad_iso97971 = __commonJS({
  "node_modules/crypto-js/pad-iso97971.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data, blockSize) {
          data.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data, blockSize);
        },
        unpad: function(data) {
          CryptoJS2.pad.ZeroPadding.unpad(data);
          data.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  }
});

// node_modules/crypto-js/pad-zeropadding.js
var require_pad_zeropadding = __commonJS({
  "node_modules/crypto-js/pad-zeropadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data.clamp();
          data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data) {
          var dataWords = data.words;
          var i = data.sigBytes - 1;
          for (var i = data.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  }
});

// node_modules/crypto-js/pad-nopadding.js
var require_pad_nopadding = __commonJS({
  "node_modules/crypto-js/pad-nopadding.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  }
});

// node_modules/crypto-js/format-hex.js
var require_format_hex = __commonJS({
  "node_modules/crypto-js/format-hex.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function(undefined2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        var HexFormatter = C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  }
});

// node_modules/crypto-js/aes.js
var require_aes2 = __commonJS({
  "node_modules/crypto-js/aes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d[i] = i << 1;
            } else {
              d[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d[x];
            var x4 = d[x2];
            var x8 = d[x4];
            var t = d[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t << 24 | t >>> 8;
            SUB_MIX_1[x] = t << 16 | t >>> 16;
            SUB_MIX_2[x] = t << 8 | t >>> 24;
            SUB_MIX_3[x] = t;
            var t = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
            INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
            INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
            INV_SUB_MIX_3[sx] = t;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d[d[d[x8 ^ x2]]];
              xi ^= d[d[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher.extend({
          _doReset: function() {
            var t;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t = t << 8 | t >>> 24;
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                  t ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 255] << 16 | SBOX[t >>> 8 & 255] << 8 | SBOX[t & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t = keySchedule[ksRow];
              } else {
                var t = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t & 255]];
              }
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M, offset) {
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t = M[offset + 1];
            M[offset + 1] = M[offset + 3];
            M[offset + 3] = t;
          },
          _doCryptBlock: function(M, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M[offset] ^ keySchedule[0];
            var s1 = M[offset + 1] ^ keySchedule[1];
            var s2 = M[offset + 2] ^ keySchedule[2];
            var s3 = M[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M[offset] = t0;
            M[offset + 1] = t1;
            M[offset + 2] = t2;
            M[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  }
});

// node_modules/crypto-js/tripledes.js
var require_tripledes = __commonJS({
  "node_modules/crypto-js/tripledes.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._subKeys);
          },
          decryptBlock: function(M, offset) {
            this._doCryptBlock(M, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M, offset, subKeys) {
            this._lBlock = M[offset];
            this._rBlock = M[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f2 = 0;
              for (var i = 0; i < 8; i++) {
                f2 |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f2;
            }
            var t = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M[offset] = this._lBlock;
            M[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t;
          this._lBlock ^= t << offset;
        }
        function exchangeRL(offset, mask) {
          var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t;
          this._rBlock ^= t << offset;
        }
        C.DES = BlockCipher._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M, offset) {
            this._des1.encryptBlock(M, offset);
            this._des2.decryptBlock(M, offset);
            this._des3.encryptBlock(M, offset);
          },
          decryptBlock: function(M, offset) {
            this._des3.decryptBlock(M, offset);
            this._des2.encryptBlock(M, offset);
            this._des1.decryptBlock(M, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  }
});

// node_modules/crypto-js/rc4.js
var require_rc4 = __commonJS({
  "node_modules/crypto-js/rc4.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S = this._S = [];
            for (var i = 0; i < 256; i++) {
              S[i] = i;
            }
            for (var i = 0, j = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j = (j + S[i] + keyByte) % 256;
              var t = S[i];
              S[i] = S[j];
              S[j] = t;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M, offset) {
            M[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S = this._S;
          var i = this._i;
          var j = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j = (j + S[i]) % 256;
            var t = S[i];
            S[i] = S[j];
            S[j] = t;
            keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  }
});

// node_modules/crypto-js/rabbit.js
var require_rabbit = __commonJS({
  "node_modules/crypto-js/rabbit.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  }
});

// node_modules/crypto-js/rabbit-legacy.js
var require_rabbit_legacy = __commonJS({
  "node_modules/crypto-js/rabbit-legacy.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv = this.cfg.iv;
            var X = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X[i + 4 & 7];
            }
            if (iv) {
              var IV = iv.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M, offset) {
            var X = this._X;
            nextState.call(this);
            S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
            S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
            S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
            S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
            for (var i = 0; i < 4; i++) {
              S[i] = (S[i] << 8 | S[i] >>> 24) & 16711935 | (S[i] << 24 | S[i] >>> 8) & 4278255360;
              M[offset + i] ^= S[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  }
});

// node_modules/crypto-js/blowfish.js
var require_blowfish = __commonJS({
  "node_modules/crypto-js/blowfish.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_enc_base64(), require_md52(), require_evpkdf(), require_cipher_core());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./enc-base64", "./md5", "./evpkdf", "./cipher-core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a = x >> 24 & 255;
          let b = x >> 16 & 255;
          let c = x >> 8 & 255;
          let d = x & 255;
          let y = ctx.sbox[0][a] + ctx.sbox[1][b];
          y = y ^ ctx.sbox[2][c];
          y = y + ctx.sbox[3][d];
          return y;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = 0; i < N; ++i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = N + 1; i > 1; --i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index = 0; index < N + 2; index++) {
            ctx.pbox[index] = ORIG_P[index] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res = 0;
          for (let i = 0; i < N + 2; i += 2) {
            res = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res.left;
            Data2 = res.right;
            ctx.pbox[i] = Data1;
            ctx.pbox[i + 1] = Data2;
          }
          for (let i = 0; i < 4; i++) {
            for (let j = 0; j < 256; j += 2) {
              res = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res.left;
              Data2 = res.right;
              ctx.sbox[i][j] = Data1;
              ctx.sbox[i][j + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M, offset) {
            var res = BlowFish_Encrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          decryptBlock: function(M, offset) {
            var res = BlowFish_Decrypt(BLOWFISH_CTX, M[offset], M[offset + 1]);
            M[offset] = res.left;
            M[offset + 1] = res.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  }
});

// node_modules/crypto-js/index.js
var require_crypto_js = __commonJS({
  "node_modules/crypto-js/index.js"(exports, module) {
    (function(root, factory, undef) {
      if (typeof exports === "object") {
        module.exports = exports = factory(require_core(), require_x64_core(), require_lib_typedarrays(), require_enc_utf16(), require_enc_base64(), require_enc_base64url(), require_md52(), require_sha1(), require_sha256(), require_sha224(), require_sha512(), require_sha384(), require_sha32(), require_ripemd160(), require_hmac3(), require_pbkdf2(), require_evpkdf(), require_cipher_core(), require_mode_cfb(), require_mode_ctr(), require_mode_ctr_gladman(), require_mode_ofb(), require_mode_ecb(), require_pad_ansix923(), require_pad_iso10126(), require_pad_iso97971(), require_pad_zeropadding(), require_pad_nopadding(), require_format_hex(), require_aes2(), require_tripledes(), require_rc4(), require_rabbit(), require_rabbit_legacy(), require_blowfish());
      } else if (typeof define === "function" && define.amd) {
        define(["./core", "./x64-core", "./lib-typedarrays", "./enc-utf16", "./enc-base64", "./enc-base64url", "./md5", "./sha1", "./sha256", "./sha224", "./sha512", "./sha384", "./sha3", "./ripemd160", "./hmac", "./pbkdf2", "./evpkdf", "./cipher-core", "./mode-cfb", "./mode-ctr", "./mode-ctr-gladman", "./mode-ofb", "./mode-ecb", "./pad-ansix923", "./pad-iso10126", "./pad-iso97971", "./pad-zeropadding", "./pad-nopadding", "./format-hex", "./aes", "./tripledes", "./rc4", "./rabbit", "./rabbit-legacy", "./blowfish"], factory);
      } else {
        root.CryptoJS = factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS2) {
      return CryptoJS2;
    });
  }
});

// node_modules/parseuri/index.js
var require_parseuri = __commonJS({
  "node_modules/parseuri/index.js"(exports, module) {
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
    module.exports = function parseuri(str) {
      var src = str, b = str.indexOf("["), e = str.indexOf("]");
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
      }
      var m = re.exec(str || ""), uri = {}, i = 14;
      while (i--) {
        uri[parts[i]] = m[i] || "";
      }
      if (b != -1 && e != -1) {
        uri.source = src;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
      }
      uri.pathNames = pathNames(uri, uri["path"]);
      uri.queryKey = queryKey(uri, uri["query"]);
      return uri;
    };
    function pathNames(obj, path) {
      var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
      if (path.substr(0, 1) == "/" || path.length === 0) {
        names.splice(0, 1);
      }
      if (path.substr(path.length - 1, 1) == "/") {
        names.splice(names.length - 1, 1);
      }
      return names;
    }
    function queryKey(uri, query) {
      var data = {};
      query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
        if ($1) {
          data[$1] = $2;
        }
      });
      return data;
    }
  }
});

// node_modules/@filen/sdk/node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/@filen/sdk/node_modules/ms/index.js"(exports, module) {
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var y = d * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isNaN(val) === false) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      if (ms >= d) {
        return Math.round(ms / d) + "d";
      }
      if (ms >= h) {
        return Math.round(ms / h) + "h";
      }
      if (ms >= m) {
        return Math.round(ms / m) + "m";
      }
      if (ms >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      return plural(ms, d, "day") || plural(ms, h, "hour") || plural(ms, m, "minute") || plural(ms, s, "second") || ms + " ms";
    }
    function plural(ms, n, name) {
      if (ms < n) {
        return;
      }
      if (ms < n * 1.5) {
        return Math.floor(ms / n) + " " + name;
      }
      return Math.ceil(ms / n) + " " + name + "s";
    }
  }
});

// node_modules/@filen/sdk/node_modules/debug/src/debug.js
var require_debug = __commonJS({
  "node_modules/@filen/sdk/node_modules/debug/src/debug.js"(exports, module) {
    exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = require_ms();
    exports.instances = [];
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    function selectColor(namespace) {
      var hash = 0, i;
      for (i in namespace) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return exports.colors[Math.abs(hash) % exports.colors.length];
    }
    function createDebug(namespace) {
      var prevTime;
      function debug() {
        if (!debug.enabled)
          return;
        var self2 = debug;
        var curr = +/* @__PURE__ */ new Date();
        var ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {
          if (match === "%%")
            return match;
          index++;
          var formatter = exports.formatters[format];
          if ("function" === typeof formatter) {
            var val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        exports.formatArgs.call(self2, args);
        var logFn = debug.log || exports.log || console.log.bind(console);
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.enabled = exports.enabled(namespace);
      debug.useColors = exports.useColors();
      debug.color = selectColor(namespace);
      debug.destroy = destroy;
      if ("function" === typeof exports.init) {
        exports.init(debug);
      }
      exports.instances.push(debug);
      return debug;
    }
    function destroy() {
      var index = exports.instances.indexOf(this);
      if (index !== -1) {
        exports.instances.splice(index, 1);
        return true;
      } else {
        return false;
      }
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var i;
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i])
          continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < exports.instances.length; i++) {
        var instance = exports.instances[i];
        instance.enabled = exports.enabled(instance.namespace);
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function coerce(val) {
      if (val instanceof Error)
        return val.stack || val.message;
      return val;
    }
  }
});

// node_modules/@filen/sdk/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/@filen/sdk/node_modules/debug/src/browser.js"(exports, module) {
    exports = module.exports = require_debug();
    exports.log = log;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2)
        return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match) {
        if ("%%" === match)
          return;
        index++;
        if ("%c" === match) {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-client/lib/url.js
var require_url2 = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-client/lib/url.js"(exports, module) {
    var parseuri = require_parseuri();
    var debug = require_browser3()("socket.io-client:url");
    module.exports = url;
    function url(uri, loc) {
      var obj = uri;
      loc = loc || typeof location !== "undefined" && location;
      if (null == uri)
        uri = loc.protocol + "//" + loc.host;
      if ("string" === typeof uri) {
        if ("/" === uri.charAt(0)) {
          if ("/" === uri.charAt(1)) {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug("protocol-less url %s", uri);
          if ("undefined" !== typeof loc) {
            uri = loc.protocol + "//" + uri;
          } else {
            uri = "https://" + uri;
          }
        }
        debug("parse %s", uri);
        obj = parseuri(uri);
      }
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = "80";
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = "443";
        }
      }
      obj.path = obj.path || "/";
      var ipv6 = obj.host.indexOf(":") !== -1;
      var host = ipv6 ? "[" + obj.host + "]" : obj.host;
      obj.id = obj.protocol + "://" + host + ":" + obj.port;
      obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
      return obj;
    }
  }
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/component-emitter/index.js"(exports, module) {
    if (typeof module !== "undefined") {
      module.exports = Emitter;
    }
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/@filen/sdk/node_modules/isarray/index.js
var require_isarray2 = __commonJS({
  "node_modules/@filen/sdk/node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-parser/is-buffer.js
var require_is_buffer2 = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-parser/is-buffer.js"(exports, module) {
    module.exports = isBuf;
    var withNativeBuffer = typeof Buffer === "function" && typeof Buffer.isBuffer === "function";
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = function(obj) {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    function isBuf(obj) {
      return withNativeBuffer && Buffer.isBuffer(obj) || withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj));
    }
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-parser/binary.js
var require_binary = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-parser/binary.js"(exports) {
    var isArray = require_isarray2();
    var isBuf = require_is_buffer2();
    var toString = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
    exports.deconstructPacket = function(packet) {
      var buffers = [];
      var packetData = packet.data;
      var pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length;
      return { packet: pack, buffers };
    };
    function _deconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (isBuf(data)) {
        var placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (isArray(data)) {
        var newData = new Array(data.length);
        for (var i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === "object" && !(data instanceof Date)) {
        var newData = {};
        for (var key in data) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
        return newData;
      }
      return data;
    }
    exports.reconstructPacket = function(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = void 0;
      return packet;
    };
    function _reconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (data && data._placeholder === true) {
        var isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
        if (isIndexValid) {
          return buffers[data.num];
        } else {
          throw new Error("illegal attachments");
        }
      } else if (isArray(data)) {
        for (var i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === "object") {
        for (var key in data) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
      return data;
    }
    exports.removeBlobs = function(data, callback) {
      function _removeBlobs(obj, curKey, containingObject) {
        if (!obj)
          return obj;
        if (withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
          pendingBlobs++;
          var fileReader = new FileReader();
          fileReader.onload = function() {
            if (containingObject) {
              containingObject[curKey] = this.result;
            } else {
              bloblessData = this.result;
            }
            if (!--pendingBlobs) {
              callback(bloblessData);
            }
          };
          fileReader.readAsArrayBuffer(obj);
        } else if (isArray(obj)) {
          for (var i = 0; i < obj.length; i++) {
            _removeBlobs(obj[i], i, obj);
          }
        } else if (typeof obj === "object" && !isBuf(obj)) {
          for (var key in obj) {
            _removeBlobs(obj[key], key, obj);
          }
        }
      }
      var pendingBlobs = 0;
      var bloblessData = data;
      _removeBlobs(bloblessData);
      if (!pendingBlobs) {
        callback(bloblessData);
      }
    };
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-parser/index.js
var require_socket = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-parser/index.js"(exports) {
    var debug = require_browser3()("socket.io-parser");
    var Emitter = require_component_emitter();
    var binary = require_binary();
    var isArray = require_isarray2();
    var isBuf = require_is_buffer2();
    exports.protocol = 4;
    exports.types = [
      "CONNECT",
      "DISCONNECT",
      "EVENT",
      "ACK",
      "ERROR",
      "BINARY_EVENT",
      "BINARY_ACK"
    ];
    exports.CONNECT = 0;
    exports.DISCONNECT = 1;
    exports.EVENT = 2;
    exports.ACK = 3;
    exports.ERROR = 4;
    exports.BINARY_EVENT = 5;
    exports.BINARY_ACK = 6;
    exports.Encoder = Encoder;
    exports.Decoder = Decoder;
    function Encoder() {
    }
    var ERROR_PACKET = exports.ERROR + '"encode error"';
    Encoder.prototype.encode = function(obj, callback) {
      debug("encoding packet %j", obj);
      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
        encodeAsBinary(obj, callback);
      } else {
        var encoding = encodeAsString(obj);
        callback([encoding]);
      }
    };
    function encodeAsString(obj) {
      var str = "" + obj.type;
      if (exports.BINARY_EVENT === obj.type || exports.BINARY_ACK === obj.type) {
        str += obj.attachments + "-";
      }
      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      }
      if (null != obj.id) {
        str += obj.id;
      }
      if (null != obj.data) {
        var payload = tryStringify(obj.data);
        if (payload !== false) {
          str += payload;
        } else {
          return ERROR_PACKET;
        }
      }
      debug("encoded %j as %s", obj, str);
      return str;
    }
    function tryStringify(str) {
      try {
        return JSON.stringify(str);
      } catch (e) {
        return false;
      }
    }
    function encodeAsBinary(obj, callback) {
      function writeEncoding(bloblessData) {
        var deconstruction = binary.deconstructPacket(bloblessData);
        var pack = encodeAsString(deconstruction.packet);
        var buffers = deconstruction.buffers;
        buffers.unshift(pack);
        callback(buffers);
      }
      binary.removeBlobs(obj, writeEncoding);
    }
    function Decoder() {
      this.reconstructor = null;
    }
    Emitter(Decoder.prototype);
    Decoder.prototype.add = function(obj) {
      var packet;
      if (typeof obj === "string") {
        if (this.reconstructor) {
          throw new Error("got plaintext data when reconstructing a packet");
        }
        packet = decodeString(obj);
        if (exports.BINARY_EVENT === packet.type || exports.BINARY_ACK === packet.type) {
          this.reconstructor = new BinaryReconstructor(packet);
          if (this.reconstructor.reconPack.attachments === 0) {
            this.emit("decoded", packet);
          }
        } else {
          this.emit("decoded", packet);
        }
      } else if (isBuf(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            this.emit("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    };
    function isPayloadValid(type, payload) {
      switch (type) {
        case 0:
          return typeof payload === "object";
        case 1:
          return payload === void 0;
        case 4:
          return typeof payload === "string" || typeof payload === "object";
        case 2:
        case 5:
          return isArray(payload) && (typeof payload[0] === "string" || typeof payload[0] === "number");
        case 3:
        case 6:
          return isArray(payload);
      }
    }
    function decodeString(str) {
      var i = 0;
      var p = {
        type: Number(str.charAt(0))
      };
      if (null == exports.types[p.type]) {
        return error("unknown packet type " + p.type);
      }
      if (exports.BINARY_EVENT === p.type || exports.BINARY_ACK === p.type) {
        var start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {
        }
        var buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      if ("/" === str.charAt(i + 1)) {
        var start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if ("," === c)
            break;
          if (i === str.length)
            break;
        }
        p.nsp = str.substring(start, i);
      } else {
        p.nsp = "/";
      }
      var next = str.charAt(i + 1);
      if ("" !== next && Number(next) == next) {
        var start = i + 1;
        while (++i) {
          var c = str.charAt(i);
          if (null == c || Number(c) != c) {
            --i;
            break;
          }
          if (i === str.length)
            break;
        }
        p.id = Number(str.substring(start, i + 1));
      }
      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));
        if (isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug("decoded %s as %j", str, p);
      return p;
    }
    function tryParse(str) {
      try {
        return JSON.parse(str);
      } catch (e) {
        return false;
      }
    }
    Decoder.prototype.destroy = function() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    };
    function BinaryReconstructor(packet) {
      this.reconPack = packet;
      this.buffers = [];
    }
    BinaryReconstructor.prototype.takeBinaryData = function(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        var packet = binary.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    };
    BinaryReconstructor.prototype.finishedReconstruction = function() {
      this.reconPack = null;
      this.buffers = [];
    };
    function error(msg) {
      return {
        type: exports.ERROR,
        data: "parser error: " + msg
      };
    }
  }
});

// node_modules/has-cors/index.js
var require_has_cors = __commonJS({
  "node_modules/has-cors/index.js"(exports, module) {
    try {
      module.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
      module.exports = false;
    }
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/globalThis.browser.js
var require_globalThis_browser = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/globalThis.browser.js"(exports, module) {
    module.exports = function() {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    }();
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/xmlhttprequest.browser.js
var require_xmlhttprequest_browser = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/xmlhttprequest.browser.js"(exports, module) {
    var hasCORS = require_has_cors();
    var globalThis2 = require_globalThis_browser();
    module.exports = function(opts) {
      var xdomain = opts.xdomain;
      var xscheme = opts.xscheme;
      var enablesXDR = opts.enablesXDR;
      try {
        if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
          return new XMLHttpRequest();
        }
      } catch (e) {
      }
      try {
        if ("undefined" !== typeof XDomainRequest && !xscheme && enablesXDR) {
          return new XDomainRequest();
        }
      } catch (e) {
      }
      if (!xdomain) {
        try {
          return new globalThis2[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e) {
        }
      }
    };
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-parser/lib/keys.js
var require_keys = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-parser/lib/keys.js"(exports, module) {
    module.exports = Object.keys || function keys(obj) {
      var arr = [];
      var has = Object.prototype.hasOwnProperty;
      for (var i in obj) {
        if (has.call(obj, i)) {
          arr.push(i);
        }
      }
      return arr;
    };
  }
});

// node_modules/has-binary2/node_modules/isarray/index.js
var require_isarray3 = __commonJS({
  "node_modules/has-binary2/node_modules/isarray/index.js"(exports, module) {
    var toString = {}.toString;
    module.exports = Array.isArray || function(arr) {
      return toString.call(arr) == "[object Array]";
    };
  }
});

// node_modules/has-binary2/index.js
var require_has_binary2 = __commonJS({
  "node_modules/has-binary2/index.js"(exports, module) {
    var isArray = require_isarray3();
    var toString = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
    module.exports = hasBinary;
    function hasBinary(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }
      if (typeof Buffer === "function" && Buffer.isBuffer && Buffer.isBuffer(obj) || typeof ArrayBuffer === "function" && obj instanceof ArrayBuffer || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
  }
});

// node_modules/arraybuffer.slice/index.js
var require_arraybuffer = __commonJS({
  "node_modules/arraybuffer.slice/index.js"(exports, module) {
    module.exports = function(arraybuffer, start, end) {
      var bytes = arraybuffer.byteLength;
      start = start || 0;
      end = end || bytes;
      if (arraybuffer.slice) {
        return arraybuffer.slice(start, end);
      }
      if (start < 0) {
        start += bytes;
      }
      if (end < 0) {
        end += bytes;
      }
      if (end > bytes) {
        end = bytes;
      }
      if (start >= bytes || start >= end || bytes === 0) {
        return new ArrayBuffer(0);
      }
      var abv = new Uint8Array(arraybuffer);
      var result = new Uint8Array(end - start);
      for (var i = start, ii = 0; i < end; i++, ii++) {
        result[ii] = abv[i];
      }
      return result.buffer;
    };
  }
});

// node_modules/after/index.js
var require_after = __commonJS({
  "node_modules/after/index.js"(exports, module) {
    module.exports = after;
    function after(count, callback, err_cb) {
      var bail = false;
      err_cb = err_cb || noop;
      proxy.count = count;
      return count === 0 ? callback() : proxy;
      function proxy(err, result) {
        if (proxy.count <= 0) {
          throw new Error("after called too many times");
        }
        --proxy.count;
        if (err) {
          bail = true;
          callback(err);
          callback = err_cb;
        } else if (proxy.count === 0 && !bail) {
          callback(null, result);
        }
      }
    }
    function noop() {
    }
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-parser/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-parser/lib/utf8.js"(exports, module) {
    var stringFromCharCode = String.fromCharCode;
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      var value;
      var extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      var length = array.length;
      var index = -1;
      var value;
      var output = "";
      while (++index < length) {
        value = array[index];
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
      }
      return output;
    }
    function checkScalarValue(codePoint, strict) {
      if (codePoint >= 55296 && codePoint <= 57343) {
        if (strict) {
          throw Error(
            "Lone surrogate U+" + codePoint.toString(16).toUpperCase() + " is not a scalar value"
          );
        }
        return false;
      }
      return true;
    }
    function createByte(codePoint, shift) {
      return stringFromCharCode(codePoint >> shift & 63 | 128);
    }
    function encodeCodePoint(codePoint, strict) {
      if ((codePoint & 4294967168) == 0) {
        return stringFromCharCode(codePoint);
      }
      var symbol = "";
      if ((codePoint & 4294965248) == 0) {
        symbol = stringFromCharCode(codePoint >> 6 & 31 | 192);
      } else if ((codePoint & 4294901760) == 0) {
        if (!checkScalarValue(codePoint, strict)) {
          codePoint = 65533;
        }
        symbol = stringFromCharCode(codePoint >> 12 & 15 | 224);
        symbol += createByte(codePoint, 6);
      } else if ((codePoint & 4292870144) == 0) {
        symbol = stringFromCharCode(codePoint >> 18 & 7 | 240);
        symbol += createByte(codePoint, 12);
        symbol += createByte(codePoint, 6);
      }
      symbol += stringFromCharCode(codePoint & 63 | 128);
      return symbol;
    }
    function utf8encode(string, opts) {
      opts = opts || {};
      var strict = false !== opts.strict;
      var codePoints = ucs2decode(string);
      var length = codePoints.length;
      var index = -1;
      var codePoint;
      var byteString = "";
      while (++index < length) {
        codePoint = codePoints[index];
        byteString += encodeCodePoint(codePoint, strict);
      }
      return byteString;
    }
    function readContinuationByte() {
      if (byteIndex >= byteCount) {
        throw Error("Invalid byte index");
      }
      var continuationByte = byteArray[byteIndex] & 255;
      byteIndex++;
      if ((continuationByte & 192) == 128) {
        return continuationByte & 63;
      }
      throw Error("Invalid continuation byte");
    }
    function decodeSymbol(strict) {
      var byte1;
      var byte2;
      var byte3;
      var byte4;
      var codePoint;
      if (byteIndex > byteCount) {
        throw Error("Invalid byte index");
      }
      if (byteIndex == byteCount) {
        return false;
      }
      byte1 = byteArray[byteIndex] & 255;
      byteIndex++;
      if ((byte1 & 128) == 0) {
        return byte1;
      }
      if ((byte1 & 224) == 192) {
        byte2 = readContinuationByte();
        codePoint = (byte1 & 31) << 6 | byte2;
        if (codePoint >= 128) {
          return codePoint;
        } else {
          throw Error("Invalid continuation byte");
        }
      }
      if ((byte1 & 240) == 224) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        codePoint = (byte1 & 15) << 12 | byte2 << 6 | byte3;
        if (codePoint >= 2048) {
          return checkScalarValue(codePoint, strict) ? codePoint : 65533;
        } else {
          throw Error("Invalid continuation byte");
        }
      }
      if ((byte1 & 248) == 240) {
        byte2 = readContinuationByte();
        byte3 = readContinuationByte();
        byte4 = readContinuationByte();
        codePoint = (byte1 & 7) << 18 | byte2 << 12 | byte3 << 6 | byte4;
        if (codePoint >= 65536 && codePoint <= 1114111) {
          return codePoint;
        }
      }
      throw Error("Invalid UTF-8 detected");
    }
    var byteArray;
    var byteCount;
    var byteIndex;
    function utf8decode(byteString, opts) {
      opts = opts || {};
      var strict = false !== opts.strict;
      byteArray = ucs2decode(byteString);
      byteCount = byteArray.length;
      byteIndex = 0;
      var codePoints = [];
      var tmp;
      while ((tmp = decodeSymbol(strict)) !== false) {
        codePoints.push(tmp);
      }
      return ucs2encode(codePoints);
    }
    module.exports = {
      version: "2.1.2",
      encode: utf8encode,
      decode: utf8decode
    };
  }
});

// node_modules/base64-arraybuffer/lib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS({
  "node_modules/base64-arraybuffer/lib/base64-arraybuffer.js"(exports) {
    (function(chars) {
      "use strict";
      exports.encode = function(arraybuffer) {
        var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
        for (i = 0; i < len; i += 3) {
          base64 += chars[bytes[i] >> 2];
          base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
          base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
          base64 += chars[bytes[i + 2] & 63];
        }
        if (len % 3 === 2) {
          base64 = base64.substring(0, base64.length - 1) + "=";
        } else if (len % 3 === 1) {
          base64 = base64.substring(0, base64.length - 2) + "==";
        }
        return base64;
      };
      exports.decode = function(base64) {
        var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
        if (base64[base64.length - 1] === "=") {
          bufferLength--;
          if (base64[base64.length - 2] === "=") {
            bufferLength--;
          }
        }
        var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
        for (i = 0; i < len; i += 4) {
          encoded1 = chars.indexOf(base64[i]);
          encoded2 = chars.indexOf(base64[i + 1]);
          encoded3 = chars.indexOf(base64[i + 2]);
          encoded4 = chars.indexOf(base64[i + 3]);
          bytes[p++] = encoded1 << 2 | encoded2 >> 4;
          bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
          bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
        }
        return arraybuffer;
      };
    })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
  }
});

// node_modules/blob/index.js
var require_blob = __commonJS({
  "node_modules/blob/index.js"(exports, module) {
    var BlobBuilder = typeof BlobBuilder !== "undefined" ? BlobBuilder : typeof WebKitBlobBuilder !== "undefined" ? WebKitBlobBuilder : typeof MSBlobBuilder !== "undefined" ? MSBlobBuilder : typeof MozBlobBuilder !== "undefined" ? MozBlobBuilder : false;
    var blobSupported = function() {
      try {
        var a = new Blob(["hi"]);
        return a.size === 2;
      } catch (e) {
        return false;
      }
    }();
    var blobSupportsArrayBufferView = blobSupported && function() {
      try {
        var b = new Blob([new Uint8Array([1, 2])]);
        return b.size === 2;
      } catch (e) {
        return false;
      }
    }();
    var blobBuilderSupported = BlobBuilder && BlobBuilder.prototype.append && BlobBuilder.prototype.getBlob;
    function mapArrayBufferViews(ary) {
      return ary.map(function(chunk) {
        if (chunk.buffer instanceof ArrayBuffer) {
          var buf = chunk.buffer;
          if (chunk.byteLength !== buf.byteLength) {
            var copy = new Uint8Array(chunk.byteLength);
            copy.set(new Uint8Array(buf, chunk.byteOffset, chunk.byteLength));
            buf = copy.buffer;
          }
          return buf;
        }
        return chunk;
      });
    }
    function BlobBuilderConstructor(ary, options) {
      options = options || {};
      var bb = new BlobBuilder();
      mapArrayBufferViews(ary).forEach(function(part) {
        bb.append(part);
      });
      return options.type ? bb.getBlob(options.type) : bb.getBlob();
    }
    function BlobConstructor(ary, options) {
      return new Blob(mapArrayBufferViews(ary), options || {});
    }
    if (typeof Blob !== "undefined") {
      BlobBuilderConstructor.prototype = Blob.prototype;
      BlobConstructor.prototype = Blob.prototype;
    }
    module.exports = function() {
      if (blobSupported) {
        return blobSupportsArrayBufferView ? Blob : BlobConstructor;
      } else if (blobBuilderSupported) {
        return BlobBuilderConstructor;
      } else {
        return void 0;
      }
    }();
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-parser/lib/browser.js
var require_browser4 = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-parser/lib/browser.js"(exports) {
    var keys = require_keys();
    var hasBinary = require_has_binary2();
    var sliceBuffer = require_arraybuffer();
    var after = require_after();
    var utf8 = require_utf8();
    var base64encoder;
    if (typeof ArrayBuffer !== "undefined") {
      base64encoder = require_base64_arraybuffer();
    }
    var isAndroid = typeof navigator !== "undefined" && /Android/i.test(navigator.userAgent);
    var isPhantomJS = typeof navigator !== "undefined" && /PhantomJS/i.test(navigator.userAgent);
    var dontSendBlobs = isAndroid || isPhantomJS;
    exports.protocol = 3;
    var packets = exports.packets = {
      open: 0,
      close: 1,
      ping: 2,
      pong: 3,
      message: 4,
      upgrade: 5,
      noop: 6
    };
    var packetslist = keys(packets);
    var err = { type: "error", data: "parser error" };
    var Blob2 = require_blob();
    exports.encodePacket = function(packet, supportsBinary, utf8encode, callback) {
      if (typeof supportsBinary === "function") {
        callback = supportsBinary;
        supportsBinary = false;
      }
      if (typeof utf8encode === "function") {
        callback = utf8encode;
        utf8encode = null;
      }
      var data = packet.data === void 0 ? void 0 : packet.data.buffer || packet.data;
      if (typeof ArrayBuffer !== "undefined" && data instanceof ArrayBuffer) {
        return encodeArrayBuffer(packet, supportsBinary, callback);
      } else if (typeof Blob2 !== "undefined" && data instanceof Blob2) {
        return encodeBlob(packet, supportsBinary, callback);
      }
      if (data && data.base64) {
        return encodeBase64Object(packet, callback);
      }
      var encoded = packets[packet.type];
      if (void 0 !== packet.data) {
        encoded += utf8encode ? utf8.encode(String(packet.data), { strict: false }) : String(packet.data);
      }
      return callback("" + encoded);
    };
    function encodeBase64Object(packet, callback) {
      var message = "b" + exports.packets[packet.type] + packet.data.data;
      return callback(message);
    }
    function encodeArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }
      var data = packet.data;
      var contentArray = new Uint8Array(data);
      var resultBuffer = new Uint8Array(1 + data.byteLength);
      resultBuffer[0] = packets[packet.type];
      for (var i = 0; i < contentArray.length; i++) {
        resultBuffer[i + 1] = contentArray[i];
      }
      return callback(resultBuffer.buffer);
    }
    function encodeBlobAsArrayBuffer(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }
      var fr = new FileReader();
      fr.onload = function() {
        exports.encodePacket({ type: packet.type, data: fr.result }, supportsBinary, true, callback);
      };
      return fr.readAsArrayBuffer(packet.data);
    }
    function encodeBlob(packet, supportsBinary, callback) {
      if (!supportsBinary) {
        return exports.encodeBase64Packet(packet, callback);
      }
      if (dontSendBlobs) {
        return encodeBlobAsArrayBuffer(packet, supportsBinary, callback);
      }
      var length = new Uint8Array(1);
      length[0] = packets[packet.type];
      var blob = new Blob2([length.buffer, packet.data]);
      return callback(blob);
    }
    exports.encodeBase64Packet = function(packet, callback) {
      var message = "b" + exports.packets[packet.type];
      if (typeof Blob2 !== "undefined" && packet.data instanceof Blob2) {
        var fr = new FileReader();
        fr.onload = function() {
          var b64 = fr.result.split(",")[1];
          callback(message + b64);
        };
        return fr.readAsDataURL(packet.data);
      }
      var b64data;
      try {
        b64data = String.fromCharCode.apply(null, new Uint8Array(packet.data));
      } catch (e) {
        var typed = new Uint8Array(packet.data);
        var basic = new Array(typed.length);
        for (var i = 0; i < typed.length; i++) {
          basic[i] = typed[i];
        }
        b64data = String.fromCharCode.apply(null, basic);
      }
      message += btoa(b64data);
      return callback(message);
    };
    exports.decodePacket = function(data, binaryType, utf8decode) {
      if (data === void 0) {
        return err;
      }
      if (typeof data === "string") {
        if (data.charAt(0) === "b") {
          return exports.decodeBase64Packet(data.substr(1), binaryType);
        }
        if (utf8decode) {
          data = tryDecode(data);
          if (data === false) {
            return err;
          }
        }
        var type = data.charAt(0);
        if (Number(type) != type || !packetslist[type]) {
          return err;
        }
        if (data.length > 1) {
          return { type: packetslist[type], data: data.substring(1) };
        } else {
          return { type: packetslist[type] };
        }
      }
      var asArray = new Uint8Array(data);
      var type = asArray[0];
      var rest = sliceBuffer(data, 1);
      if (Blob2 && binaryType === "blob") {
        rest = new Blob2([rest]);
      }
      return { type: packetslist[type], data: rest };
    };
    function tryDecode(data) {
      try {
        data = utf8.decode(data, { strict: false });
      } catch (e) {
        return false;
      }
      return data;
    }
    exports.decodeBase64Packet = function(msg, binaryType) {
      var type = packetslist[msg.charAt(0)];
      if (!base64encoder) {
        return { type, data: { base64: true, data: msg.substr(1) } };
      }
      var data = base64encoder.decode(msg.substr(1));
      if (binaryType === "blob" && Blob2) {
        data = new Blob2([data]);
      }
      return { type, data };
    };
    exports.encodePayload = function(packets2, supportsBinary, callback) {
      if (typeof supportsBinary === "function") {
        callback = supportsBinary;
        supportsBinary = null;
      }
      var isBinary = hasBinary(packets2);
      if (supportsBinary && isBinary) {
        if (Blob2 && !dontSendBlobs) {
          return exports.encodePayloadAsBlob(packets2, callback);
        }
        return exports.encodePayloadAsArrayBuffer(packets2, callback);
      }
      if (!packets2.length) {
        return callback("0:");
      }
      function setLengthHeader(message) {
        return message.length + ":" + message;
      }
      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, !isBinary ? false : supportsBinary, false, function(message) {
          doneCallback(null, setLengthHeader(message));
        });
      }
      map(packets2, encodeOne, function(err2, results) {
        return callback(results.join(""));
      });
    };
    function map(ary, each, done) {
      var result = new Array(ary.length);
      var next = after(ary.length, done);
      var eachWithIndex = function(i2, el, cb) {
        each(el, function(error, msg) {
          result[i2] = msg;
          cb(error, result);
        });
      };
      for (var i = 0; i < ary.length; i++) {
        eachWithIndex(i, ary[i], next);
      }
    }
    exports.decodePayload = function(data, binaryType, callback) {
      if (typeof data !== "string") {
        return exports.decodePayloadAsBinary(data, binaryType, callback);
      }
      if (typeof binaryType === "function") {
        callback = binaryType;
        binaryType = null;
      }
      var packet;
      if (data === "") {
        return callback(err, 0, 1);
      }
      var length = "", n, msg;
      for (var i = 0, l = data.length; i < l; i++) {
        var chr = data.charAt(i);
        if (chr !== ":") {
          length += chr;
          continue;
        }
        if (length === "" || length != (n = Number(length))) {
          return callback(err, 0, 1);
        }
        msg = data.substr(i + 1, n);
        if (length != msg.length) {
          return callback(err, 0, 1);
        }
        if (msg.length) {
          packet = exports.decodePacket(msg, binaryType, false);
          if (err.type === packet.type && err.data === packet.data) {
            return callback(err, 0, 1);
          }
          var ret = callback(packet, i + n, l);
          if (false === ret)
            return;
        }
        i += n;
        length = "";
      }
      if (length !== "") {
        return callback(err, 0, 1);
      }
    };
    exports.encodePayloadAsArrayBuffer = function(packets2, callback) {
      if (!packets2.length) {
        return callback(new ArrayBuffer(0));
      }
      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(data) {
          return doneCallback(null, data);
        });
      }
      map(packets2, encodeOne, function(err2, encodedPackets) {
        var totalLength = encodedPackets.reduce(function(acc, p) {
          var len;
          if (typeof p === "string") {
            len = p.length;
          } else {
            len = p.byteLength;
          }
          return acc + len.toString().length + len + 2;
        }, 0);
        var resultArray = new Uint8Array(totalLength);
        var bufferIndex = 0;
        encodedPackets.forEach(function(p) {
          var isString = typeof p === "string";
          var ab = p;
          if (isString) {
            var view = new Uint8Array(p.length);
            for (var i = 0; i < p.length; i++) {
              view[i] = p.charCodeAt(i);
            }
            ab = view.buffer;
          }
          if (isString) {
            resultArray[bufferIndex++] = 0;
          } else {
            resultArray[bufferIndex++] = 1;
          }
          var lenStr = ab.byteLength.toString();
          for (var i = 0; i < lenStr.length; i++) {
            resultArray[bufferIndex++] = parseInt(lenStr[i]);
          }
          resultArray[bufferIndex++] = 255;
          var view = new Uint8Array(ab);
          for (var i = 0; i < view.length; i++) {
            resultArray[bufferIndex++] = view[i];
          }
        });
        return callback(resultArray.buffer);
      });
    };
    exports.encodePayloadAsBlob = function(packets2, callback) {
      function encodeOne(packet, doneCallback) {
        exports.encodePacket(packet, true, true, function(encoded) {
          var binaryIdentifier = new Uint8Array(1);
          binaryIdentifier[0] = 1;
          if (typeof encoded === "string") {
            var view = new Uint8Array(encoded.length);
            for (var i = 0; i < encoded.length; i++) {
              view[i] = encoded.charCodeAt(i);
            }
            encoded = view.buffer;
            binaryIdentifier[0] = 0;
          }
          var len = encoded instanceof ArrayBuffer ? encoded.byteLength : encoded.size;
          var lenStr = len.toString();
          var lengthAry = new Uint8Array(lenStr.length + 1);
          for (var i = 0; i < lenStr.length; i++) {
            lengthAry[i] = parseInt(lenStr[i]);
          }
          lengthAry[lenStr.length] = 255;
          if (Blob2) {
            var blob = new Blob2([binaryIdentifier.buffer, lengthAry.buffer, encoded]);
            doneCallback(null, blob);
          }
        });
      }
      map(packets2, encodeOne, function(err2, results) {
        return callback(new Blob2(results));
      });
    };
    exports.decodePayloadAsBinary = function(data, binaryType, callback) {
      if (typeof binaryType === "function") {
        callback = binaryType;
        binaryType = null;
      }
      var bufferTail = data;
      var buffers = [];
      while (bufferTail.byteLength > 0) {
        var tailArray = new Uint8Array(bufferTail);
        var isString = tailArray[0] === 0;
        var msgLength = "";
        for (var i = 1; ; i++) {
          if (tailArray[i] === 255)
            break;
          if (msgLength.length > 310) {
            return callback(err, 0, 1);
          }
          msgLength += tailArray[i];
        }
        bufferTail = sliceBuffer(bufferTail, 2 + msgLength.length);
        msgLength = parseInt(msgLength);
        var msg = sliceBuffer(bufferTail, 0, msgLength);
        if (isString) {
          try {
            msg = String.fromCharCode.apply(null, new Uint8Array(msg));
          } catch (e) {
            var typed = new Uint8Array(msg);
            msg = "";
            for (var i = 0; i < typed.length; i++) {
              msg += String.fromCharCode(typed[i]);
            }
          }
        }
        buffers.push(msg);
        bufferTail = sliceBuffer(bufferTail, msgLength);
      }
      var total = buffers.length;
      buffers.forEach(function(buffer, i2) {
        callback(exports.decodePacket(buffer, binaryType, true), i2, total);
      });
    };
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transport.js
var require_transport = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transport.js"(exports, module) {
    var parser = require_browser4();
    var Emitter = require_component_emitter();
    module.exports = Transport;
    function Transport(opts) {
      this.path = opts.path;
      this.hostname = opts.hostname;
      this.port = opts.port;
      this.secure = opts.secure;
      this.query = opts.query;
      this.timestampParam = opts.timestampParam;
      this.timestampRequests = opts.timestampRequests;
      this.readyState = "";
      this.agent = opts.agent || false;
      this.socket = opts.socket;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.forceNode = opts.forceNode;
      this.isReactNative = opts.isReactNative;
      this.extraHeaders = opts.extraHeaders;
      this.localAddress = opts.localAddress;
    }
    Emitter(Transport.prototype);
    Transport.prototype.onError = function(msg, desc) {
      var err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    };
    Transport.prototype.open = function() {
      if ("closed" === this.readyState || "" === this.readyState) {
        this.readyState = "opening";
        this.doOpen();
      }
      return this;
    };
    Transport.prototype.close = function() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.doClose();
        this.onClose();
      }
      return this;
    };
    Transport.prototype.send = function(packets) {
      if ("open" === this.readyState) {
        this.write(packets);
      } else {
        throw new Error("Transport not open");
      }
    };
    Transport.prototype.onOpen = function() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    };
    Transport.prototype.onData = function(data) {
      var packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    };
    Transport.prototype.onPacket = function(packet) {
      this.emit("packet", packet);
    };
    Transport.prototype.onClose = function() {
      this.readyState = "closed";
      this.emit("close");
    };
  }
});

// node_modules/parseqs/index.js
var require_parseqs = __commonJS({
  "node_modules/parseqs/index.js"(exports) {
    exports.encode = function(obj) {
      var str = "";
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length)
            str += "&";
          str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
        }
      }
      return str;
    };
    exports.decode = function(qs) {
      var qry = {};
      var pairs = qs.split("&");
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
  }
});

// node_modules/component-inherit/index.js
var require_component_inherit = __commonJS({
  "node_modules/component-inherit/index.js"(exports, module) {
    module.exports = function(a, b) {
      var fn = function() {
      };
      fn.prototype = b.prototype;
      a.prototype = new fn();
      a.prototype.constructor = a;
    };
  }
});

// node_modules/yeast/index.js
var require_yeast = __commonJS({
  "node_modules/yeast/index.js"(exports, module) {
    "use strict";
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
    var length = 64;
    var map = {};
    var seed = 0;
    var i = 0;
    var prev;
    function encode(num) {
      var encoded = "";
      do {
        encoded = alphabet[num % length] + encoded;
        num = Math.floor(num / length);
      } while (num > 0);
      return encoded;
    }
    function decode(str) {
      var decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length + map[str.charAt(i)];
      }
      return decoded;
    }
    function yeast() {
      var now = encode(+/* @__PURE__ */ new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + "." + encode(seed++);
    }
    for (; i < length; i++)
      map[alphabet[i]] = i;
    yeast.encode = encode;
    yeast.decode = decode;
    module.exports = yeast;
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/polling.js
var require_polling = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/polling.js"(exports, module) {
    var Transport = require_transport();
    var parseqs = require_parseqs();
    var parser = require_browser4();
    var inherit = require_component_inherit();
    var yeast = require_yeast();
    var debug = require_browser3()("engine.io-client:polling");
    module.exports = Polling;
    var hasXHR2 = function() {
      var XMLHttpRequest2 = require_xmlhttprequest_browser();
      var xhr = new XMLHttpRequest2({ xdomain: false });
      return null != xhr.responseType;
    }();
    function Polling(opts) {
      var forceBase64 = opts && opts.forceBase64;
      if (!hasXHR2 || forceBase64) {
        this.supportsBinary = false;
      }
      Transport.call(this, opts);
    }
    inherit(Polling, Transport);
    Polling.prototype.name = "polling";
    Polling.prototype.doOpen = function() {
      this.poll();
    };
    Polling.prototype.pause = function(onPause) {
      var self2 = this;
      this.readyState = "pausing";
      function pause() {
        debug("paused");
        self2.readyState = "paused";
        onPause();
      }
      if (this.polling || !this.writable) {
        var total = 0;
        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    };
    Polling.prototype.poll = function() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    };
    Polling.prototype.onData = function(data) {
      var self2 = this;
      debug("polling got data %s", data);
      var callback = function(packet, index, total) {
        if ("opening" === self2.readyState && packet.type === "open") {
          self2.onOpen();
        }
        if ("close" === packet.type) {
          self2.onClose();
          return false;
        }
        self2.onPacket(packet);
      };
      parser.decodePayload(data, this.socket.binaryType, callback);
      if ("closed" !== this.readyState) {
        this.polling = false;
        this.emit("pollComplete");
        if ("open" === this.readyState) {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    };
    Polling.prototype.doClose = function() {
      var self2 = this;
      function close() {
        debug("writing close packet");
        self2.write([{ type: "close" }]);
      }
      if ("open" === this.readyState) {
        debug("transport open - closing");
        close();
      } else {
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    };
    Polling.prototype.write = function(packets) {
      var self2 = this;
      this.writable = false;
      var callbackfn = function() {
        self2.writable = true;
        self2.emit("drain");
      };
      parser.encodePayload(packets, this.supportsBinary, function(data) {
        self2.doWrite(data, callbackfn);
      });
    };
    Polling.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? "https" : "http";
      var port = "";
      if (false !== this.timestampRequests) {
        query[this.timestampParam] = yeast();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (this.port && ("https" === schema && Number(this.port) !== 443 || "http" === schema && Number(this.port) !== 80)) {
        port = ":" + this.port;
      }
      if (query.length) {
        query = "?" + query;
      }
      var ipv6 = this.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
    };
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/polling-xhr.js
var require_polling_xhr = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/polling-xhr.js"(exports, module) {
    var XMLHttpRequest2 = require_xmlhttprequest_browser();
    var Polling = require_polling();
    var Emitter = require_component_emitter();
    var inherit = require_component_inherit();
    var debug = require_browser3()("engine.io-client:polling-xhr");
    var globalThis2 = require_globalThis_browser();
    module.exports = XHR;
    module.exports.Request = Request;
    function empty() {
    }
    function XHR(opts) {
      Polling.call(this, opts);
      this.requestTimeout = opts.requestTimeout;
      this.extraHeaders = opts.extraHeaders;
      if (typeof location !== "undefined") {
        var isSSL = "https:" === location.protocol;
        var port = location.port;
        if (!port) {
          port = isSSL ? 443 : 80;
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        this.xs = opts.secure !== isSSL;
      }
    }
    inherit(XHR, Polling);
    XHR.prototype.supportsBinary = true;
    XHR.prototype.request = function(opts) {
      opts = opts || {};
      opts.uri = this.uri();
      opts.xd = this.xd;
      opts.xs = this.xs;
      opts.agent = this.agent || false;
      opts.supportsBinary = this.supportsBinary;
      opts.enablesXDR = this.enablesXDR;
      opts.withCredentials = this.withCredentials;
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      opts.requestTimeout = this.requestTimeout;
      opts.extraHeaders = this.extraHeaders;
      return new Request(opts);
    };
    XHR.prototype.doWrite = function(data, fn) {
      var isBinary = typeof data !== "string" && data !== void 0;
      var req = this.request({ method: "POST", data, isBinary });
      var self2 = this;
      req.on("success", fn);
      req.on("error", function(err) {
        self2.onError("xhr post error", err);
      });
      this.sendXhr = req;
    };
    XHR.prototype.doPoll = function() {
      debug("xhr poll");
      var req = this.request();
      var self2 = this;
      req.on("data", function(data) {
        self2.onData(data);
      });
      req.on("error", function(err) {
        self2.onError("xhr poll error", err);
      });
      this.pollXhr = req;
    };
    function Request(opts) {
      this.method = opts.method || "GET";
      this.uri = opts.uri;
      this.xd = !!opts.xd;
      this.xs = !!opts.xs;
      this.async = false !== opts.async;
      this.data = void 0 !== opts.data ? opts.data : null;
      this.agent = opts.agent;
      this.isBinary = opts.isBinary;
      this.supportsBinary = opts.supportsBinary;
      this.enablesXDR = opts.enablesXDR;
      this.withCredentials = opts.withCredentials;
      this.requestTimeout = opts.requestTimeout;
      this.pfx = opts.pfx;
      this.key = opts.key;
      this.passphrase = opts.passphrase;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.ciphers = opts.ciphers;
      this.rejectUnauthorized = opts.rejectUnauthorized;
      this.extraHeaders = opts.extraHeaders;
      this.create();
    }
    Emitter(Request.prototype);
    Request.prototype.create = function() {
      var opts = { agent: this.agent, xdomain: this.xd, xscheme: this.xs, enablesXDR: this.enablesXDR };
      opts.pfx = this.pfx;
      opts.key = this.key;
      opts.passphrase = this.passphrase;
      opts.cert = this.cert;
      opts.ca = this.ca;
      opts.ciphers = this.ciphers;
      opts.rejectUnauthorized = this.rejectUnauthorized;
      var xhr = this.xhr = new XMLHttpRequest2(opts);
      var self2 = this;
      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (var i in this.extraHeaders) {
              if (this.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.extraHeaders[i]);
              }
            }
          }
        } catch (e) {
        }
        if ("POST" === this.method) {
          try {
            if (this.isBinary) {
              xhr.setRequestHeader("Content-type", "application/octet-stream");
            } else {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            }
          } catch (e) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {
        }
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.withCredentials;
        }
        if (this.requestTimeout) {
          xhr.timeout = this.requestTimeout;
        }
        if (this.hasXDR()) {
          xhr.onload = function() {
            self2.onLoad();
          };
          xhr.onerror = function() {
            self2.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function() {
            if (xhr.readyState === 2) {
              try {
                var contentType = xhr.getResponseHeader("Content-Type");
                if (self2.supportsBinary && contentType === "application/octet-stream" || contentType === "application/octet-stream; charset=UTF-8") {
                  xhr.responseType = "arraybuffer";
                }
              } catch (e) {
              }
            }
            if (4 !== xhr.readyState)
              return;
            if (200 === xhr.status || 1223 === xhr.status) {
              self2.onLoad();
            } else {
              setTimeout(function() {
                self2.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
        }
        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        setTimeout(function() {
          self2.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    };
    Request.prototype.onSuccess = function() {
      this.emit("success");
      this.cleanup();
    };
    Request.prototype.onData = function(data) {
      this.emit("data", data);
      this.onSuccess();
    };
    Request.prototype.onError = function(err) {
      this.emit("error", err);
      this.cleanup(true);
    };
    Request.prototype.cleanup = function(fromError) {
      if ("undefined" === typeof this.xhr || null === this.xhr) {
        return;
      }
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty;
      } else {
        this.xhr.onreadystatechange = empty;
      }
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    };
    Request.prototype.onLoad = function() {
      var data;
      try {
        var contentType;
        try {
          contentType = this.xhr.getResponseHeader("Content-Type");
        } catch (e) {
        }
        if (contentType === "application/octet-stream" || contentType === "application/octet-stream; charset=UTF-8") {
          data = this.xhr.response || this.xhr.responseText;
        } else {
          data = this.xhr.responseText;
        }
      } catch (e) {
        this.onError(e);
      }
      if (null != data) {
        this.onData(data);
      }
    };
    Request.prototype.hasXDR = function() {
      return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
    };
    Request.prototype.abort = function() {
      this.cleanup();
    };
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        terminationEvent = "onpagehide" in globalThis2 ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
    var terminationEvent;
    function unloadHandler() {
      for (var i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/polling-jsonp.js
var require_polling_jsonp = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/polling-jsonp.js"(exports, module) {
    var Polling = require_polling();
    var inherit = require_component_inherit();
    var globalThis2 = require_globalThis_browser();
    module.exports = JSONPPolling;
    var rNewline = /\n/g;
    var rEscapedNewline = /\\n/g;
    var callbacks;
    function empty() {
    }
    function JSONPPolling(opts) {
      Polling.call(this, opts);
      this.query = this.query || {};
      if (!callbacks) {
        callbacks = globalThis2.___eio = globalThis2.___eio || [];
      }
      this.index = callbacks.length;
      var self2 = this;
      callbacks.push(function(msg) {
        self2.onData(msg);
      });
      this.query.j = this.index;
      if (typeof addEventListener === "function") {
        addEventListener("beforeunload", function() {
          if (self2.script)
            self2.script.onerror = empty;
        }, false);
      }
    }
    inherit(JSONPPolling, Polling);
    JSONPPolling.prototype.supportsBinary = false;
    JSONPPolling.prototype.doClose = function() {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }
      Polling.prototype.doClose.call(this);
    };
    JSONPPolling.prototype.doPoll = function() {
      var self2 = this;
      var script = document.createElement("script");
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      script.async = true;
      script.src = this.uri();
      script.onerror = function(e) {
        self2.onError("jsonp poll error", e);
      };
      var insertAt = document.getElementsByTagName("script")[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;
      var isUAgecko = "undefined" !== typeof navigator && /gecko/i.test(navigator.userAgent);
      if (isUAgecko) {
        setTimeout(function() {
          var iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    };
    JSONPPolling.prototype.doWrite = function(data, fn) {
      var self2 = this;
      if (!this.form) {
        var form = document.createElement("form");
        var area = document.createElement("textarea");
        var id = this.iframeId = "eio_iframe_" + this.index;
        var iframe;
        form.className = "socketio";
        form.style.position = "absolute";
        form.style.top = "-1000px";
        form.style.left = "-1000px";
        form.target = id;
        form.method = "POST";
        form.setAttribute("accept-charset", "utf-8");
        area.name = "d";
        form.appendChild(area);
        document.body.appendChild(form);
        this.form = form;
        this.area = area;
      }
      this.form.action = this.uri();
      function complete() {
        initIframe();
        fn();
      }
      function initIframe() {
        if (self2.iframe) {
          try {
            self2.form.removeChild(self2.iframe);
          } catch (e) {
            self2.onError("jsonp polling iframe removal error", e);
          }
        }
        try {
          var html = '<iframe src="javascript:0" name="' + self2.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement("iframe");
          iframe.name = self2.iframeId;
          iframe.src = "javascript:0";
        }
        iframe.id = self2.iframeId;
        self2.form.appendChild(iframe);
        self2.iframe = iframe;
      }
      initIframe();
      data = data.replace(rEscapedNewline, "\\\n");
      this.area.value = data.replace(rNewline, "\\n");
      try {
        this.form.submit();
      } catch (e) {
      }
      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function() {
          if (self2.iframe.readyState === "complete") {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    };
  }
});

// browser-external:ws
var require_ws = __commonJS({
  "browser-external:ws"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "ws" has been externalized for browser compatibility. Cannot access "ws.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/websocket.js
var require_websocket = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/websocket.js"(exports, module) {
    var Transport = require_transport();
    var parser = require_browser4();
    var parseqs = require_parseqs();
    var inherit = require_component_inherit();
    var yeast = require_yeast();
    var debug = require_browser3()("engine.io-client:websocket");
    var BrowserWebSocket;
    var NodeWebSocket;
    if (typeof WebSocket !== "undefined") {
      BrowserWebSocket = WebSocket;
    } else if (typeof self !== "undefined") {
      BrowserWebSocket = self.WebSocket || self.MozWebSocket;
    }
    if (typeof window === "undefined") {
      try {
        NodeWebSocket = require_ws();
      } catch (e) {
      }
    }
    var WebSocketImpl = BrowserWebSocket || NodeWebSocket;
    module.exports = WS;
    function WS(opts) {
      var forceBase64 = opts && opts.forceBase64;
      if (forceBase64) {
        this.supportsBinary = false;
      }
      this.perMessageDeflate = opts.perMessageDeflate;
      this.usingBrowserWebSocket = BrowserWebSocket && !opts.forceNode;
      this.protocols = opts.protocols;
      if (!this.usingBrowserWebSocket) {
        WebSocketImpl = NodeWebSocket;
      }
      Transport.call(this, opts);
    }
    inherit(WS, Transport);
    WS.prototype.name = "websocket";
    WS.prototype.supportsBinary = true;
    WS.prototype.doOpen = function() {
      if (!this.check()) {
        return;
      }
      var uri = this.uri();
      var protocols = this.protocols;
      var opts = {};
      if (!this.isReactNative) {
        opts.agent = this.agent;
        opts.perMessageDeflate = this.perMessageDeflate;
        opts.pfx = this.pfx;
        opts.key = this.key;
        opts.passphrase = this.passphrase;
        opts.cert = this.cert;
        opts.ca = this.ca;
        opts.ciphers = this.ciphers;
        opts.rejectUnauthorized = this.rejectUnauthorized;
      }
      if (this.extraHeaders) {
        opts.headers = this.extraHeaders;
      }
      if (this.localAddress) {
        opts.localAddress = this.localAddress;
      }
      try {
        this.ws = this.usingBrowserWebSocket && !this.isReactNative ? protocols ? new WebSocketImpl(uri, protocols) : new WebSocketImpl(uri) : new WebSocketImpl(uri, protocols, opts);
      } catch (err) {
        return this.emit("error", err);
      }
      if (this.ws.binaryType === void 0) {
        this.supportsBinary = false;
      }
      if (this.ws.supports && this.ws.supports.binary) {
        this.supportsBinary = true;
        this.ws.binaryType = "nodebuffer";
      } else {
        this.ws.binaryType = "arraybuffer";
      }
      this.addEventListeners();
    };
    WS.prototype.addEventListeners = function() {
      var self2 = this;
      this.ws.onopen = function() {
        self2.onOpen();
      };
      this.ws.onclose = function() {
        self2.onClose();
      };
      this.ws.onmessage = function(ev) {
        self2.onData(ev.data);
      };
      this.ws.onerror = function(e) {
        self2.onError("websocket error", e);
      };
    };
    WS.prototype.write = function(packets) {
      var self2 = this;
      this.writable = false;
      var total = packets.length;
      for (var i = 0, l = total; i < l; i++) {
        (function(packet) {
          parser.encodePacket(packet, self2.supportsBinary, function(data) {
            if (!self2.usingBrowserWebSocket) {
              var opts = {};
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (self2.perMessageDeflate) {
                var len = "string" === typeof data ? Buffer.byteLength(data) : data.length;
                if (len < self2.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (self2.usingBrowserWebSocket) {
                self2.ws.send(data);
              } else {
                self2.ws.send(data, opts);
              }
            } catch (e) {
              debug("websocket closed before onclose event");
            }
            --total || done();
          });
        })(packets[i]);
      }
      function done() {
        self2.emit("flush");
        setTimeout(function() {
          self2.writable = true;
          self2.emit("drain");
        }, 0);
      }
    };
    WS.prototype.onClose = function() {
      Transport.prototype.onClose.call(this);
    };
    WS.prototype.doClose = function() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
      }
    };
    WS.prototype.uri = function() {
      var query = this.query || {};
      var schema = this.secure ? "wss" : "ws";
      var port = "";
      if (this.port && ("wss" === schema && Number(this.port) !== 443 || "ws" === schema && Number(this.port) !== 80)) {
        port = ":" + this.port;
      }
      if (this.timestampRequests) {
        query[this.timestampParam] = yeast();
      }
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (query.length) {
        query = "?" + query;
      }
      var ipv6 = this.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.hostname + "]" : this.hostname) + port + this.path + query;
    };
    WS.prototype.check = function() {
      return !!WebSocketImpl && !("__initialize" in WebSocketImpl && this.name === WS.prototype.name);
    };
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/index.js
var require_transports = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/transports/index.js"(exports) {
    var XMLHttpRequest2 = require_xmlhttprequest_browser();
    var XHR = require_polling_xhr();
    var JSONP = require_polling_jsonp();
    var websocket = require_websocket();
    exports.polling = polling;
    exports.websocket = websocket;
    function polling(opts) {
      var xhr;
      var xd = false;
      var xs = false;
      var jsonp = false !== opts.jsonp;
      if (typeof location !== "undefined") {
        var isSSL = "https:" === location.protocol;
        var port = location.port;
        if (!port) {
          port = isSSL ? 443 : 80;
        }
        xd = opts.hostname !== location.hostname || port !== opts.port;
        xs = opts.secure !== isSSL;
      }
      opts.xdomain = xd;
      opts.xscheme = xs;
      xhr = new XMLHttpRequest2(opts);
      if ("open" in xhr && !opts.forceJSONP) {
        return new XHR(opts);
      } else {
        if (!jsonp)
          throw new Error("JSONP disabled");
        return new JSONP(opts);
      }
    }
  }
});

// node_modules/indexof/index.js
var require_indexof = __commonJS({
  "node_modules/indexof/index.js"(exports, module) {
    var indexOf = [].indexOf;
    module.exports = function(arr, obj) {
      if (indexOf)
        return arr.indexOf(obj);
      for (var i = 0; i < arr.length; ++i) {
        if (arr[i] === obj)
          return i;
      }
      return -1;
    };
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/socket.js
var require_socket2 = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/socket.js"(exports, module) {
    var transports = require_transports();
    var Emitter = require_component_emitter();
    var debug = require_browser3()("engine.io-client:socket");
    var index = require_indexof();
    var parser = require_browser4();
    var parseuri = require_parseuri();
    var parseqs = require_parseqs();
    module.exports = Socket2;
    function Socket2(uri, opts) {
      if (!(this instanceof Socket2))
        return new Socket2(uri, opts);
      opts = opts || {};
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }
      this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.agent = opts.agent || false;
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
      this.query = opts.query || {};
      if ("string" === typeof this.query)
        this.query = parseqs.decode(this.query);
      this.upgrade = false !== opts.upgrade;
      this.path = (opts.path || "/engine.io").replace(/\/$/, "") + "/";
      this.forceJSONP = !!opts.forceJSONP;
      this.jsonp = false !== opts.jsonp;
      this.forceBase64 = !!opts.forceBase64;
      this.enablesXDR = !!opts.enablesXDR;
      this.withCredentials = false !== opts.withCredentials;
      this.timestampParam = opts.timestampParam || "t";
      this.timestampRequests = opts.timestampRequests;
      this.transports = opts.transports || ["polling", "websocket"];
      this.transportOptions = opts.transportOptions || {};
      this.readyState = "";
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.policyPort = opts.policyPort || 843;
      this.rememberUpgrade = opts.rememberUpgrade || false;
      this.binaryType = null;
      this.onlyBinaryUpgrades = opts.onlyBinaryUpgrades;
      this.perMessageDeflate = false !== opts.perMessageDeflate ? opts.perMessageDeflate || {} : false;
      if (true === this.perMessageDeflate)
        this.perMessageDeflate = {};
      if (this.perMessageDeflate && null == this.perMessageDeflate.threshold) {
        this.perMessageDeflate.threshold = 1024;
      }
      this.pfx = opts.pfx || void 0;
      this.key = opts.key || void 0;
      this.passphrase = opts.passphrase || void 0;
      this.cert = opts.cert || void 0;
      this.ca = opts.ca || void 0;
      this.ciphers = opts.ciphers || void 0;
      this.rejectUnauthorized = opts.rejectUnauthorized === void 0 ? true : opts.rejectUnauthorized;
      this.forceNode = !!opts.forceNode;
      this.isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
      if (typeof self === "undefined" || this.isReactNative) {
        if (opts.extraHeaders && Object.keys(opts.extraHeaders).length > 0) {
          this.extraHeaders = opts.extraHeaders;
        }
        if (opts.localAddress) {
          this.localAddress = opts.localAddress;
        }
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingIntervalTimer = null;
      this.pingTimeoutTimer = null;
      this.open();
    }
    Socket2.priorWebsocketSuccess = false;
    Emitter(Socket2.prototype);
    Socket2.protocol = parser.protocol;
    Socket2.Socket = Socket2;
    Socket2.Transport = require_transport();
    Socket2.transports = require_transports();
    Socket2.parser = require_browser4();
    Socket2.prototype.createTransport = function(name) {
      debug('creating transport "%s"', name);
      var query = clone(this.query);
      query.EIO = parser.protocol;
      query.transport = name;
      var options = this.transportOptions[name] || {};
      if (this.id)
        query.sid = this.id;
      var transport = new transports[name]({
        query,
        socket: this,
        agent: options.agent || this.agent,
        hostname: options.hostname || this.hostname,
        port: options.port || this.port,
        secure: options.secure || this.secure,
        path: options.path || this.path,
        forceJSONP: options.forceJSONP || this.forceJSONP,
        jsonp: options.jsonp || this.jsonp,
        forceBase64: options.forceBase64 || this.forceBase64,
        enablesXDR: options.enablesXDR || this.enablesXDR,
        withCredentials: options.withCredentials || this.withCredentials,
        timestampRequests: options.timestampRequests || this.timestampRequests,
        timestampParam: options.timestampParam || this.timestampParam,
        policyPort: options.policyPort || this.policyPort,
        pfx: options.pfx || this.pfx,
        key: options.key || this.key,
        passphrase: options.passphrase || this.passphrase,
        cert: options.cert || this.cert,
        ca: options.ca || this.ca,
        ciphers: options.ciphers || this.ciphers,
        rejectUnauthorized: options.rejectUnauthorized || this.rejectUnauthorized,
        perMessageDeflate: options.perMessageDeflate || this.perMessageDeflate,
        extraHeaders: options.extraHeaders || this.extraHeaders,
        forceNode: options.forceNode || this.forceNode,
        localAddress: options.localAddress || this.localAddress,
        requestTimeout: options.requestTimeout || this.requestTimeout,
        protocols: options.protocols || void 0,
        isReactNative: this.isReactNative
      });
      return transport;
    };
    function clone(obj) {
      var o = {};
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = obj[i];
        }
      }
      return o;
    }
    Socket2.prototype.open = function() {
      var transport;
      if (this.rememberUpgrade && Socket2.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (0 === this.transports.length) {
        var self2 = this;
        setTimeout(function() {
          self2.emit("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        this.transports.shift();
        this.open();
        return;
      }
      transport.open();
      this.setTransport(transport);
    };
    Socket2.prototype.setTransport = function(transport) {
      debug("setting transport %s", transport.name);
      var self2 = this;
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      this.transport = transport;
      transport.on("drain", function() {
        self2.onDrain();
      }).on("packet", function(packet) {
        self2.onPacket(packet);
      }).on("error", function(e) {
        self2.onError(e);
      }).on("close", function() {
        self2.onClose("transport close");
      });
    };
    Socket2.prototype.probe = function(name) {
      debug('probing transport "%s"', name);
      var transport = this.createTransport(name, { probe: 1 });
      var failed = false;
      var self2 = this;
      Socket2.priorWebsocketSuccess = false;
      function onTransportOpen() {
        if (self2.onlyBinaryUpgrades) {
          var upgradeLosesBinary = !this.supportsBinary && self2.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed)
          return;
        debug('probe transport "%s" opened', name);
        transport.send([{ type: "ping", data: "probe" }]);
        transport.once("packet", function(msg) {
          if (failed)
            return;
          if ("pong" === msg.type && "probe" === msg.data) {
            debug('probe transport "%s" pong', name);
            self2.upgrading = true;
            self2.emit("upgrading", transport);
            if (!transport)
              return;
            Socket2.priorWebsocketSuccess = "websocket" === transport.name;
            debug('pausing current transport "%s"', self2.transport.name);
            self2.transport.pause(function() {
              if (failed)
                return;
              if ("closed" === self2.readyState)
                return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              self2.setTransport(transport);
              transport.send([{ type: "upgrade" }]);
              self2.emit("upgrade", transport);
              transport = null;
              self2.upgrading = false;
              self2.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            var err = new Error("probe error");
            err.transport = transport.name;
            self2.emit("upgradeError", err);
          }
        });
      }
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      function onerror(err) {
        var error = new Error("probe error: " + err);
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        self2.emit("upgradeError", error);
      }
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        self2.removeListener("close", onclose);
        self2.removeListener("upgrading", onupgrade);
      }
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      transport.open();
    };
    Socket2.prototype.onOpen = function() {
      debug("socket open");
      this.readyState = "open";
      Socket2.priorWebsocketSuccess = "websocket" === this.transport.name;
      this.emit("open");
      this.flush();
      if ("open" === this.readyState && this.upgrade && this.transport.pause) {
        debug("starting upgrade probes");
        for (var i = 0, l = this.upgrades.length; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    };
    Socket2.prototype.onPacket = function(packet) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emit("packet", packet);
        this.emit("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "pong":
            this.setPing();
            this.emit("pong");
            break;
          case "error":
            var err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    };
    Socket2.prototype.onHandshake = function(data) {
      this.emit("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      if ("closed" === this.readyState)
        return;
      this.setPing();
      this.removeListener("heartbeat", this.onHeartbeat);
      this.on("heartbeat", this.onHeartbeat);
    };
    Socket2.prototype.onHeartbeat = function(timeout) {
      clearTimeout(this.pingTimeoutTimer);
      var self2 = this;
      self2.pingTimeoutTimer = setTimeout(function() {
        if ("closed" === self2.readyState)
          return;
        self2.onClose("ping timeout");
      }, timeout || self2.pingInterval + self2.pingTimeout);
    };
    Socket2.prototype.setPing = function() {
      var self2 = this;
      clearTimeout(self2.pingIntervalTimer);
      self2.pingIntervalTimer = setTimeout(function() {
        debug("writing ping packet - expecting pong within %sms", self2.pingTimeout);
        self2.ping();
        self2.onHeartbeat(self2.pingTimeout);
      }, self2.pingInterval);
    };
    Socket2.prototype.ping = function() {
      var self2 = this;
      this.sendPacket("ping", function() {
        self2.emit("ping");
      });
    };
    Socket2.prototype.onDrain = function() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (0 === this.writeBuffer.length) {
        this.emit("drain");
      } else {
        this.flush();
      }
    };
    Socket2.prototype.flush = function() {
      if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        debug("flushing %d packets in socket", this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        this.prevBufferLen = this.writeBuffer.length;
        this.emit("flush");
      }
    };
    Socket2.prototype.write = Socket2.prototype.send = function(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    };
    Socket2.prototype.sendPacket = function(type, data, options, fn) {
      if ("function" === typeof data) {
        fn = data;
        data = void 0;
      }
      if ("function" === typeof options) {
        fn = options;
        options = null;
      }
      if ("closing" === this.readyState || "closed" === this.readyState) {
        return;
      }
      options = options || {};
      options.compress = false !== options.compress;
      var packet = {
        type,
        data,
        options
      };
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    };
    Socket2.prototype.close = function() {
      if ("opening" === this.readyState || "open" === this.readyState) {
        this.readyState = "closing";
        var self2 = this;
        if (this.writeBuffer.length) {
          this.once("drain", function() {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      function close() {
        self2.onClose("forced close");
        debug("socket closing - telling transport to close");
        self2.transport.close();
      }
      function cleanupAndClose() {
        self2.removeListener("upgrade", cleanupAndClose);
        self2.removeListener("upgradeError", cleanupAndClose);
        close();
      }
      function waitForUpgrade() {
        self2.once("upgrade", cleanupAndClose);
        self2.once("upgradeError", cleanupAndClose);
      }
      return this;
    };
    Socket2.prototype.onError = function(err) {
      debug("socket error %j", err);
      Socket2.priorWebsocketSuccess = false;
      this.emit("error", err);
      this.onClose("transport error", err);
    };
    Socket2.prototype.onClose = function(reason, desc) {
      if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
        debug('socket close with reason: "%s"', reason);
        var self2 = this;
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        this.readyState = "closed";
        this.id = null;
        this.emit("close", reason, desc);
        self2.writeBuffer = [];
        self2.prevBufferLen = 0;
      }
    };
    Socket2.prototype.filterUpgrades = function(upgrades) {
      var filteredUpgrades = [];
      for (var i = 0, j = upgrades.length; i < j; i++) {
        if (~index(this.transports, upgrades[i]))
          filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    };
  }
});

// node_modules/@filen/sdk/node_modules/engine.io-client/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@filen/sdk/node_modules/engine.io-client/lib/index.js"(exports, module) {
    module.exports = require_socket2();
    module.exports.parser = require_browser4();
  }
});

// node_modules/to-array/index.js
var require_to_array = __commonJS({
  "node_modules/to-array/index.js"(exports, module) {
    module.exports = toArray;
    function toArray(list, index) {
      var array = [];
      index = index || 0;
      for (var i = index || 0; i < list.length; i++) {
        array[i - index] = list[i];
      }
      return array;
    }
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-client/lib/on.js
var require_on = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-client/lib/on.js"(exports, module) {
    module.exports = on;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return {
        destroy: function() {
          obj.removeListener(ev, fn);
        }
      };
    }
  }
});

// node_modules/component-bind/index.js
var require_component_bind = __commonJS({
  "node_modules/component-bind/index.js"(exports, module) {
    var slice = [].slice;
    module.exports = function(obj, fn) {
      if ("string" == typeof fn)
        fn = obj[fn];
      if ("function" != typeof fn)
        throw new Error("bind() requires a function");
      var args = slice.call(arguments, 2);
      return function() {
        return fn.apply(obj, args.concat(slice.call(arguments)));
      };
    };
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-client/lib/socket.js
var require_socket3 = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-client/lib/socket.js"(exports, module) {
    var parser = require_socket();
    var Emitter = require_component_emitter();
    var toArray = require_to_array();
    var on = require_on();
    var bind = require_component_bind();
    var debug = require_browser3()("socket.io-client:socket");
    var parseqs = require_parseqs();
    var hasBin = require_has_binary2();
    module.exports = exports = Socket2;
    var events = {
      connect: 1,
      connect_error: 1,
      connect_timeout: 1,
      connecting: 1,
      disconnect: 1,
      error: 1,
      reconnect: 1,
      reconnect_attempt: 1,
      reconnect_failed: 1,
      reconnect_error: 1,
      reconnecting: 1,
      ping: 1,
      pong: 1
    };
    var emit = Emitter.prototype.emit;
    function Socket2(io2, nsp, opts) {
      this.io = io2;
      this.nsp = nsp;
      this.json = this;
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      this.flags = {};
      if (opts && opts.query) {
        this.query = opts.query;
      }
      if (this.io.autoConnect)
        this.open();
    }
    Emitter(Socket2.prototype);
    Socket2.prototype.subEvents = function() {
      if (this.subs)
        return;
      var io2 = this.io;
      this.subs = [
        on(io2, "open", bind(this, "onopen")),
        on(io2, "packet", bind(this, "onpacket")),
        on(io2, "close", bind(this, "onclose"))
      ];
    };
    Socket2.prototype.open = Socket2.prototype.connect = function() {
      if (this.connected)
        return this;
      this.subEvents();
      if (!this.io.reconnecting)
        this.io.open();
      if ("open" === this.io.readyState)
        this.onopen();
      this.emit("connecting");
      return this;
    };
    Socket2.prototype.send = function() {
      var args = toArray(arguments);
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    };
    Socket2.prototype.emit = function(ev) {
      if (events.hasOwnProperty(ev)) {
        emit.apply(this, arguments);
        return this;
      }
      var args = toArray(arguments);
      var packet = {
        type: (this.flags.binary !== void 0 ? this.flags.binary : hasBin(args)) ? parser.BINARY_EVENT : parser.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = !this.flags || false !== this.flags.compress;
      if ("function" === typeof args[args.length - 1]) {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }
      if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    };
    Socket2.prototype.packet = function(packet) {
      packet.nsp = this.nsp;
      this.io.packet(packet);
    };
    Socket2.prototype.onopen = function() {
      debug("transport is open - connecting");
      if ("/" !== this.nsp) {
        if (this.query) {
          var query = typeof this.query === "object" ? parseqs.encode(this.query) : this.query;
          debug("sending connect packet with query %s", query);
          this.packet({ type: parser.CONNECT, query });
        } else {
          this.packet({ type: parser.CONNECT });
        }
      }
    };
    Socket2.prototype.onclose = function(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      this.emit("disconnect", reason);
    };
    Socket2.prototype.onpacket = function(packet) {
      var sameNamespace = packet.nsp === this.nsp;
      var rootNamespaceError = packet.type === parser.ERROR && packet.nsp === "/";
      if (!sameNamespace && !rootNamespaceError)
        return;
      switch (packet.type) {
        case parser.CONNECT:
          this.onconnect();
          break;
        case parser.EVENT:
          this.onevent(packet);
          break;
        case parser.BINARY_EVENT:
          this.onevent(packet);
          break;
        case parser.ACK:
          this.onack(packet);
          break;
        case parser.BINARY_ACK:
          this.onack(packet);
          break;
        case parser.DISCONNECT:
          this.ondisconnect();
          break;
        case parser.ERROR:
          this.emit("error", packet.data);
          break;
      }
    };
    Socket2.prototype.onevent = function(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);
      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        emit.apply(this, args);
      } else {
        this.receiveBuffer.push(args);
      }
    };
    Socket2.prototype.ack = function(id) {
      var self2 = this;
      var sent = false;
      return function() {
        if (sent)
          return;
        sent = true;
        var args = toArray(arguments);
        debug("sending ack %j", args);
        self2.packet({
          type: hasBin(args) ? parser.BINARY_ACK : parser.ACK,
          id,
          data: args
        });
      };
    };
    Socket2.prototype.onack = function(packet) {
      var ack = this.acks[packet.id];
      if ("function" === typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug("bad ack %s", packet.id);
      }
    };
    Socket2.prototype.onconnect = function() {
      this.connected = true;
      this.disconnected = false;
      this.emitBuffered();
      this.emit("connect");
    };
    Socket2.prototype.emitBuffered = function() {
      var i;
      for (i = 0; i < this.receiveBuffer.length; i++) {
        emit.apply(this, this.receiveBuffer[i]);
      }
      this.receiveBuffer = [];
      for (i = 0; i < this.sendBuffer.length; i++) {
        this.packet(this.sendBuffer[i]);
      }
      this.sendBuffer = [];
    };
    Socket2.prototype.ondisconnect = function() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    };
    Socket2.prototype.destroy = function() {
      if (this.subs) {
        for (var i = 0; i < this.subs.length; i++) {
          this.subs[i].destroy();
        }
        this.subs = null;
      }
      this.io.destroy(this);
    };
    Socket2.prototype.close = Socket2.prototype.disconnect = function() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({ type: parser.DISCONNECT });
      }
      this.destroy();
      if (this.connected) {
        this.onclose("io client disconnect");
      }
      return this;
    };
    Socket2.prototype.compress = function(compress) {
      this.flags.compress = compress;
      return this;
    };
    Socket2.prototype.binary = function(binary) {
      this.flags.binary = binary;
      return this;
    };
  }
});

// node_modules/backo2/index.js
var require_backo2 = __commonJS({
  "node_modules/backo2/index.js"(exports, module) {
    module.exports = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 1e4;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-client/lib/manager.js
var require_manager = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-client/lib/manager.js"(exports, module) {
    var eio = require_lib2();
    var Socket2 = require_socket3();
    var Emitter = require_component_emitter();
    var parser = require_socket();
    var on = require_on();
    var bind = require_component_bind();
    var debug = require_browser3()("socket.io-client:manager");
    var indexOf = require_indexof();
    var Backoff = require_backo2();
    var has = Object.prototype.hasOwnProperty;
    module.exports = Manager;
    function Manager(uri, opts) {
      if (!(this instanceof Manager))
        return new Manager(uri, opts);
      if (uri && "object" === typeof uri) {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.nsps = {};
      this.subs = [];
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
      this.readyState = "closed";
      this.uri = uri;
      this.connecting = [];
      this.lastPing = null;
      this.encoding = false;
      this.packetBuffer = [];
      var _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this.autoConnect = opts.autoConnect !== false;
      if (this.autoConnect)
        this.open();
    }
    Manager.prototype.emitAll = function() {
      this.emit.apply(this, arguments);
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].emit.apply(this.nsps[nsp], arguments);
        }
      }
    };
    Manager.prototype.updateSocketIds = function() {
      for (var nsp in this.nsps) {
        if (has.call(this.nsps, nsp)) {
          this.nsps[nsp].id = this.generateId(nsp);
        }
      }
    };
    Manager.prototype.generateId = function(nsp) {
      return (nsp === "/" ? "" : nsp + "#") + this.engine.id;
    };
    Emitter(Manager.prototype);
    Manager.prototype.reconnection = function(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    };
    Manager.prototype.reconnectionAttempts = function(v) {
      if (!arguments.length)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    };
    Manager.prototype.reconnectionDelay = function(v) {
      if (!arguments.length)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      this.backoff && this.backoff.setMin(v);
      return this;
    };
    Manager.prototype.randomizationFactor = function(v) {
      if (!arguments.length)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      this.backoff && this.backoff.setJitter(v);
      return this;
    };
    Manager.prototype.reconnectionDelayMax = function(v) {
      if (!arguments.length)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      this.backoff && this.backoff.setMax(v);
      return this;
    };
    Manager.prototype.timeout = function(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    };
    Manager.prototype.maybeReconnectOnOpen = function() {
      if (!this.reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    };
    Manager.prototype.open = Manager.prototype.connect = function(fn, opts) {
      debug("readyState %s", this.readyState);
      if (~this.readyState.indexOf("open"))
        return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      var socket = this.engine;
      var self2 = this;
      this.readyState = "opening";
      this.skipReconnect = false;
      var openSub = on(socket, "open", function() {
        self2.onopen();
        fn && fn();
      });
      var errorSub = on(socket, "error", function(data) {
        debug("connect_error");
        self2.cleanup();
        self2.readyState = "closed";
        self2.emitAll("connect_error", data);
        if (fn) {
          var err = new Error("Connection error");
          err.data = data;
          fn(err);
        } else {
          self2.maybeReconnectOnOpen();
        }
      });
      if (false !== this._timeout) {
        var timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);
        if (timeout === 0) {
          openSub.destroy();
        }
        var timer = setTimeout(function() {
          debug("connect attempt timed out after %d", timeout);
          openSub.destroy();
          socket.close();
          socket.emit("error", "timeout");
          self2.emitAll("connect_timeout", timeout);
        }, timeout);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
      this.subs.push(openSub);
      this.subs.push(errorSub);
      return this;
    };
    Manager.prototype.onopen = function() {
      debug("open");
      this.cleanup();
      this.readyState = "open";
      this.emit("open");
      var socket = this.engine;
      this.subs.push(on(socket, "data", bind(this, "ondata")));
      this.subs.push(on(socket, "ping", bind(this, "onping")));
      this.subs.push(on(socket, "pong", bind(this, "onpong")));
      this.subs.push(on(socket, "error", bind(this, "onerror")));
      this.subs.push(on(socket, "close", bind(this, "onclose")));
      this.subs.push(on(this.decoder, "decoded", bind(this, "ondecoded")));
    };
    Manager.prototype.onping = function() {
      this.lastPing = /* @__PURE__ */ new Date();
      this.emitAll("ping");
    };
    Manager.prototype.onpong = function() {
      this.emitAll("pong", /* @__PURE__ */ new Date() - this.lastPing);
    };
    Manager.prototype.ondata = function(data) {
      this.decoder.add(data);
    };
    Manager.prototype.ondecoded = function(packet) {
      this.emit("packet", packet);
    };
    Manager.prototype.onerror = function(err) {
      debug("error", err);
      this.emitAll("error", err);
    };
    Manager.prototype.socket = function(nsp, opts) {
      var socket = this.nsps[nsp];
      if (!socket) {
        socket = new Socket2(this, nsp, opts);
        this.nsps[nsp] = socket;
        var self2 = this;
        socket.on("connecting", onConnecting);
        socket.on("connect", function() {
          socket.id = self2.generateId(nsp);
        });
        if (this.autoConnect) {
          onConnecting();
        }
      }
      function onConnecting() {
        if (!~indexOf(self2.connecting, socket)) {
          self2.connecting.push(socket);
        }
      }
      return socket;
    };
    Manager.prototype.destroy = function(socket) {
      var index = indexOf(this.connecting, socket);
      if (~index)
        this.connecting.splice(index, 1);
      if (this.connecting.length)
        return;
      this.close();
    };
    Manager.prototype.packet = function(packet) {
      debug("writing packet %j", packet);
      var self2 = this;
      if (packet.query && packet.type === 0)
        packet.nsp += "?" + packet.query;
      if (!self2.encoding) {
        self2.encoding = true;
        this.encoder.encode(packet, function(encodedPackets) {
          for (var i = 0; i < encodedPackets.length; i++) {
            self2.engine.write(encodedPackets[i], packet.options);
          }
          self2.encoding = false;
          self2.processPacketQueue();
        });
      } else {
        self2.packetBuffer.push(packet);
      }
    };
    Manager.prototype.processPacketQueue = function() {
      if (this.packetBuffer.length > 0 && !this.encoding) {
        var pack = this.packetBuffer.shift();
        this.packet(pack);
      }
    };
    Manager.prototype.cleanup = function() {
      debug("cleanup");
      var subsLength = this.subs.length;
      for (var i = 0; i < subsLength; i++) {
        var sub = this.subs.shift();
        sub.destroy();
      }
      this.packetBuffer = [];
      this.encoding = false;
      this.lastPing = null;
      this.decoder.destroy();
    };
    Manager.prototype.close = Manager.prototype.disconnect = function() {
      debug("disconnect");
      this.skipReconnect = true;
      this.reconnecting = false;
      if ("opening" === this.readyState) {
        this.cleanup();
      }
      this.backoff.reset();
      this.readyState = "closed";
      if (this.engine)
        this.engine.close();
    };
    Manager.prototype.onclose = function(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this.readyState = "closed";
      this.emit("close", reason);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    };
    Manager.prototype.reconnect = function() {
      if (this.reconnecting || this.skipReconnect)
        return this;
      var self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        this.emitAll("reconnect_failed");
        this.reconnecting = false;
      } else {
        var delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this.reconnecting = true;
        var timer = setTimeout(function() {
          if (self2.skipReconnect)
            return;
          debug("attempting reconnect");
          self2.emitAll("reconnect_attempt", self2.backoff.attempts);
          self2.emitAll("reconnecting", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open(function(err) {
            if (err) {
              debug("reconnect attempt error");
              self2.reconnecting = false;
              self2.reconnect();
              self2.emitAll("reconnect_error", err.data);
            } else {
              debug("reconnect success");
              self2.onreconnect();
            }
          });
        }, delay);
        this.subs.push({
          destroy: function() {
            clearTimeout(timer);
          }
        });
      }
    };
    Manager.prototype.onreconnect = function() {
      var attempt = this.backoff.attempts;
      this.reconnecting = false;
      this.backoff.reset();
      this.updateSocketIds();
      this.emitAll("reconnect", attempt);
    };
  }
});

// node_modules/@filen/sdk/node_modules/socket.io-client/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@filen/sdk/node_modules/socket.io-client/lib/index.js"(exports, module) {
    var url = require_url2();
    var parser = require_socket();
    var Manager = require_manager();
    var debug = require_browser3()("socket.io-client");
    module.exports = exports = lookup;
    var cache2 = exports.managers = {};
    function lookup(uri, opts) {
      if (typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      var parsed = url(uri);
      var source = parsed.source;
      var id = parsed.id;
      var path = parsed.path;
      var sameNamespace = cache2[id] && path in cache2[id].nsps;
      var newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
      var io2;
      if (newConnection) {
        debug("ignoring socket cache for %s", source);
        io2 = Manager(source, opts);
      } else {
        if (!cache2[id]) {
          debug("new io instance for %s", source);
          cache2[id] = Manager(source, opts);
        }
        io2 = cache2[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.query;
      }
      return io2.socket(parsed.path, opts);
    }
    exports.protocol = parser.protocol;
    exports.connect = lookup;
    exports.Manager = require_manager();
    exports.Socket = require_socket3();
  }
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS({
  "node_modules/imurmurhash/imurmurhash.js"(exports, module) {
    (function() {
      var cache2;
      function MurmurHash3(key, seed) {
        var m = this instanceof MurmurHash3 ? this : cache2;
        m.reset(seed);
        if (typeof key === "string" && key.length > 0) {
          m.hash(key);
        }
        if (m !== this) {
          return m;
        }
      }
      ;
      MurmurHash3.prototype.hash = function(key) {
        var h1, k1, i, top, len;
        len = key.length;
        this.len += len;
        k1 = this.k1;
        i = 0;
        switch (this.rem) {
          case 0:
            k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
          case 1:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
          case 2:
            k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
          case 3:
            k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
            k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
        }
        this.rem = len + this.rem & 3;
        len -= this.rem;
        if (len > 0) {
          h1 = this.h1;
          while (1) {
            k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196 & 4294967295;
            if (i >= len) {
              break;
            }
            k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
            top = key.charCodeAt(i++);
            k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
          }
          k1 = 0;
          switch (this.rem) {
            case 3:
              k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
            case 2:
              k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
            case 1:
              k1 ^= key.charCodeAt(i) & 65535;
          }
          this.h1 = h1;
        }
        this.k1 = k1;
        return this;
      };
      MurmurHash3.prototype.result = function() {
        var k1, h1;
        k1 = this.k1;
        h1 = this.h1;
        if (k1 > 0) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
        }
        h1 ^= this.len;
        h1 ^= h1 >>> 16;
        h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
        h1 ^= h1 >>> 13;
        h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
        h1 ^= h1 >>> 16;
        return h1 >>> 0;
      };
      MurmurHash3.prototype.reset = function(seed) {
        this.h1 = typeof seed === "number" ? seed : 0;
        this.rem = this.k1 = this.len = 0;
        return this;
      };
      cache2 = new MurmurHash3();
      if (typeof module != "undefined") {
        module.exports = MurmurHash3;
      } else {
        this.MurmurHash3 = MurmurHash3;
      }
    })();
  }
});

// node_modules/signal-exit/dist/cjs/signals.js
var require_signals = __commonJS({
  "node_modules/signal-exit/dist/cjs/signals.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.signals = void 0;
    exports.signals = [];
    exports.signals.push("SIGHUP", "SIGINT", "SIGTERM");
    if (process.platform !== "win32") {
      exports.signals.push(
        "SIGALRM",
        "SIGABRT",
        "SIGVTALRM",
        "SIGXCPU",
        "SIGXFSZ",
        "SIGUSR2",
        "SIGTRAP",
        "SIGSYS",
        "SIGQUIT",
        "SIGIOT"
        // should detect profiler and enable/disable accordingly.
        // see #21
        // 'SIGPROF'
      );
    }
    if (process.platform === "linux") {
      exports.signals.push("SIGIO", "SIGPOLL", "SIGPWR", "SIGSTKFLT");
    }
  }
});

// node_modules/signal-exit/dist/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/signal-exit/dist/cjs/index.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.unload = exports.load = exports.onExit = exports.signals = void 0;
    var signals_js_1 = require_signals();
    Object.defineProperty(exports, "signals", { enumerable: true, get: function() {
      return signals_js_1.signals;
    } });
    var processOk = (process3) => !!process3 && typeof process3 === "object" && typeof process3.removeListener === "function" && typeof process3.emit === "function" && typeof process3.reallyExit === "function" && typeof process3.listeners === "function" && typeof process3.kill === "function" && typeof process3.pid === "number" && typeof process3.on === "function";
    var kExitEmitter = Symbol.for("signal-exit emitter");
    var global2 = globalThis;
    var ObjectDefineProperty = Object.defineProperty.bind(Object);
    var Emitter = class {
      constructor() {
        __publicField(this, "emitted", {
          afterExit: false,
          exit: false
        });
        __publicField(this, "listeners", {
          afterExit: [],
          exit: []
        });
        __publicField(this, "count", 0);
        __publicField(this, "id", Math.random());
        if (global2[kExitEmitter]) {
          return global2[kExitEmitter];
        }
        ObjectDefineProperty(global2, kExitEmitter, {
          value: this,
          writable: false,
          enumerable: false,
          configurable: false
        });
      }
      on(ev, fn) {
        this.listeners[ev].push(fn);
      }
      removeListener(ev, fn) {
        const list = this.listeners[ev];
        const i = list.indexOf(fn);
        if (i === -1) {
          return;
        }
        if (i === 0 && list.length === 1) {
          list.length = 0;
        } else {
          list.splice(i, 1);
        }
      }
      emit(ev, code, signal) {
        if (this.emitted[ev]) {
          return false;
        }
        this.emitted[ev] = true;
        let ret = false;
        for (const fn of this.listeners[ev]) {
          ret = fn(code, signal) === true || ret;
        }
        if (ev === "exit") {
          ret = this.emit("afterExit", code, signal) || ret;
        }
        return ret;
      }
    };
    var SignalExitBase = class {
    };
    var signalExitWrap = (handler) => {
      return {
        onExit(cb, opts) {
          return handler.onExit(cb, opts);
        },
        load() {
          return handler.load();
        },
        unload() {
          return handler.unload();
        }
      };
    };
    var SignalExitFallback = class extends SignalExitBase {
      onExit() {
        return () => {
        };
      }
      load() {
      }
      unload() {
      }
    };
    var _hupSig, _emitter, _process, _originalProcessEmit, _originalProcessReallyExit, _sigListeners, _loaded, _processReallyExit, processReallyExit_fn, _processEmit, processEmit_fn;
    var SignalExit = class extends SignalExitBase {
      constructor(process3) {
        super();
        __privateAdd(this, _processReallyExit);
        __privateAdd(this, _processEmit);
        // "SIGHUP" throws an `ENOSYS` error on Windows,
        // so use a supported signal instead
        /* c8 ignore start */
        __privateAdd(this, _hupSig, process2.platform === "win32" ? "SIGINT" : "SIGHUP");
        /* c8 ignore stop */
        __privateAdd(this, _emitter, new Emitter());
        __privateAdd(this, _process, void 0);
        __privateAdd(this, _originalProcessEmit, void 0);
        __privateAdd(this, _originalProcessReallyExit, void 0);
        __privateAdd(this, _sigListeners, {});
        __privateAdd(this, _loaded, false);
        __privateSet(this, _process, process3);
        __privateSet(this, _sigListeners, {});
        for (const sig of signals_js_1.signals) {
          __privateGet(this, _sigListeners)[sig] = () => {
            const listeners = __privateGet(this, _process).listeners(sig);
            let { count } = __privateGet(this, _emitter);
            const p = process3;
            if (typeof p.__signal_exit_emitter__ === "object" && typeof p.__signal_exit_emitter__.count === "number") {
              count += p.__signal_exit_emitter__.count;
            }
            if (listeners.length === count) {
              this.unload();
              const ret = __privateGet(this, _emitter).emit("exit", null, sig);
              const s = sig === "SIGHUP" ? __privateGet(this, _hupSig) : sig;
              if (!ret)
                process3.kill(process3.pid, s);
            }
          };
        }
        __privateSet(this, _originalProcessReallyExit, process3.reallyExit);
        __privateSet(this, _originalProcessEmit, process3.emit);
      }
      onExit(cb, opts) {
        if (!processOk(__privateGet(this, _process))) {
          return () => {
          };
        }
        if (__privateGet(this, _loaded) === false) {
          this.load();
        }
        const ev = (opts == null ? void 0 : opts.alwaysLast) ? "afterExit" : "exit";
        __privateGet(this, _emitter).on(ev, cb);
        return () => {
          __privateGet(this, _emitter).removeListener(ev, cb);
          if (__privateGet(this, _emitter).listeners["exit"].length === 0 && __privateGet(this, _emitter).listeners["afterExit"].length === 0) {
            this.unload();
          }
        };
      }
      load() {
        if (__privateGet(this, _loaded)) {
          return;
        }
        __privateSet(this, _loaded, true);
        __privateGet(this, _emitter).count += 1;
        for (const sig of signals_js_1.signals) {
          try {
            const fn = __privateGet(this, _sigListeners)[sig];
            if (fn)
              __privateGet(this, _process).on(sig, fn);
          } catch (_) {
          }
        }
        __privateGet(this, _process).emit = (ev, ...a) => {
          return __privateMethod(this, _processEmit, processEmit_fn).call(this, ev, ...a);
        };
        __privateGet(this, _process).reallyExit = (code) => {
          return __privateMethod(this, _processReallyExit, processReallyExit_fn).call(this, code);
        };
      }
      unload() {
        if (!__privateGet(this, _loaded)) {
          return;
        }
        __privateSet(this, _loaded, false);
        signals_js_1.signals.forEach((sig) => {
          const listener = __privateGet(this, _sigListeners)[sig];
          if (!listener) {
            throw new Error("Listener not defined for signal: " + sig);
          }
          try {
            __privateGet(this, _process).removeListener(sig, listener);
          } catch (_) {
          }
        });
        __privateGet(this, _process).emit = __privateGet(this, _originalProcessEmit);
        __privateGet(this, _process).reallyExit = __privateGet(this, _originalProcessReallyExit);
        __privateGet(this, _emitter).count -= 1;
      }
    };
    _hupSig = new WeakMap();
    _emitter = new WeakMap();
    _process = new WeakMap();
    _originalProcessEmit = new WeakMap();
    _originalProcessReallyExit = new WeakMap();
    _sigListeners = new WeakMap();
    _loaded = new WeakMap();
    _processReallyExit = new WeakSet();
    processReallyExit_fn = function(code) {
      if (!processOk(__privateGet(this, _process))) {
        return 0;
      }
      __privateGet(this, _process).exitCode = code || 0;
      __privateGet(this, _emitter).emit("exit", __privateGet(this, _process).exitCode, null);
      return __privateGet(this, _originalProcessReallyExit).call(__privateGet(this, _process), __privateGet(this, _process).exitCode);
    };
    _processEmit = new WeakSet();
    processEmit_fn = function(ev, ...args) {
      const og = __privateGet(this, _originalProcessEmit);
      if (ev === "exit" && processOk(__privateGet(this, _process))) {
        if (typeof args[0] === "number") {
          __privateGet(this, _process).exitCode = args[0];
        }
        const ret = og.call(__privateGet(this, _process), ev, ...args);
        __privateGet(this, _emitter).emit("exit", __privateGet(this, _process).exitCode, null);
        return ret;
      } else {
        return og.call(__privateGet(this, _process), ev, ...args);
      }
    };
    var process2 = globalThis.process;
    _a = signalExitWrap(processOk(process2) ? new SignalExit(process2) : new SignalExitFallback()), /**
     * Called when the process is exiting, whether via signal, explicit
     * exit, or running out of stuff to do.
     *
     * If the global process object is not suitable for instrumentation,
     * then this will be a no-op.
     *
     * Returns a function that may be used to unload signal-exit.
     */
    exports.onExit = _a.onExit, /**
     * Load the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports.load = _a.load, /**
     * Unload the listeners.  Likely you never need to call this, unless
     * doing a rather deep integration with signal-exit functionality.
     * Mostly exposed for the benefit of testing.
     *
     * @internal
     */
    exports.unload = _a.unload;
  }
});

// browser-external:worker_threads
var require_worker_threads = __commonJS({
  "browser-external:worker_threads"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "worker_threads" has been externalized for browser compatibility. Cannot access "worker_threads.${key}" in client code. See https://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/write-file-atomic/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/write-file-atomic/lib/index.js"(exports, module) {
    "use strict";
    module.exports = writeFile;
    module.exports.sync = writeFileSync;
    module.exports._getTmpname = getTmpname;
    module.exports._cleanupOnExit = cleanupOnExit;
    var fs10 = require_fs();
    var MurmurHash3 = require_imurmurhash();
    var { onExit } = require_cjs();
    var path = require_path();
    var { promisify: promisify7 } = require_util();
    var activeFiles = {};
    var threadId = function getId() {
      try {
        const workerThreads = require_worker_threads();
        return workerThreads.threadId;
      } catch (e) {
        return 0;
      }
    }();
    var invocations = 0;
    function getTmpname(filename) {
      return filename + "." + MurmurHash3(__filename).hash(String(process.pid)).hash(String(threadId)).hash(String(++invocations)).result();
    }
    function cleanupOnExit(tmpfile) {
      return () => {
        try {
          fs10.unlinkSync(typeof tmpfile === "function" ? tmpfile() : tmpfile);
        } catch {
        }
      };
    }
    function serializeActiveFile(absoluteName) {
      return new Promise((resolve) => {
        if (!activeFiles[absoluteName]) {
          activeFiles[absoluteName] = [];
        }
        activeFiles[absoluteName].push(resolve);
        if (activeFiles[absoluteName].length === 1) {
          resolve();
        }
      });
    }
    function isChownErrOk(err) {
      if (err.code === "ENOSYS") {
        return true;
      }
      const nonroot = !process.getuid || process.getuid() !== 0;
      if (nonroot) {
        if (err.code === "EINVAL" || err.code === "EPERM") {
          return true;
        }
      }
      return false;
    }
    async function writeFileAsync(filename, data, options = {}) {
      if (typeof options === "string") {
        options = { encoding: options };
      }
      let fd;
      let tmpfile;
      const removeOnExitHandler = onExit(cleanupOnExit(() => tmpfile));
      const absoluteName = path.resolve(filename);
      try {
        await serializeActiveFile(absoluteName);
        const truename = await promisify7(fs10.realpath)(filename).catch(() => filename);
        tmpfile = getTmpname(truename);
        if (!options.mode || !options.chown) {
          const stats = await promisify7(fs10.stat)(truename).catch(() => {
          });
          if (stats) {
            if (options.mode == null) {
              options.mode = stats.mode;
            }
            if (options.chown == null && process.getuid) {
              options.chown = { uid: stats.uid, gid: stats.gid };
            }
          }
        }
        fd = await promisify7(fs10.open)(tmpfile, "w", options.mode);
        if (options.tmpfileCreated) {
          await options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          await promisify7(fs10.write)(fd, data, 0, data.length, 0);
        } else if (data != null) {
          await promisify7(fs10.write)(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          await promisify7(fs10.fsync)(fd);
        }
        await promisify7(fs10.close)(fd);
        fd = null;
        if (options.chown) {
          await promisify7(fs10.chown)(tmpfile, options.chown.uid, options.chown.gid).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        if (options.mode) {
          await promisify7(fs10.chmod)(tmpfile, options.mode).catch((err) => {
            if (!isChownErrOk(err)) {
              throw err;
            }
          });
        }
        await promisify7(fs10.rename)(tmpfile, truename);
      } finally {
        if (fd) {
          await promisify7(fs10.close)(fd).catch(
            /* istanbul ignore next */
            () => {
            }
          );
        }
        removeOnExitHandler();
        await promisify7(fs10.unlink)(tmpfile).catch(() => {
        });
        activeFiles[absoluteName].shift();
        if (activeFiles[absoluteName].length > 0) {
          activeFiles[absoluteName][0]();
        } else {
          delete activeFiles[absoluteName];
        }
      }
    }
    async function writeFile(filename, data, options, callback) {
      if (options instanceof Function) {
        callback = options;
        options = {};
      }
      const promise = writeFileAsync(filename, data, options);
      if (callback) {
        try {
          const result = await promise;
          return callback(result);
        } catch (err) {
          return callback(err);
        }
      }
      return promise;
    }
    function writeFileSync(filename, data, options) {
      if (typeof options === "string") {
        options = { encoding: options };
      } else if (!options) {
        options = {};
      }
      try {
        filename = fs10.realpathSync(filename);
      } catch (ex) {
      }
      const tmpfile = getTmpname(filename);
      if (!options.mode || !options.chown) {
        try {
          const stats = fs10.statSync(filename);
          options = Object.assign({}, options);
          if (!options.mode) {
            options.mode = stats.mode;
          }
          if (!options.chown && process.getuid) {
            options.chown = { uid: stats.uid, gid: stats.gid };
          }
        } catch (ex) {
        }
      }
      let fd;
      const cleanup = cleanupOnExit(tmpfile);
      const removeOnExitHandler = onExit(cleanup);
      let threw = true;
      try {
        fd = fs10.openSync(tmpfile, "w", options.mode || 438);
        if (options.tmpfileCreated) {
          options.tmpfileCreated(tmpfile);
        }
        if (ArrayBuffer.isView(data)) {
          fs10.writeSync(fd, data, 0, data.length, 0);
        } else if (data != null) {
          fs10.writeSync(fd, String(data), 0, String(options.encoding || "utf8"));
        }
        if (options.fsync !== false) {
          fs10.fsyncSync(fd);
        }
        fs10.closeSync(fd);
        fd = null;
        if (options.chown) {
          try {
            fs10.chownSync(tmpfile, options.chown.uid, options.chown.gid);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        if (options.mode) {
          try {
            fs10.chmodSync(tmpfile, options.mode);
          } catch (err) {
            if (!isChownErrOk(err)) {
              throw err;
            }
          }
        }
        fs10.renameSync(tmpfile, filename);
        threw = false;
      } finally {
        if (fd) {
          try {
            fs10.closeSync(fd);
          } catch (ex) {
          }
        }
        removeOnExitHandler();
        if (threw) {
          cleanup();
        }
      }
    }
  }
});

// node_modules/mime-db/db.json
var require_db = __commonJS({
  "node_modules/mime-db/db.json"(exports, module) {
    module.exports = {
      "application/1d-interleaved-parityfec": {
        source: "iana"
      },
      "application/3gpdash-qoe-report+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/3gpp-ims+xml": {
        source: "iana",
        compressible: true
      },
      "application/3gpphal+json": {
        source: "iana",
        compressible: true
      },
      "application/3gpphalforms+json": {
        source: "iana",
        compressible: true
      },
      "application/a2l": {
        source: "iana"
      },
      "application/ace+cbor": {
        source: "iana"
      },
      "application/activemessage": {
        source: "iana"
      },
      "application/activity+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-costmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-directory+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcost+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointcostparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointprop+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-endpointpropparams+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-error+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmap+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-networkmapfilter+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamcontrol+json": {
        source: "iana",
        compressible: true
      },
      "application/alto-updatestreamparams+json": {
        source: "iana",
        compressible: true
      },
      "application/aml": {
        source: "iana"
      },
      "application/andrew-inset": {
        source: "iana",
        extensions: ["ez"]
      },
      "application/applefile": {
        source: "iana"
      },
      "application/applixware": {
        source: "apache",
        extensions: ["aw"]
      },
      "application/at+jwt": {
        source: "iana"
      },
      "application/atf": {
        source: "iana"
      },
      "application/atfx": {
        source: "iana"
      },
      "application/atom+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atom"]
      },
      "application/atomcat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomcat"]
      },
      "application/atomdeleted+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomdeleted"]
      },
      "application/atomicmail": {
        source: "iana"
      },
      "application/atomsvc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["atomsvc"]
      },
      "application/atsc-dwd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dwd"]
      },
      "application/atsc-dynamic-event-message": {
        source: "iana"
      },
      "application/atsc-held+xml": {
        source: "iana",
        compressible: true,
        extensions: ["held"]
      },
      "application/atsc-rdt+json": {
        source: "iana",
        compressible: true
      },
      "application/atsc-rsat+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsat"]
      },
      "application/atxml": {
        source: "iana"
      },
      "application/auth-policy+xml": {
        source: "iana",
        compressible: true
      },
      "application/bacnet-xdd+zip": {
        source: "iana",
        compressible: false
      },
      "application/batch-smtp": {
        source: "iana"
      },
      "application/bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/beep+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/calendar+json": {
        source: "iana",
        compressible: true
      },
      "application/calendar+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xcs"]
      },
      "application/call-completion": {
        source: "iana"
      },
      "application/cals-1840": {
        source: "iana"
      },
      "application/captive+json": {
        source: "iana",
        compressible: true
      },
      "application/cbor": {
        source: "iana"
      },
      "application/cbor-seq": {
        source: "iana"
      },
      "application/cccex": {
        source: "iana"
      },
      "application/ccmp+xml": {
        source: "iana",
        compressible: true
      },
      "application/ccxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ccxml"]
      },
      "application/cdfx+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdfx"]
      },
      "application/cdmi-capability": {
        source: "iana",
        extensions: ["cdmia"]
      },
      "application/cdmi-container": {
        source: "iana",
        extensions: ["cdmic"]
      },
      "application/cdmi-domain": {
        source: "iana",
        extensions: ["cdmid"]
      },
      "application/cdmi-object": {
        source: "iana",
        extensions: ["cdmio"]
      },
      "application/cdmi-queue": {
        source: "iana",
        extensions: ["cdmiq"]
      },
      "application/cdni": {
        source: "iana"
      },
      "application/cea": {
        source: "iana"
      },
      "application/cea-2018+xml": {
        source: "iana",
        compressible: true
      },
      "application/cellml+xml": {
        source: "iana",
        compressible: true
      },
      "application/cfw": {
        source: "iana"
      },
      "application/city+json": {
        source: "iana",
        compressible: true
      },
      "application/clr": {
        source: "iana"
      },
      "application/clue+xml": {
        source: "iana",
        compressible: true
      },
      "application/clue_info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cms": {
        source: "iana"
      },
      "application/cnrp+xml": {
        source: "iana",
        compressible: true
      },
      "application/coap-group+json": {
        source: "iana",
        compressible: true
      },
      "application/coap-payload": {
        source: "iana"
      },
      "application/commonground": {
        source: "iana"
      },
      "application/conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/cose": {
        source: "iana"
      },
      "application/cose-key": {
        source: "iana"
      },
      "application/cose-key-set": {
        source: "iana"
      },
      "application/cpl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cpl"]
      },
      "application/csrattrs": {
        source: "iana"
      },
      "application/csta+xml": {
        source: "iana",
        compressible: true
      },
      "application/cstadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/csvm+json": {
        source: "iana",
        compressible: true
      },
      "application/cu-seeme": {
        source: "apache",
        extensions: ["cu"]
      },
      "application/cwt": {
        source: "iana"
      },
      "application/cybercash": {
        source: "iana"
      },
      "application/dart": {
        compressible: true
      },
      "application/dash+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpd"]
      },
      "application/dash-patch+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpp"]
      },
      "application/dashdelta": {
        source: "iana"
      },
      "application/davmount+xml": {
        source: "iana",
        compressible: true,
        extensions: ["davmount"]
      },
      "application/dca-rft": {
        source: "iana"
      },
      "application/dcd": {
        source: "iana"
      },
      "application/dec-dx": {
        source: "iana"
      },
      "application/dialog-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/dicom": {
        source: "iana"
      },
      "application/dicom+json": {
        source: "iana",
        compressible: true
      },
      "application/dicom+xml": {
        source: "iana",
        compressible: true
      },
      "application/dii": {
        source: "iana"
      },
      "application/dit": {
        source: "iana"
      },
      "application/dns": {
        source: "iana"
      },
      "application/dns+json": {
        source: "iana",
        compressible: true
      },
      "application/dns-message": {
        source: "iana"
      },
      "application/docbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dbk"]
      },
      "application/dots+cbor": {
        source: "iana"
      },
      "application/dskpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/dssc+der": {
        source: "iana",
        extensions: ["dssc"]
      },
      "application/dssc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdssc"]
      },
      "application/dvcs": {
        source: "iana"
      },
      "application/ecmascript": {
        source: "iana",
        compressible: true,
        extensions: ["es", "ecma"]
      },
      "application/edi-consent": {
        source: "iana"
      },
      "application/edi-x12": {
        source: "iana",
        compressible: false
      },
      "application/edifact": {
        source: "iana",
        compressible: false
      },
      "application/efi": {
        source: "iana"
      },
      "application/elm+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/elm+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.cap+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/emergencycalldata.comment+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.control+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.deviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.ecall.msd": {
        source: "iana"
      },
      "application/emergencycalldata.providerinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.serviceinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.subscriberinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/emergencycalldata.veds+xml": {
        source: "iana",
        compressible: true
      },
      "application/emma+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emma"]
      },
      "application/emotionml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["emotionml"]
      },
      "application/encaprtp": {
        source: "iana"
      },
      "application/epp+xml": {
        source: "iana",
        compressible: true
      },
      "application/epub+zip": {
        source: "iana",
        compressible: false,
        extensions: ["epub"]
      },
      "application/eshop": {
        source: "iana"
      },
      "application/exi": {
        source: "iana",
        extensions: ["exi"]
      },
      "application/expect-ct-report+json": {
        source: "iana",
        compressible: true
      },
      "application/express": {
        source: "iana",
        extensions: ["exp"]
      },
      "application/fastinfoset": {
        source: "iana"
      },
      "application/fastsoap": {
        source: "iana"
      },
      "application/fdt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fdt"]
      },
      "application/fhir+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fhir+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/fido.trusted-apps+json": {
        compressible: true
      },
      "application/fits": {
        source: "iana"
      },
      "application/flexfec": {
        source: "iana"
      },
      "application/font-sfnt": {
        source: "iana"
      },
      "application/font-tdpfr": {
        source: "iana",
        extensions: ["pfr"]
      },
      "application/font-woff": {
        source: "iana",
        compressible: false
      },
      "application/framework-attributes+xml": {
        source: "iana",
        compressible: true
      },
      "application/geo+json": {
        source: "iana",
        compressible: true,
        extensions: ["geojson"]
      },
      "application/geo+json-seq": {
        source: "iana"
      },
      "application/geopackage+sqlite3": {
        source: "iana"
      },
      "application/geoxacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/gltf-buffer": {
        source: "iana"
      },
      "application/gml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["gml"]
      },
      "application/gpx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["gpx"]
      },
      "application/gxf": {
        source: "apache",
        extensions: ["gxf"]
      },
      "application/gzip": {
        source: "iana",
        compressible: false,
        extensions: ["gz"]
      },
      "application/h224": {
        source: "iana"
      },
      "application/held+xml": {
        source: "iana",
        compressible: true
      },
      "application/hjson": {
        extensions: ["hjson"]
      },
      "application/http": {
        source: "iana"
      },
      "application/hyperstudio": {
        source: "iana",
        extensions: ["stk"]
      },
      "application/ibe-key-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pkg-reply+xml": {
        source: "iana",
        compressible: true
      },
      "application/ibe-pp-data": {
        source: "iana"
      },
      "application/iges": {
        source: "iana"
      },
      "application/im-iscomposing+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/index": {
        source: "iana"
      },
      "application/index.cmd": {
        source: "iana"
      },
      "application/index.obj": {
        source: "iana"
      },
      "application/index.response": {
        source: "iana"
      },
      "application/index.vnd": {
        source: "iana"
      },
      "application/inkml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ink", "inkml"]
      },
      "application/iotp": {
        source: "iana"
      },
      "application/ipfix": {
        source: "iana",
        extensions: ["ipfix"]
      },
      "application/ipp": {
        source: "iana"
      },
      "application/isup": {
        source: "iana"
      },
      "application/its+xml": {
        source: "iana",
        compressible: true,
        extensions: ["its"]
      },
      "application/java-archive": {
        source: "apache",
        compressible: false,
        extensions: ["jar", "war", "ear"]
      },
      "application/java-serialized-object": {
        source: "apache",
        compressible: false,
        extensions: ["ser"]
      },
      "application/java-vm": {
        source: "apache",
        compressible: false,
        extensions: ["class"]
      },
      "application/javascript": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["js", "mjs"]
      },
      "application/jf2feed+json": {
        source: "iana",
        compressible: true
      },
      "application/jose": {
        source: "iana"
      },
      "application/jose+json": {
        source: "iana",
        compressible: true
      },
      "application/jrd+json": {
        source: "iana",
        compressible: true
      },
      "application/jscalendar+json": {
        source: "iana",
        compressible: true
      },
      "application/json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["json", "map"]
      },
      "application/json-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/json-seq": {
        source: "iana"
      },
      "application/json5": {
        extensions: ["json5"]
      },
      "application/jsonml+json": {
        source: "apache",
        compressible: true,
        extensions: ["jsonml"]
      },
      "application/jwk+json": {
        source: "iana",
        compressible: true
      },
      "application/jwk-set+json": {
        source: "iana",
        compressible: true
      },
      "application/jwt": {
        source: "iana"
      },
      "application/kpml-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/kpml-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/ld+json": {
        source: "iana",
        compressible: true,
        extensions: ["jsonld"]
      },
      "application/lgr+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lgr"]
      },
      "application/link-format": {
        source: "iana"
      },
      "application/load-control+xml": {
        source: "iana",
        compressible: true
      },
      "application/lost+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lostxml"]
      },
      "application/lostsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/lpf+zip": {
        source: "iana",
        compressible: false
      },
      "application/lxf": {
        source: "iana"
      },
      "application/mac-binhex40": {
        source: "iana",
        extensions: ["hqx"]
      },
      "application/mac-compactpro": {
        source: "apache",
        extensions: ["cpt"]
      },
      "application/macwriteii": {
        source: "iana"
      },
      "application/mads+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mads"]
      },
      "application/manifest+json": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["webmanifest"]
      },
      "application/marc": {
        source: "iana",
        extensions: ["mrc"]
      },
      "application/marcxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mrcx"]
      },
      "application/mathematica": {
        source: "iana",
        extensions: ["ma", "nb", "mb"]
      },
      "application/mathml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mathml"]
      },
      "application/mathml-content+xml": {
        source: "iana",
        compressible: true
      },
      "application/mathml-presentation+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-associated-procedure-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-deregister+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-envelope+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-msk-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-protection-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-reception-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-register-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-schedule+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbms-user-service-description+xml": {
        source: "iana",
        compressible: true
      },
      "application/mbox": {
        source: "iana",
        extensions: ["mbox"]
      },
      "application/media-policy-dataset+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpf"]
      },
      "application/media_control+xml": {
        source: "iana",
        compressible: true
      },
      "application/mediaservercontrol+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mscml"]
      },
      "application/merge-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/metalink+xml": {
        source: "apache",
        compressible: true,
        extensions: ["metalink"]
      },
      "application/metalink4+xml": {
        source: "iana",
        compressible: true,
        extensions: ["meta4"]
      },
      "application/mets+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mets"]
      },
      "application/mf4": {
        source: "iana"
      },
      "application/mikey": {
        source: "iana"
      },
      "application/mipc": {
        source: "iana"
      },
      "application/missing-blocks+cbor-seq": {
        source: "iana"
      },
      "application/mmt-aei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["maei"]
      },
      "application/mmt-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musd"]
      },
      "application/mods+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mods"]
      },
      "application/moss-keys": {
        source: "iana"
      },
      "application/moss-signature": {
        source: "iana"
      },
      "application/mosskey-data": {
        source: "iana"
      },
      "application/mosskey-request": {
        source: "iana"
      },
      "application/mp21": {
        source: "iana",
        extensions: ["m21", "mp21"]
      },
      "application/mp4": {
        source: "iana",
        extensions: ["mp4s", "m4p"]
      },
      "application/mpeg4-generic": {
        source: "iana"
      },
      "application/mpeg4-iod": {
        source: "iana"
      },
      "application/mpeg4-iod-xmt": {
        source: "iana"
      },
      "application/mrb-consumer+xml": {
        source: "iana",
        compressible: true
      },
      "application/mrb-publish+xml": {
        source: "iana",
        compressible: true
      },
      "application/msc-ivr+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msc-mixer+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/msword": {
        source: "iana",
        compressible: false,
        extensions: ["doc", "dot"]
      },
      "application/mud+json": {
        source: "iana",
        compressible: true
      },
      "application/multipart-core": {
        source: "iana"
      },
      "application/mxf": {
        source: "iana",
        extensions: ["mxf"]
      },
      "application/n-quads": {
        source: "iana",
        extensions: ["nq"]
      },
      "application/n-triples": {
        source: "iana",
        extensions: ["nt"]
      },
      "application/nasdata": {
        source: "iana"
      },
      "application/news-checkgroups": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-groupinfo": {
        source: "iana",
        charset: "US-ASCII"
      },
      "application/news-transmission": {
        source: "iana"
      },
      "application/nlsml+xml": {
        source: "iana",
        compressible: true
      },
      "application/node": {
        source: "iana",
        extensions: ["cjs"]
      },
      "application/nss": {
        source: "iana"
      },
      "application/oauth-authz-req+jwt": {
        source: "iana"
      },
      "application/oblivious-dns-message": {
        source: "iana"
      },
      "application/ocsp-request": {
        source: "iana"
      },
      "application/ocsp-response": {
        source: "iana"
      },
      "application/octet-stream": {
        source: "iana",
        compressible: false,
        extensions: ["bin", "dms", "lrf", "mar", "so", "dist", "distz", "pkg", "bpk", "dump", "elc", "deploy", "exe", "dll", "deb", "dmg", "iso", "img", "msi", "msp", "msm", "buffer"]
      },
      "application/oda": {
        source: "iana",
        extensions: ["oda"]
      },
      "application/odm+xml": {
        source: "iana",
        compressible: true
      },
      "application/odx": {
        source: "iana"
      },
      "application/oebps-package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["opf"]
      },
      "application/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogx"]
      },
      "application/omdoc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["omdoc"]
      },
      "application/onenote": {
        source: "apache",
        extensions: ["onetoc", "onetoc2", "onetmp", "onepkg"]
      },
      "application/opc-nodeset+xml": {
        source: "iana",
        compressible: true
      },
      "application/oscore": {
        source: "iana"
      },
      "application/oxps": {
        source: "iana",
        extensions: ["oxps"]
      },
      "application/p21": {
        source: "iana"
      },
      "application/p21+zip": {
        source: "iana",
        compressible: false
      },
      "application/p2p-overlay+xml": {
        source: "iana",
        compressible: true,
        extensions: ["relo"]
      },
      "application/parityfec": {
        source: "iana"
      },
      "application/passport": {
        source: "iana"
      },
      "application/patch-ops-error+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xer"]
      },
      "application/pdf": {
        source: "iana",
        compressible: false,
        extensions: ["pdf"]
      },
      "application/pdx": {
        source: "iana"
      },
      "application/pem-certificate-chain": {
        source: "iana"
      },
      "application/pgp-encrypted": {
        source: "iana",
        compressible: false,
        extensions: ["pgp"]
      },
      "application/pgp-keys": {
        source: "iana",
        extensions: ["asc"]
      },
      "application/pgp-signature": {
        source: "iana",
        extensions: ["asc", "sig"]
      },
      "application/pics-rules": {
        source: "apache",
        extensions: ["prf"]
      },
      "application/pidf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pidf-diff+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/pkcs10": {
        source: "iana",
        extensions: ["p10"]
      },
      "application/pkcs12": {
        source: "iana"
      },
      "application/pkcs7-mime": {
        source: "iana",
        extensions: ["p7m", "p7c"]
      },
      "application/pkcs7-signature": {
        source: "iana",
        extensions: ["p7s"]
      },
      "application/pkcs8": {
        source: "iana",
        extensions: ["p8"]
      },
      "application/pkcs8-encrypted": {
        source: "iana"
      },
      "application/pkix-attr-cert": {
        source: "iana",
        extensions: ["ac"]
      },
      "application/pkix-cert": {
        source: "iana",
        extensions: ["cer"]
      },
      "application/pkix-crl": {
        source: "iana",
        extensions: ["crl"]
      },
      "application/pkix-pkipath": {
        source: "iana",
        extensions: ["pkipath"]
      },
      "application/pkixcmp": {
        source: "iana",
        extensions: ["pki"]
      },
      "application/pls+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pls"]
      },
      "application/poc-settings+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/postscript": {
        source: "iana",
        compressible: true,
        extensions: ["ai", "eps", "ps"]
      },
      "application/ppsp-tracker+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+json": {
        source: "iana",
        compressible: true
      },
      "application/problem+xml": {
        source: "iana",
        compressible: true
      },
      "application/provenance+xml": {
        source: "iana",
        compressible: true,
        extensions: ["provx"]
      },
      "application/prs.alvestrand.titrax-sheet": {
        source: "iana"
      },
      "application/prs.cww": {
        source: "iana",
        extensions: ["cww"]
      },
      "application/prs.cyn": {
        source: "iana",
        charset: "7-BIT"
      },
      "application/prs.hpub+zip": {
        source: "iana",
        compressible: false
      },
      "application/prs.nprend": {
        source: "iana"
      },
      "application/prs.plucker": {
        source: "iana"
      },
      "application/prs.rdf-xml-crypt": {
        source: "iana"
      },
      "application/prs.xsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/pskc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["pskcxml"]
      },
      "application/pvd+json": {
        source: "iana",
        compressible: true
      },
      "application/qsig": {
        source: "iana"
      },
      "application/raml+yaml": {
        compressible: true,
        extensions: ["raml"]
      },
      "application/raptorfec": {
        source: "iana"
      },
      "application/rdap+json": {
        source: "iana",
        compressible: true
      },
      "application/rdf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rdf", "owl"]
      },
      "application/reginfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rif"]
      },
      "application/relax-ng-compact-syntax": {
        source: "iana",
        extensions: ["rnc"]
      },
      "application/remote-printing": {
        source: "iana"
      },
      "application/reputon+json": {
        source: "iana",
        compressible: true
      },
      "application/resource-lists+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rl"]
      },
      "application/resource-lists-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rld"]
      },
      "application/rfc+xml": {
        source: "iana",
        compressible: true
      },
      "application/riscos": {
        source: "iana"
      },
      "application/rlmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/rls-services+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rs"]
      },
      "application/route-apd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rapd"]
      },
      "application/route-s-tsid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sls"]
      },
      "application/route-usd+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rusd"]
      },
      "application/rpki-ghostbusters": {
        source: "iana",
        extensions: ["gbr"]
      },
      "application/rpki-manifest": {
        source: "iana",
        extensions: ["mft"]
      },
      "application/rpki-publication": {
        source: "iana"
      },
      "application/rpki-roa": {
        source: "iana",
        extensions: ["roa"]
      },
      "application/rpki-updown": {
        source: "iana"
      },
      "application/rsd+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rsd"]
      },
      "application/rss+xml": {
        source: "apache",
        compressible: true,
        extensions: ["rss"]
      },
      "application/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "application/rtploopback": {
        source: "iana"
      },
      "application/rtx": {
        source: "iana"
      },
      "application/samlassertion+xml": {
        source: "iana",
        compressible: true
      },
      "application/samlmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/sarif+json": {
        source: "iana",
        compressible: true
      },
      "application/sarif-external-properties+json": {
        source: "iana",
        compressible: true
      },
      "application/sbe": {
        source: "iana"
      },
      "application/sbml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sbml"]
      },
      "application/scaip+xml": {
        source: "iana",
        compressible: true
      },
      "application/scim+json": {
        source: "iana",
        compressible: true
      },
      "application/scvp-cv-request": {
        source: "iana",
        extensions: ["scq"]
      },
      "application/scvp-cv-response": {
        source: "iana",
        extensions: ["scs"]
      },
      "application/scvp-vp-request": {
        source: "iana",
        extensions: ["spq"]
      },
      "application/scvp-vp-response": {
        source: "iana",
        extensions: ["spp"]
      },
      "application/sdp": {
        source: "iana",
        extensions: ["sdp"]
      },
      "application/secevent+jwt": {
        source: "iana"
      },
      "application/senml+cbor": {
        source: "iana"
      },
      "application/senml+json": {
        source: "iana",
        compressible: true
      },
      "application/senml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["senmlx"]
      },
      "application/senml-etch+cbor": {
        source: "iana"
      },
      "application/senml-etch+json": {
        source: "iana",
        compressible: true
      },
      "application/senml-exi": {
        source: "iana"
      },
      "application/sensml+cbor": {
        source: "iana"
      },
      "application/sensml+json": {
        source: "iana",
        compressible: true
      },
      "application/sensml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sensmlx"]
      },
      "application/sensml-exi": {
        source: "iana"
      },
      "application/sep+xml": {
        source: "iana",
        compressible: true
      },
      "application/sep-exi": {
        source: "iana"
      },
      "application/session-info": {
        source: "iana"
      },
      "application/set-payment": {
        source: "iana"
      },
      "application/set-payment-initiation": {
        source: "iana",
        extensions: ["setpay"]
      },
      "application/set-registration": {
        source: "iana"
      },
      "application/set-registration-initiation": {
        source: "iana",
        extensions: ["setreg"]
      },
      "application/sgml": {
        source: "iana"
      },
      "application/sgml-open-catalog": {
        source: "iana"
      },
      "application/shf+xml": {
        source: "iana",
        compressible: true,
        extensions: ["shf"]
      },
      "application/sieve": {
        source: "iana",
        extensions: ["siv", "sieve"]
      },
      "application/simple-filter+xml": {
        source: "iana",
        compressible: true
      },
      "application/simple-message-summary": {
        source: "iana"
      },
      "application/simplesymbolcontainer": {
        source: "iana"
      },
      "application/sipc": {
        source: "iana"
      },
      "application/slate": {
        source: "iana"
      },
      "application/smil": {
        source: "iana"
      },
      "application/smil+xml": {
        source: "iana",
        compressible: true,
        extensions: ["smi", "smil"]
      },
      "application/smpte336m": {
        source: "iana"
      },
      "application/soap+fastinfoset": {
        source: "iana"
      },
      "application/soap+xml": {
        source: "iana",
        compressible: true
      },
      "application/sparql-query": {
        source: "iana",
        extensions: ["rq"]
      },
      "application/sparql-results+xml": {
        source: "iana",
        compressible: true,
        extensions: ["srx"]
      },
      "application/spdx+json": {
        source: "iana",
        compressible: true
      },
      "application/spirits-event+xml": {
        source: "iana",
        compressible: true
      },
      "application/sql": {
        source: "iana"
      },
      "application/srgs": {
        source: "iana",
        extensions: ["gram"]
      },
      "application/srgs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["grxml"]
      },
      "application/sru+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sru"]
      },
      "application/ssdl+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ssdl"]
      },
      "application/ssml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ssml"]
      },
      "application/stix+json": {
        source: "iana",
        compressible: true
      },
      "application/swid+xml": {
        source: "iana",
        compressible: true,
        extensions: ["swidtag"]
      },
      "application/tamp-apex-update": {
        source: "iana"
      },
      "application/tamp-apex-update-confirm": {
        source: "iana"
      },
      "application/tamp-community-update": {
        source: "iana"
      },
      "application/tamp-community-update-confirm": {
        source: "iana"
      },
      "application/tamp-error": {
        source: "iana"
      },
      "application/tamp-sequence-adjust": {
        source: "iana"
      },
      "application/tamp-sequence-adjust-confirm": {
        source: "iana"
      },
      "application/tamp-status-query": {
        source: "iana"
      },
      "application/tamp-status-response": {
        source: "iana"
      },
      "application/tamp-update": {
        source: "iana"
      },
      "application/tamp-update-confirm": {
        source: "iana"
      },
      "application/tar": {
        compressible: true
      },
      "application/taxii+json": {
        source: "iana",
        compressible: true
      },
      "application/td+json": {
        source: "iana",
        compressible: true
      },
      "application/tei+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tei", "teicorpus"]
      },
      "application/tetra_isi": {
        source: "iana"
      },
      "application/thraud+xml": {
        source: "iana",
        compressible: true,
        extensions: ["tfi"]
      },
      "application/timestamp-query": {
        source: "iana"
      },
      "application/timestamp-reply": {
        source: "iana"
      },
      "application/timestamped-data": {
        source: "iana",
        extensions: ["tsd"]
      },
      "application/tlsrpt+gzip": {
        source: "iana"
      },
      "application/tlsrpt+json": {
        source: "iana",
        compressible: true
      },
      "application/tnauthlist": {
        source: "iana"
      },
      "application/token-introspection+jwt": {
        source: "iana"
      },
      "application/toml": {
        compressible: true,
        extensions: ["toml"]
      },
      "application/trickle-ice-sdpfrag": {
        source: "iana"
      },
      "application/trig": {
        source: "iana",
        extensions: ["trig"]
      },
      "application/ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ttml"]
      },
      "application/tve-trigger": {
        source: "iana"
      },
      "application/tzif": {
        source: "iana"
      },
      "application/tzif-leap": {
        source: "iana"
      },
      "application/ubjson": {
        compressible: false,
        extensions: ["ubj"]
      },
      "application/ulpfec": {
        source: "iana"
      },
      "application/urc-grpsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/urc-ressheet+xml": {
        source: "iana",
        compressible: true,
        extensions: ["rsheet"]
      },
      "application/urc-targetdesc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["td"]
      },
      "application/urc-uisocketdesc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vcard+json": {
        source: "iana",
        compressible: true
      },
      "application/vcard+xml": {
        source: "iana",
        compressible: true
      },
      "application/vemmi": {
        source: "iana"
      },
      "application/vividence.scriptfile": {
        source: "apache"
      },
      "application/vnd.1000minds.decision-model+xml": {
        source: "iana",
        compressible: true,
        extensions: ["1km"]
      },
      "application/vnd.3gpp-prose+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-prose-pc3ch+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp-v2x-local-service-information": {
        source: "iana"
      },
      "application/vnd.3gpp.5gnas": {
        source: "iana"
      },
      "application/vnd.3gpp.access-transfer-events+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.bsf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gmop+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.gtpc": {
        source: "iana"
      },
      "application/vnd.3gpp.interworking-data": {
        source: "iana"
      },
      "application/vnd.3gpp.lpp": {
        source: "iana"
      },
      "application/vnd.3gpp.mc-signalling-ear": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-payload": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-signalling": {
        source: "iana"
      },
      "application/vnd.3gpp.mcdata-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcdata-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-floor-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-signed+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-ue-init-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcptt-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-location-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-service-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-transmission-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-ue-config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mcvideo-user-profile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.mid-call+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ngap": {
        source: "iana"
      },
      "application/vnd.3gpp.pfcp": {
        source: "iana"
      },
      "application/vnd.3gpp.pic-bw-large": {
        source: "iana",
        extensions: ["plb"]
      },
      "application/vnd.3gpp.pic-bw-small": {
        source: "iana",
        extensions: ["psb"]
      },
      "application/vnd.3gpp.pic-bw-var": {
        source: "iana",
        extensions: ["pvb"]
      },
      "application/vnd.3gpp.s1ap": {
        source: "iana"
      },
      "application/vnd.3gpp.sms": {
        source: "iana"
      },
      "application/vnd.3gpp.sms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-ext+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.srvcc-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.state-and-event-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp.ussd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.bcmcsinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.3gpp2.sms": {
        source: "iana"
      },
      "application/vnd.3gpp2.tcap": {
        source: "iana",
        extensions: ["tcap"]
      },
      "application/vnd.3lightssoftware.imagescal": {
        source: "iana"
      },
      "application/vnd.3m.post-it-notes": {
        source: "iana",
        extensions: ["pwn"]
      },
      "application/vnd.accpac.simply.aso": {
        source: "iana",
        extensions: ["aso"]
      },
      "application/vnd.accpac.simply.imp": {
        source: "iana",
        extensions: ["imp"]
      },
      "application/vnd.acucobol": {
        source: "iana",
        extensions: ["acu"]
      },
      "application/vnd.acucorp": {
        source: "iana",
        extensions: ["atc", "acutc"]
      },
      "application/vnd.adobe.air-application-installer-package+zip": {
        source: "apache",
        compressible: false,
        extensions: ["air"]
      },
      "application/vnd.adobe.flash.movie": {
        source: "iana"
      },
      "application/vnd.adobe.formscentral.fcdt": {
        source: "iana",
        extensions: ["fcdt"]
      },
      "application/vnd.adobe.fxp": {
        source: "iana",
        extensions: ["fxp", "fxpl"]
      },
      "application/vnd.adobe.partial-upload": {
        source: "iana"
      },
      "application/vnd.adobe.xdp+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdp"]
      },
      "application/vnd.adobe.xfdf": {
        source: "iana",
        extensions: ["xfdf"]
      },
      "application/vnd.aether.imp": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata": {
        source: "iana"
      },
      "application/vnd.afpc.afplinedata-pagedef": {
        source: "iana"
      },
      "application/vnd.afpc.cmoca-cmresource": {
        source: "iana"
      },
      "application/vnd.afpc.foca-charset": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codedfont": {
        source: "iana"
      },
      "application/vnd.afpc.foca-codepage": {
        source: "iana"
      },
      "application/vnd.afpc.modca": {
        source: "iana"
      },
      "application/vnd.afpc.modca-cmtable": {
        source: "iana"
      },
      "application/vnd.afpc.modca-formdef": {
        source: "iana"
      },
      "application/vnd.afpc.modca-mediummap": {
        source: "iana"
      },
      "application/vnd.afpc.modca-objectcontainer": {
        source: "iana"
      },
      "application/vnd.afpc.modca-overlay": {
        source: "iana"
      },
      "application/vnd.afpc.modca-pagesegment": {
        source: "iana"
      },
      "application/vnd.age": {
        source: "iana",
        extensions: ["age"]
      },
      "application/vnd.ah-barcode": {
        source: "iana"
      },
      "application/vnd.ahead.space": {
        source: "iana",
        extensions: ["ahead"]
      },
      "application/vnd.airzip.filesecure.azf": {
        source: "iana",
        extensions: ["azf"]
      },
      "application/vnd.airzip.filesecure.azs": {
        source: "iana",
        extensions: ["azs"]
      },
      "application/vnd.amadeus+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.amazon.ebook": {
        source: "apache",
        extensions: ["azw"]
      },
      "application/vnd.amazon.mobi8-ebook": {
        source: "iana"
      },
      "application/vnd.americandynamics.acc": {
        source: "iana",
        extensions: ["acc"]
      },
      "application/vnd.amiga.ami": {
        source: "iana",
        extensions: ["ami"]
      },
      "application/vnd.amundsen.maze+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.android.ota": {
        source: "iana"
      },
      "application/vnd.android.package-archive": {
        source: "apache",
        compressible: false,
        extensions: ["apk"]
      },
      "application/vnd.anki": {
        source: "iana"
      },
      "application/vnd.anser-web-certificate-issue-initiation": {
        source: "iana",
        extensions: ["cii"]
      },
      "application/vnd.anser-web-funds-transfer-initiation": {
        source: "apache",
        extensions: ["fti"]
      },
      "application/vnd.antix.game-component": {
        source: "iana",
        extensions: ["atx"]
      },
      "application/vnd.apache.arrow.file": {
        source: "iana"
      },
      "application/vnd.apache.arrow.stream": {
        source: "iana"
      },
      "application/vnd.apache.thrift.binary": {
        source: "iana"
      },
      "application/vnd.apache.thrift.compact": {
        source: "iana"
      },
      "application/vnd.apache.thrift.json": {
        source: "iana"
      },
      "application/vnd.api+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.aplextor.warrp+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apothekende.reservation+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.apple.installer+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mpkg"]
      },
      "application/vnd.apple.keynote": {
        source: "iana",
        extensions: ["key"]
      },
      "application/vnd.apple.mpegurl": {
        source: "iana",
        extensions: ["m3u8"]
      },
      "application/vnd.apple.numbers": {
        source: "iana",
        extensions: ["numbers"]
      },
      "application/vnd.apple.pages": {
        source: "iana",
        extensions: ["pages"]
      },
      "application/vnd.apple.pkpass": {
        compressible: false,
        extensions: ["pkpass"]
      },
      "application/vnd.arastra.swi": {
        source: "iana"
      },
      "application/vnd.aristanetworks.swi": {
        source: "iana",
        extensions: ["swi"]
      },
      "application/vnd.artisan+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.artsquare": {
        source: "iana"
      },
      "application/vnd.astraea-software.iota": {
        source: "iana",
        extensions: ["iota"]
      },
      "application/vnd.audiograph": {
        source: "iana",
        extensions: ["aep"]
      },
      "application/vnd.autopackage": {
        source: "iana"
      },
      "application/vnd.avalon+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.avistar+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.balsamiq.bmml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["bmml"]
      },
      "application/vnd.balsamiq.bmpr": {
        source: "iana"
      },
      "application/vnd.banana-accounting": {
        source: "iana"
      },
      "application/vnd.bbf.usp.error": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg": {
        source: "iana"
      },
      "application/vnd.bbf.usp.msg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bekitzur-stech+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.bint.med-content": {
        source: "iana"
      },
      "application/vnd.biopax.rdf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.blink-idb-value-wrapper": {
        source: "iana"
      },
      "application/vnd.blueice.multipass": {
        source: "iana",
        extensions: ["mpm"]
      },
      "application/vnd.bluetooth.ep.oob": {
        source: "iana"
      },
      "application/vnd.bluetooth.le.oob": {
        source: "iana"
      },
      "application/vnd.bmi": {
        source: "iana",
        extensions: ["bmi"]
      },
      "application/vnd.bpf": {
        source: "iana"
      },
      "application/vnd.bpf3": {
        source: "iana"
      },
      "application/vnd.businessobjects": {
        source: "iana",
        extensions: ["rep"]
      },
      "application/vnd.byu.uapi+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cab-jscript": {
        source: "iana"
      },
      "application/vnd.canon-cpdl": {
        source: "iana"
      },
      "application/vnd.canon-lips": {
        source: "iana"
      },
      "application/vnd.capasystems-pg+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cendio.thinlinc.clientconf": {
        source: "iana"
      },
      "application/vnd.century-systems.tcp_stream": {
        source: "iana"
      },
      "application/vnd.chemdraw+xml": {
        source: "iana",
        compressible: true,
        extensions: ["cdxml"]
      },
      "application/vnd.chess-pgn": {
        source: "iana"
      },
      "application/vnd.chipnuts.karaoke-mmd": {
        source: "iana",
        extensions: ["mmd"]
      },
      "application/vnd.ciedi": {
        source: "iana"
      },
      "application/vnd.cinderella": {
        source: "iana",
        extensions: ["cdy"]
      },
      "application/vnd.cirpack.isdn-ext": {
        source: "iana"
      },
      "application/vnd.citationstyles.style+xml": {
        source: "iana",
        compressible: true,
        extensions: ["csl"]
      },
      "application/vnd.claymore": {
        source: "iana",
        extensions: ["cla"]
      },
      "application/vnd.cloanto.rp9": {
        source: "iana",
        extensions: ["rp9"]
      },
      "application/vnd.clonk.c4group": {
        source: "iana",
        extensions: ["c4g", "c4d", "c4f", "c4p", "c4u"]
      },
      "application/vnd.cluetrust.cartomobile-config": {
        source: "iana",
        extensions: ["c11amc"]
      },
      "application/vnd.cluetrust.cartomobile-config-pkg": {
        source: "iana",
        extensions: ["c11amz"]
      },
      "application/vnd.coffeescript": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.document-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.presentation-template": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet": {
        source: "iana"
      },
      "application/vnd.collabio.xodocuments.spreadsheet-template": {
        source: "iana"
      },
      "application/vnd.collection+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.doc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.collection.next+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.comicbook+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.comicbook-rar": {
        source: "iana"
      },
      "application/vnd.commerce-battelle": {
        source: "iana"
      },
      "application/vnd.commonspace": {
        source: "iana",
        extensions: ["csp"]
      },
      "application/vnd.contact.cmsg": {
        source: "iana",
        extensions: ["cdbcmsg"]
      },
      "application/vnd.coreos.ignition+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cosmocaller": {
        source: "iana",
        extensions: ["cmc"]
      },
      "application/vnd.crick.clicker": {
        source: "iana",
        extensions: ["clkx"]
      },
      "application/vnd.crick.clicker.keyboard": {
        source: "iana",
        extensions: ["clkk"]
      },
      "application/vnd.crick.clicker.palette": {
        source: "iana",
        extensions: ["clkp"]
      },
      "application/vnd.crick.clicker.template": {
        source: "iana",
        extensions: ["clkt"]
      },
      "application/vnd.crick.clicker.wordbank": {
        source: "iana",
        extensions: ["clkw"]
      },
      "application/vnd.criticaltools.wbs+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wbs"]
      },
      "application/vnd.cryptii.pipe+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.crypto-shade-file": {
        source: "iana"
      },
      "application/vnd.cryptomator.encrypted": {
        source: "iana"
      },
      "application/vnd.cryptomator.vault": {
        source: "iana"
      },
      "application/vnd.ctc-posml": {
        source: "iana",
        extensions: ["pml"]
      },
      "application/vnd.ctct.ws+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cups-pdf": {
        source: "iana"
      },
      "application/vnd.cups-postscript": {
        source: "iana"
      },
      "application/vnd.cups-ppd": {
        source: "iana",
        extensions: ["ppd"]
      },
      "application/vnd.cups-raster": {
        source: "iana"
      },
      "application/vnd.cups-raw": {
        source: "iana"
      },
      "application/vnd.curl": {
        source: "iana"
      },
      "application/vnd.curl.car": {
        source: "apache",
        extensions: ["car"]
      },
      "application/vnd.curl.pcurl": {
        source: "apache",
        extensions: ["pcurl"]
      },
      "application/vnd.cyan.dean.root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cybank": {
        source: "iana"
      },
      "application/vnd.cyclonedx+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.cyclonedx+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.d2l.coursepackage1p0+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.d3m-dataset": {
        source: "iana"
      },
      "application/vnd.d3m-problem": {
        source: "iana"
      },
      "application/vnd.dart": {
        source: "iana",
        compressible: true,
        extensions: ["dart"]
      },
      "application/vnd.data-vision.rdz": {
        source: "iana",
        extensions: ["rdz"]
      },
      "application/vnd.datapackage+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dataresource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dbf": {
        source: "iana",
        extensions: ["dbf"]
      },
      "application/vnd.debian.binary-package": {
        source: "iana"
      },
      "application/vnd.dece.data": {
        source: "iana",
        extensions: ["uvf", "uvvf", "uvd", "uvvd"]
      },
      "application/vnd.dece.ttml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uvt", "uvvt"]
      },
      "application/vnd.dece.unspecified": {
        source: "iana",
        extensions: ["uvx", "uvvx"]
      },
      "application/vnd.dece.zip": {
        source: "iana",
        extensions: ["uvz", "uvvz"]
      },
      "application/vnd.denovo.fcselayout-link": {
        source: "iana",
        extensions: ["fe_launch"]
      },
      "application/vnd.desmume.movie": {
        source: "iana"
      },
      "application/vnd.dir-bi.plate-dl-nosuffix": {
        source: "iana"
      },
      "application/vnd.dm.delegation+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dna": {
        source: "iana",
        extensions: ["dna"]
      },
      "application/vnd.document+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dolby.mlp": {
        source: "apache",
        extensions: ["mlp"]
      },
      "application/vnd.dolby.mobile.1": {
        source: "iana"
      },
      "application/vnd.dolby.mobile.2": {
        source: "iana"
      },
      "application/vnd.doremir.scorecloud-binary-document": {
        source: "iana"
      },
      "application/vnd.dpgraph": {
        source: "iana",
        extensions: ["dpg"]
      },
      "application/vnd.dreamfactory": {
        source: "iana",
        extensions: ["dfac"]
      },
      "application/vnd.drive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ds-keypoint": {
        source: "apache",
        extensions: ["kpxx"]
      },
      "application/vnd.dtg.local": {
        source: "iana"
      },
      "application/vnd.dtg.local.flash": {
        source: "iana"
      },
      "application/vnd.dtg.local.html": {
        source: "iana"
      },
      "application/vnd.dvb.ait": {
        source: "iana",
        extensions: ["ait"]
      },
      "application/vnd.dvb.dvbisl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.dvbj": {
        source: "iana"
      },
      "application/vnd.dvb.esgcontainer": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcdftnotifaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgaccess2": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcesgpdd": {
        source: "iana"
      },
      "application/vnd.dvb.ipdcroaming": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-base": {
        source: "iana"
      },
      "application/vnd.dvb.iptv.alfec-enhancement": {
        source: "iana"
      },
      "application/vnd.dvb.notif-aggregate-root+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-container+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-generic+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-msglist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-ia-registration-response+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.notif-init+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.dvb.pfr": {
        source: "iana"
      },
      "application/vnd.dvb.service": {
        source: "iana",
        extensions: ["svc"]
      },
      "application/vnd.dxr": {
        source: "iana"
      },
      "application/vnd.dynageo": {
        source: "iana",
        extensions: ["geo"]
      },
      "application/vnd.dzr": {
        source: "iana"
      },
      "application/vnd.easykaraoke.cdgdownload": {
        source: "iana"
      },
      "application/vnd.ecdis-update": {
        source: "iana"
      },
      "application/vnd.ecip.rlp": {
        source: "iana"
      },
      "application/vnd.eclipse.ditto+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ecowin.chart": {
        source: "iana",
        extensions: ["mag"]
      },
      "application/vnd.ecowin.filerequest": {
        source: "iana"
      },
      "application/vnd.ecowin.fileupdate": {
        source: "iana"
      },
      "application/vnd.ecowin.series": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesrequest": {
        source: "iana"
      },
      "application/vnd.ecowin.seriesupdate": {
        source: "iana"
      },
      "application/vnd.efi.img": {
        source: "iana"
      },
      "application/vnd.efi.iso": {
        source: "iana"
      },
      "application/vnd.emclient.accessrequest+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.enliven": {
        source: "iana",
        extensions: ["nml"]
      },
      "application/vnd.enphase.envoy": {
        source: "iana"
      },
      "application/vnd.eprints.data+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.epson.esf": {
        source: "iana",
        extensions: ["esf"]
      },
      "application/vnd.epson.msf": {
        source: "iana",
        extensions: ["msf"]
      },
      "application/vnd.epson.quickanime": {
        source: "iana",
        extensions: ["qam"]
      },
      "application/vnd.epson.salt": {
        source: "iana",
        extensions: ["slt"]
      },
      "application/vnd.epson.ssf": {
        source: "iana",
        extensions: ["ssf"]
      },
      "application/vnd.ericsson.quickcall": {
        source: "iana"
      },
      "application/vnd.espass-espass+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.eszigno3+xml": {
        source: "iana",
        compressible: true,
        extensions: ["es3", "et3"]
      },
      "application/vnd.etsi.aoc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.asic-e+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.asic-s+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.etsi.cug+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvcommand+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-bc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-cod+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsad-npvr+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvservice+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvsync+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.iptvueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mcid+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.mheg5": {
        source: "iana"
      },
      "application/vnd.etsi.overload-control-policy-dataset+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.pstn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.sci+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.simservs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.timestamp-token": {
        source: "iana"
      },
      "application/vnd.etsi.tsl+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.etsi.tsl.der": {
        source: "iana"
      },
      "application/vnd.eu.kasparian.car+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.eudora.data": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.profile": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.settings": {
        source: "iana"
      },
      "application/vnd.evolv.ecig.theme": {
        source: "iana"
      },
      "application/vnd.exstream-empower+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.exstream-package": {
        source: "iana"
      },
      "application/vnd.ezpix-album": {
        source: "iana",
        extensions: ["ez2"]
      },
      "application/vnd.ezpix-package": {
        source: "iana",
        extensions: ["ez3"]
      },
      "application/vnd.f-secure.mobile": {
        source: "iana"
      },
      "application/vnd.familysearch.gedcom+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.fastcopy-disk-image": {
        source: "iana"
      },
      "application/vnd.fdf": {
        source: "iana",
        extensions: ["fdf"]
      },
      "application/vnd.fdsn.mseed": {
        source: "iana",
        extensions: ["mseed"]
      },
      "application/vnd.fdsn.seed": {
        source: "iana",
        extensions: ["seed", "dataless"]
      },
      "application/vnd.ffsns": {
        source: "iana"
      },
      "application/vnd.ficlab.flb+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.filmit.zfc": {
        source: "iana"
      },
      "application/vnd.fints": {
        source: "iana"
      },
      "application/vnd.firemonkeys.cloudcell": {
        source: "iana"
      },
      "application/vnd.flographit": {
        source: "iana",
        extensions: ["gph"]
      },
      "application/vnd.fluxtime.clip": {
        source: "iana",
        extensions: ["ftc"]
      },
      "application/vnd.font-fontforge-sfd": {
        source: "iana"
      },
      "application/vnd.framemaker": {
        source: "iana",
        extensions: ["fm", "frame", "maker", "book"]
      },
      "application/vnd.frogans.fnc": {
        source: "iana",
        extensions: ["fnc"]
      },
      "application/vnd.frogans.ltf": {
        source: "iana",
        extensions: ["ltf"]
      },
      "application/vnd.fsc.weblaunch": {
        source: "iana",
        extensions: ["fsc"]
      },
      "application/vnd.fujifilm.fb.docuworks": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.binder": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujifilm.fb.jfi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fujitsu.oasys": {
        source: "iana",
        extensions: ["oas"]
      },
      "application/vnd.fujitsu.oasys2": {
        source: "iana",
        extensions: ["oa2"]
      },
      "application/vnd.fujitsu.oasys3": {
        source: "iana",
        extensions: ["oa3"]
      },
      "application/vnd.fujitsu.oasysgp": {
        source: "iana",
        extensions: ["fg5"]
      },
      "application/vnd.fujitsu.oasysprs": {
        source: "iana",
        extensions: ["bh2"]
      },
      "application/vnd.fujixerox.art-ex": {
        source: "iana"
      },
      "application/vnd.fujixerox.art4": {
        source: "iana"
      },
      "application/vnd.fujixerox.ddd": {
        source: "iana",
        extensions: ["ddd"]
      },
      "application/vnd.fujixerox.docuworks": {
        source: "iana",
        extensions: ["xdw"]
      },
      "application/vnd.fujixerox.docuworks.binder": {
        source: "iana",
        extensions: ["xbd"]
      },
      "application/vnd.fujixerox.docuworks.container": {
        source: "iana"
      },
      "application/vnd.fujixerox.hbpl": {
        source: "iana"
      },
      "application/vnd.fut-misnet": {
        source: "iana"
      },
      "application/vnd.futoin+cbor": {
        source: "iana"
      },
      "application/vnd.futoin+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.fuzzysheet": {
        source: "iana",
        extensions: ["fzs"]
      },
      "application/vnd.genomatix.tuxedo": {
        source: "iana",
        extensions: ["txd"]
      },
      "application/vnd.gentics.grd+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geo+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geocube+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.geogebra.file": {
        source: "iana",
        extensions: ["ggb"]
      },
      "application/vnd.geogebra.slides": {
        source: "iana"
      },
      "application/vnd.geogebra.tool": {
        source: "iana",
        extensions: ["ggt"]
      },
      "application/vnd.geometry-explorer": {
        source: "iana",
        extensions: ["gex", "gre"]
      },
      "application/vnd.geonext": {
        source: "iana",
        extensions: ["gxt"]
      },
      "application/vnd.geoplan": {
        source: "iana",
        extensions: ["g2w"]
      },
      "application/vnd.geospace": {
        source: "iana",
        extensions: ["g3w"]
      },
      "application/vnd.gerber": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt": {
        source: "iana"
      },
      "application/vnd.globalplatform.card-content-mgt-response": {
        source: "iana"
      },
      "application/vnd.gmx": {
        source: "iana",
        extensions: ["gmx"]
      },
      "application/vnd.google-apps.document": {
        compressible: false,
        extensions: ["gdoc"]
      },
      "application/vnd.google-apps.presentation": {
        compressible: false,
        extensions: ["gslides"]
      },
      "application/vnd.google-apps.spreadsheet": {
        compressible: false,
        extensions: ["gsheet"]
      },
      "application/vnd.google-earth.kml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["kml"]
      },
      "application/vnd.google-earth.kmz": {
        source: "iana",
        compressible: false,
        extensions: ["kmz"]
      },
      "application/vnd.gov.sk.e-form+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.gov.sk.e-form+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.gov.sk.xmldatacontainer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.grafeq": {
        source: "iana",
        extensions: ["gqf", "gqs"]
      },
      "application/vnd.gridmp": {
        source: "iana"
      },
      "application/vnd.groove-account": {
        source: "iana",
        extensions: ["gac"]
      },
      "application/vnd.groove-help": {
        source: "iana",
        extensions: ["ghf"]
      },
      "application/vnd.groove-identity-message": {
        source: "iana",
        extensions: ["gim"]
      },
      "application/vnd.groove-injector": {
        source: "iana",
        extensions: ["grv"]
      },
      "application/vnd.groove-tool-message": {
        source: "iana",
        extensions: ["gtm"]
      },
      "application/vnd.groove-tool-template": {
        source: "iana",
        extensions: ["tpl"]
      },
      "application/vnd.groove-vcard": {
        source: "iana",
        extensions: ["vcg"]
      },
      "application/vnd.hal+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hal+xml": {
        source: "iana",
        compressible: true,
        extensions: ["hal"]
      },
      "application/vnd.handheld-entertainment+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zmm"]
      },
      "application/vnd.hbci": {
        source: "iana",
        extensions: ["hbci"]
      },
      "application/vnd.hc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hcl-bireports": {
        source: "iana"
      },
      "application/vnd.hdt": {
        source: "iana"
      },
      "application/vnd.heroku+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hhe.lesson-player": {
        source: "iana",
        extensions: ["les"]
      },
      "application/vnd.hl7cda+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hl7v2+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.hp-hpgl": {
        source: "iana",
        extensions: ["hpgl"]
      },
      "application/vnd.hp-hpid": {
        source: "iana",
        extensions: ["hpid"]
      },
      "application/vnd.hp-hps": {
        source: "iana",
        extensions: ["hps"]
      },
      "application/vnd.hp-jlyt": {
        source: "iana",
        extensions: ["jlt"]
      },
      "application/vnd.hp-pcl": {
        source: "iana",
        extensions: ["pcl"]
      },
      "application/vnd.hp-pclxl": {
        source: "iana",
        extensions: ["pclxl"]
      },
      "application/vnd.httphone": {
        source: "iana"
      },
      "application/vnd.hydrostatix.sof-data": {
        source: "iana",
        extensions: ["sfd-hdstx"]
      },
      "application/vnd.hyper+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyper-item+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hyperdrive+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.hzn-3d-crossword": {
        source: "iana"
      },
      "application/vnd.ibm.afplinedata": {
        source: "iana"
      },
      "application/vnd.ibm.electronic-media": {
        source: "iana"
      },
      "application/vnd.ibm.minipay": {
        source: "iana",
        extensions: ["mpy"]
      },
      "application/vnd.ibm.modcap": {
        source: "iana",
        extensions: ["afp", "listafp", "list3820"]
      },
      "application/vnd.ibm.rights-management": {
        source: "iana",
        extensions: ["irm"]
      },
      "application/vnd.ibm.secure-container": {
        source: "iana",
        extensions: ["sc"]
      },
      "application/vnd.iccprofile": {
        source: "iana",
        extensions: ["icc", "icm"]
      },
      "application/vnd.ieee.1905": {
        source: "iana"
      },
      "application/vnd.igloader": {
        source: "iana",
        extensions: ["igl"]
      },
      "application/vnd.imagemeter.folder+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.imagemeter.image+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.immervision-ivp": {
        source: "iana",
        extensions: ["ivp"]
      },
      "application/vnd.immervision-ivu": {
        source: "iana",
        extensions: ["ivu"]
      },
      "application/vnd.ims.imsccv1p1": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p2": {
        source: "iana"
      },
      "application/vnd.ims.imsccv1p3": {
        source: "iana"
      },
      "application/vnd.ims.lis.v2.result+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolproxy.id+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ims.lti.v2.toolsettings.simple+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informedcontrol.rms+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.informix-visionary": {
        source: "iana"
      },
      "application/vnd.infotech.project": {
        source: "iana"
      },
      "application/vnd.infotech.project+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.innopath.wamp.notification": {
        source: "iana"
      },
      "application/vnd.insors.igm": {
        source: "iana",
        extensions: ["igm"]
      },
      "application/vnd.intercon.formnet": {
        source: "iana",
        extensions: ["xpw", "xpx"]
      },
      "application/vnd.intergeo": {
        source: "iana",
        extensions: ["i2g"]
      },
      "application/vnd.intertrust.digibox": {
        source: "iana"
      },
      "application/vnd.intertrust.nncp": {
        source: "iana"
      },
      "application/vnd.intu.qbo": {
        source: "iana",
        extensions: ["qbo"]
      },
      "application/vnd.intu.qfx": {
        source: "iana",
        extensions: ["qfx"]
      },
      "application/vnd.iptc.g2.catalogitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.conceptitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.knowledgeitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.newsmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.packageitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.iptc.g2.planningitem+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ipunplugged.rcprofile": {
        source: "iana",
        extensions: ["rcprofile"]
      },
      "application/vnd.irepository.package+xml": {
        source: "iana",
        compressible: true,
        extensions: ["irp"]
      },
      "application/vnd.is-xpr": {
        source: "iana",
        extensions: ["xpr"]
      },
      "application/vnd.isac.fcs": {
        source: "iana",
        extensions: ["fcs"]
      },
      "application/vnd.iso11783-10+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.jam": {
        source: "iana",
        extensions: ["jam"]
      },
      "application/vnd.japannet-directory-service": {
        source: "iana"
      },
      "application/vnd.japannet-jpnstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-payment-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-registration": {
        source: "iana"
      },
      "application/vnd.japannet-registration-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-setstore-wakeup": {
        source: "iana"
      },
      "application/vnd.japannet-verification": {
        source: "iana"
      },
      "application/vnd.japannet-verification-wakeup": {
        source: "iana"
      },
      "application/vnd.jcp.javame.midlet-rms": {
        source: "iana",
        extensions: ["rms"]
      },
      "application/vnd.jisp": {
        source: "iana",
        extensions: ["jisp"]
      },
      "application/vnd.joost.joda-archive": {
        source: "iana",
        extensions: ["joda"]
      },
      "application/vnd.jsk.isdn-ngn": {
        source: "iana"
      },
      "application/vnd.kahootz": {
        source: "iana",
        extensions: ["ktz", "ktr"]
      },
      "application/vnd.kde.karbon": {
        source: "iana",
        extensions: ["karbon"]
      },
      "application/vnd.kde.kchart": {
        source: "iana",
        extensions: ["chrt"]
      },
      "application/vnd.kde.kformula": {
        source: "iana",
        extensions: ["kfo"]
      },
      "application/vnd.kde.kivio": {
        source: "iana",
        extensions: ["flw"]
      },
      "application/vnd.kde.kontour": {
        source: "iana",
        extensions: ["kon"]
      },
      "application/vnd.kde.kpresenter": {
        source: "iana",
        extensions: ["kpr", "kpt"]
      },
      "application/vnd.kde.kspread": {
        source: "iana",
        extensions: ["ksp"]
      },
      "application/vnd.kde.kword": {
        source: "iana",
        extensions: ["kwd", "kwt"]
      },
      "application/vnd.kenameaapp": {
        source: "iana",
        extensions: ["htke"]
      },
      "application/vnd.kidspiration": {
        source: "iana",
        extensions: ["kia"]
      },
      "application/vnd.kinar": {
        source: "iana",
        extensions: ["kne", "knp"]
      },
      "application/vnd.koan": {
        source: "iana",
        extensions: ["skp", "skd", "skt", "skm"]
      },
      "application/vnd.kodak-descriptor": {
        source: "iana",
        extensions: ["sse"]
      },
      "application/vnd.las": {
        source: "iana"
      },
      "application/vnd.las.las+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.las.las+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lasxml"]
      },
      "application/vnd.laszip": {
        source: "iana"
      },
      "application/vnd.leap+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.liberty-request+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.llamagraphics.life-balance.desktop": {
        source: "iana",
        extensions: ["lbd"]
      },
      "application/vnd.llamagraphics.life-balance.exchange+xml": {
        source: "iana",
        compressible: true,
        extensions: ["lbe"]
      },
      "application/vnd.logipipe.circuit+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.loom": {
        source: "iana"
      },
      "application/vnd.lotus-1-2-3": {
        source: "iana",
        extensions: ["123"]
      },
      "application/vnd.lotus-approach": {
        source: "iana",
        extensions: ["apr"]
      },
      "application/vnd.lotus-freelance": {
        source: "iana",
        extensions: ["pre"]
      },
      "application/vnd.lotus-notes": {
        source: "iana",
        extensions: ["nsf"]
      },
      "application/vnd.lotus-organizer": {
        source: "iana",
        extensions: ["org"]
      },
      "application/vnd.lotus-screencam": {
        source: "iana",
        extensions: ["scm"]
      },
      "application/vnd.lotus-wordpro": {
        source: "iana",
        extensions: ["lwp"]
      },
      "application/vnd.macports.portpkg": {
        source: "iana",
        extensions: ["portpkg"]
      },
      "application/vnd.mapbox-vector-tile": {
        source: "iana",
        extensions: ["mvt"]
      },
      "application/vnd.marlin.drm.actiontoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.conftoken+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.license+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.marlin.drm.mdcf": {
        source: "iana"
      },
      "application/vnd.mason+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.maxar.archive.3tz+zip": {
        source: "iana",
        compressible: false
      },
      "application/vnd.maxmind.maxmind-db": {
        source: "iana"
      },
      "application/vnd.mcd": {
        source: "iana",
        extensions: ["mcd"]
      },
      "application/vnd.medcalcdata": {
        source: "iana",
        extensions: ["mc1"]
      },
      "application/vnd.mediastation.cdkey": {
        source: "iana",
        extensions: ["cdkey"]
      },
      "application/vnd.meridian-slingshot": {
        source: "iana"
      },
      "application/vnd.mfer": {
        source: "iana",
        extensions: ["mwf"]
      },
      "application/vnd.mfmp": {
        source: "iana",
        extensions: ["mfm"]
      },
      "application/vnd.micro+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.micrografx.flo": {
        source: "iana",
        extensions: ["flo"]
      },
      "application/vnd.micrografx.igx": {
        source: "iana",
        extensions: ["igx"]
      },
      "application/vnd.microsoft.portable-executable": {
        source: "iana"
      },
      "application/vnd.microsoft.windows.thumbnail-cache": {
        source: "iana"
      },
      "application/vnd.miele+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.mif": {
        source: "iana",
        extensions: ["mif"]
      },
      "application/vnd.minisoft-hp3000-save": {
        source: "iana"
      },
      "application/vnd.mitsubishi.misty-guard.trustweb": {
        source: "iana"
      },
      "application/vnd.mobius.daf": {
        source: "iana",
        extensions: ["daf"]
      },
      "application/vnd.mobius.dis": {
        source: "iana",
        extensions: ["dis"]
      },
      "application/vnd.mobius.mbk": {
        source: "iana",
        extensions: ["mbk"]
      },
      "application/vnd.mobius.mqy": {
        source: "iana",
        extensions: ["mqy"]
      },
      "application/vnd.mobius.msl": {
        source: "iana",
        extensions: ["msl"]
      },
      "application/vnd.mobius.plc": {
        source: "iana",
        extensions: ["plc"]
      },
      "application/vnd.mobius.txf": {
        source: "iana",
        extensions: ["txf"]
      },
      "application/vnd.mophun.application": {
        source: "iana",
        extensions: ["mpn"]
      },
      "application/vnd.mophun.certificate": {
        source: "iana",
        extensions: ["mpc"]
      },
      "application/vnd.motorola.flexsuite": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.adsi": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.fis": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.gotap": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.kmr": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.ttc": {
        source: "iana"
      },
      "application/vnd.motorola.flexsuite.wem": {
        source: "iana"
      },
      "application/vnd.motorola.iprm": {
        source: "iana"
      },
      "application/vnd.mozilla.xul+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xul"]
      },
      "application/vnd.ms-3mfdocument": {
        source: "iana"
      },
      "application/vnd.ms-artgalry": {
        source: "iana",
        extensions: ["cil"]
      },
      "application/vnd.ms-asf": {
        source: "iana"
      },
      "application/vnd.ms-cab-compressed": {
        source: "iana",
        extensions: ["cab"]
      },
      "application/vnd.ms-color.iccprofile": {
        source: "apache"
      },
      "application/vnd.ms-excel": {
        source: "iana",
        compressible: false,
        extensions: ["xls", "xlm", "xla", "xlc", "xlt", "xlw"]
      },
      "application/vnd.ms-excel.addin.macroenabled.12": {
        source: "iana",
        extensions: ["xlam"]
      },
      "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
        source: "iana",
        extensions: ["xlsb"]
      },
      "application/vnd.ms-excel.sheet.macroenabled.12": {
        source: "iana",
        extensions: ["xlsm"]
      },
      "application/vnd.ms-excel.template.macroenabled.12": {
        source: "iana",
        extensions: ["xltm"]
      },
      "application/vnd.ms-fontobject": {
        source: "iana",
        compressible: true,
        extensions: ["eot"]
      },
      "application/vnd.ms-htmlhelp": {
        source: "iana",
        extensions: ["chm"]
      },
      "application/vnd.ms-ims": {
        source: "iana",
        extensions: ["ims"]
      },
      "application/vnd.ms-lrm": {
        source: "iana",
        extensions: ["lrm"]
      },
      "application/vnd.ms-office.activex+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-officetheme": {
        source: "iana",
        extensions: ["thmx"]
      },
      "application/vnd.ms-opentype": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-outlook": {
        compressible: false,
        extensions: ["msg"]
      },
      "application/vnd.ms-package.obfuscated-opentype": {
        source: "apache"
      },
      "application/vnd.ms-pki.seccat": {
        source: "apache",
        extensions: ["cat"]
      },
      "application/vnd.ms-pki.stl": {
        source: "apache",
        extensions: ["stl"]
      },
      "application/vnd.ms-playready.initiator+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-powerpoint": {
        source: "iana",
        compressible: false,
        extensions: ["ppt", "pps", "pot"]
      },
      "application/vnd.ms-powerpoint.addin.macroenabled.12": {
        source: "iana",
        extensions: ["ppam"]
      },
      "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
        source: "iana",
        extensions: ["pptm"]
      },
      "application/vnd.ms-powerpoint.slide.macroenabled.12": {
        source: "iana",
        extensions: ["sldm"]
      },
      "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
        source: "iana",
        extensions: ["ppsm"]
      },
      "application/vnd.ms-powerpoint.template.macroenabled.12": {
        source: "iana",
        extensions: ["potm"]
      },
      "application/vnd.ms-printdevicecapabilities+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-printing.printticket+xml": {
        source: "apache",
        compressible: true
      },
      "application/vnd.ms-printschematicket+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ms-project": {
        source: "iana",
        extensions: ["mpp", "mpt"]
      },
      "application/vnd.ms-tnef": {
        source: "iana"
      },
      "application/vnd.ms-windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.nwprinting.oob": {
        source: "iana"
      },
      "application/vnd.ms-windows.printerpairing": {
        source: "iana"
      },
      "application/vnd.ms-windows.wsd.oob": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.lic-resp": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-chlg-req": {
        source: "iana"
      },
      "application/vnd.ms-wmdrm.meter-resp": {
        source: "iana"
      },
      "application/vnd.ms-word.document.macroenabled.12": {
        source: "iana",
        extensions: ["docm"]
      },
      "application/vnd.ms-word.template.macroenabled.12": {
        source: "iana",
        extensions: ["dotm"]
      },
      "application/vnd.ms-works": {
        source: "iana",
        extensions: ["wps", "wks", "wcm", "wdb"]
      },
      "application/vnd.ms-wpl": {
        source: "iana",
        extensions: ["wpl"]
      },
      "application/vnd.ms-xpsdocument": {
        source: "iana",
        compressible: false,
        extensions: ["xps"]
      },
      "application/vnd.msa-disk-image": {
        source: "iana"
      },
      "application/vnd.mseq": {
        source: "iana",
        extensions: ["mseq"]
      },
      "application/vnd.msign": {
        source: "iana"
      },
      "application/vnd.multiad.creator": {
        source: "iana"
      },
      "application/vnd.multiad.creator.cif": {
        source: "iana"
      },
      "application/vnd.music-niff": {
        source: "iana"
      },
      "application/vnd.musician": {
        source: "iana",
        extensions: ["mus"]
      },
      "application/vnd.muvee.style": {
        source: "iana",
        extensions: ["msty"]
      },
      "application/vnd.mynfc": {
        source: "iana",
        extensions: ["taglet"]
      },
      "application/vnd.nacamar.ybrid+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.ncd.control": {
        source: "iana"
      },
      "application/vnd.ncd.reference": {
        source: "iana"
      },
      "application/vnd.nearst.inv+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nebumind.line": {
        source: "iana"
      },
      "application/vnd.nervana": {
        source: "iana"
      },
      "application/vnd.netfpx": {
        source: "iana"
      },
      "application/vnd.neurolanguage.nlu": {
        source: "iana",
        extensions: ["nlu"]
      },
      "application/vnd.nimn": {
        source: "iana"
      },
      "application/vnd.nintendo.nitro.rom": {
        source: "iana"
      },
      "application/vnd.nintendo.snes.rom": {
        source: "iana"
      },
      "application/vnd.nitf": {
        source: "iana",
        extensions: ["ntf", "nitf"]
      },
      "application/vnd.noblenet-directory": {
        source: "iana",
        extensions: ["nnd"]
      },
      "application/vnd.noblenet-sealer": {
        source: "iana",
        extensions: ["nns"]
      },
      "application/vnd.noblenet-web": {
        source: "iana",
        extensions: ["nnw"]
      },
      "application/vnd.nokia.catalogs": {
        source: "iana"
      },
      "application/vnd.nokia.conml+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.conml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.iptv.config+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.isds-radio-presets": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.landmark+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.landmarkcollection+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.n-gage.ac+xml": {
        source: "iana",
        compressible: true,
        extensions: ["ac"]
      },
      "application/vnd.nokia.n-gage.data": {
        source: "iana",
        extensions: ["ngdat"]
      },
      "application/vnd.nokia.n-gage.symbian.install": {
        source: "iana",
        extensions: ["n-gage"]
      },
      "application/vnd.nokia.ncd": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+wbxml": {
        source: "iana"
      },
      "application/vnd.nokia.pcd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.nokia.radio-preset": {
        source: "iana",
        extensions: ["rpst"]
      },
      "application/vnd.nokia.radio-presets": {
        source: "iana",
        extensions: ["rpss"]
      },
      "application/vnd.novadigm.edm": {
        source: "iana",
        extensions: ["edm"]
      },
      "application/vnd.novadigm.edx": {
        source: "iana",
        extensions: ["edx"]
      },
      "application/vnd.novadigm.ext": {
        source: "iana",
        extensions: ["ext"]
      },
      "application/vnd.ntt-local.content-share": {
        source: "iana"
      },
      "application/vnd.ntt-local.file-transfer": {
        source: "iana"
      },
      "application/vnd.ntt-local.ogw_remote-access": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_remote": {
        source: "iana"
      },
      "application/vnd.ntt-local.sip-ta_tcp_stream": {
        source: "iana"
      },
      "application/vnd.oasis.opendocument.chart": {
        source: "iana",
        extensions: ["odc"]
      },
      "application/vnd.oasis.opendocument.chart-template": {
        source: "iana",
        extensions: ["otc"]
      },
      "application/vnd.oasis.opendocument.database": {
        source: "iana",
        extensions: ["odb"]
      },
      "application/vnd.oasis.opendocument.formula": {
        source: "iana",
        extensions: ["odf"]
      },
      "application/vnd.oasis.opendocument.formula-template": {
        source: "iana",
        extensions: ["odft"]
      },
      "application/vnd.oasis.opendocument.graphics": {
        source: "iana",
        compressible: false,
        extensions: ["odg"]
      },
      "application/vnd.oasis.opendocument.graphics-template": {
        source: "iana",
        extensions: ["otg"]
      },
      "application/vnd.oasis.opendocument.image": {
        source: "iana",
        extensions: ["odi"]
      },
      "application/vnd.oasis.opendocument.image-template": {
        source: "iana",
        extensions: ["oti"]
      },
      "application/vnd.oasis.opendocument.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["odp"]
      },
      "application/vnd.oasis.opendocument.presentation-template": {
        source: "iana",
        extensions: ["otp"]
      },
      "application/vnd.oasis.opendocument.spreadsheet": {
        source: "iana",
        compressible: false,
        extensions: ["ods"]
      },
      "application/vnd.oasis.opendocument.spreadsheet-template": {
        source: "iana",
        extensions: ["ots"]
      },
      "application/vnd.oasis.opendocument.text": {
        source: "iana",
        compressible: false,
        extensions: ["odt"]
      },
      "application/vnd.oasis.opendocument.text-master": {
        source: "iana",
        extensions: ["odm"]
      },
      "application/vnd.oasis.opendocument.text-template": {
        source: "iana",
        extensions: ["ott"]
      },
      "application/vnd.oasis.opendocument.text-web": {
        source: "iana",
        extensions: ["oth"]
      },
      "application/vnd.obn": {
        source: "iana"
      },
      "application/vnd.ocf+cbor": {
        source: "iana"
      },
      "application/vnd.oci.image.manifest.v1+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oftn.l10n+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessdownload+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.contentaccessstreaming+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.cspg-hexbinary": {
        source: "iana"
      },
      "application/vnd.oipf.dae.svg+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.dae.xhtml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.mippvcontrolmessage+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.pae.gem": {
        source: "iana"
      },
      "application/vnd.oipf.spdiscovery+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.spdlist+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.ueprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oipf.userprofile+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.olpc-sugar": {
        source: "iana",
        extensions: ["xo"]
      },
      "application/vnd.oma-scws-config": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-request": {
        source: "iana"
      },
      "application/vnd.oma-scws-http-response": {
        source: "iana"
      },
      "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.drm-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.imd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.ltkm": {
        source: "iana"
      },
      "application/vnd.oma.bcast.notification+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.provisioningtrigger": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgboot": {
        source: "iana"
      },
      "application/vnd.oma.bcast.sgdd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sgdu": {
        source: "iana"
      },
      "application/vnd.oma.bcast.simple-symbol-container": {
        source: "iana"
      },
      "application/vnd.oma.bcast.smartcard-trigger+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.sprov+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.bcast.stkm": {
        source: "iana"
      },
      "application/vnd.oma.cab-address-book+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-feature-handler+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-pcc+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-subs-invite+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.cab-user-prefs+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.dcd": {
        source: "iana"
      },
      "application/vnd.oma.dcdc": {
        source: "iana"
      },
      "application/vnd.oma.dd2+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dd2"]
      },
      "application/vnd.oma.drm.risd+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.group-usage-list+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+cbor": {
        source: "iana"
      },
      "application/vnd.oma.lwm2m+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.lwm2m+tlv": {
        source: "iana"
      },
      "application/vnd.oma.pal+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.detailed-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.final-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.groups+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.invocation-descriptor+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.poc.optimized-progress-report+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.push": {
        source: "iana"
      },
      "application/vnd.oma.scidm.messages+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oma.xcap-directory+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.omads-email+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-file+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omads-folder+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.omaloc-supl-init": {
        source: "iana"
      },
      "application/vnd.onepager": {
        source: "iana"
      },
      "application/vnd.onepagertamp": {
        source: "iana"
      },
      "application/vnd.onepagertamx": {
        source: "iana"
      },
      "application/vnd.onepagertat": {
        source: "iana"
      },
      "application/vnd.onepagertatp": {
        source: "iana"
      },
      "application/vnd.onepagertatx": {
        source: "iana"
      },
      "application/vnd.openblox.game+xml": {
        source: "iana",
        compressible: true,
        extensions: ["obgx"]
      },
      "application/vnd.openblox.game-binary": {
        source: "iana"
      },
      "application/vnd.openeye.oeb": {
        source: "iana"
      },
      "application/vnd.openofficeorg.extension": {
        source: "apache",
        extensions: ["oxt"]
      },
      "application/vnd.openstreetmap.data+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osm"]
      },
      "application/vnd.opentimestamps.ots": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawing+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
        source: "iana",
        compressible: false,
        extensions: ["pptx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide": {
        source: "iana",
        extensions: ["sldx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
        source: "iana",
        extensions: ["ppsx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template": {
        source: "iana",
        extensions: ["potx"]
      },
      "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
        source: "iana",
        compressible: false,
        extensions: ["xlsx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
        source: "iana",
        extensions: ["xltx"]
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.theme+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.vmldrawing": {
        source: "iana"
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
        source: "iana",
        compressible: false,
        extensions: ["docx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
        source: "iana",
        extensions: ["dotx"]
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.core-properties+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.openxmlformats-package.relationships+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oracle.resource+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.orange.indata": {
        source: "iana"
      },
      "application/vnd.osa.netdeploy": {
        source: "iana"
      },
      "application/vnd.osgeo.mapguide.package": {
        source: "iana",
        extensions: ["mgp"]
      },
      "application/vnd.osgi.bundle": {
        source: "iana"
      },
      "application/vnd.osgi.dp": {
        source: "iana",
        extensions: ["dp"]
      },
      "application/vnd.osgi.subsystem": {
        source: "iana",
        extensions: ["esa"]
      },
      "application/vnd.otps.ct-kip+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.oxli.countgraph": {
        source: "iana"
      },
      "application/vnd.pagerduty+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.palm": {
        source: "iana",
        extensions: ["pdb", "pqa", "oprc"]
      },
      "application/vnd.panoply": {
        source: "iana"
      },
      "application/vnd.paos.xml": {
        source: "iana"
      },
      "application/vnd.patentdive": {
        source: "iana"
      },
      "application/vnd.patientecommsdoc": {
        source: "iana"
      },
      "application/vnd.pawaafile": {
        source: "iana",
        extensions: ["paw"]
      },
      "application/vnd.pcos": {
        source: "iana"
      },
      "application/vnd.pg.format": {
        source: "iana",
        extensions: ["str"]
      },
      "application/vnd.pg.osasli": {
        source: "iana",
        extensions: ["ei6"]
      },
      "application/vnd.piaccess.application-licence": {
        source: "iana"
      },
      "application/vnd.picsel": {
        source: "iana",
        extensions: ["efif"]
      },
      "application/vnd.pmi.widget": {
        source: "iana",
        extensions: ["wg"]
      },
      "application/vnd.poc.group-advertisement+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.pocketlearn": {
        source: "iana",
        extensions: ["plf"]
      },
      "application/vnd.powerbuilder6": {
        source: "iana",
        extensions: ["pbd"]
      },
      "application/vnd.powerbuilder6-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder7": {
        source: "iana"
      },
      "application/vnd.powerbuilder7-s": {
        source: "iana"
      },
      "application/vnd.powerbuilder75": {
        source: "iana"
      },
      "application/vnd.powerbuilder75-s": {
        source: "iana"
      },
      "application/vnd.preminet": {
        source: "iana"
      },
      "application/vnd.previewsystems.box": {
        source: "iana",
        extensions: ["box"]
      },
      "application/vnd.proteus.magazine": {
        source: "iana",
        extensions: ["mgz"]
      },
      "application/vnd.psfs": {
        source: "iana"
      },
      "application/vnd.publishare-delta-tree": {
        source: "iana",
        extensions: ["qps"]
      },
      "application/vnd.pvi.ptid1": {
        source: "iana",
        extensions: ["ptid"]
      },
      "application/vnd.pwg-multiplexed": {
        source: "iana"
      },
      "application/vnd.pwg-xhtml-print+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.qualcomm.brew-app-res": {
        source: "iana"
      },
      "application/vnd.quarantainenet": {
        source: "iana"
      },
      "application/vnd.quark.quarkxpress": {
        source: "iana",
        extensions: ["qxd", "qxt", "qwd", "qwt", "qxl", "qxb"]
      },
      "application/vnd.quobject-quoxdocument": {
        source: "iana"
      },
      "application/vnd.radisys.moml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-conn+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-audit-stream+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-conf+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-base+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-detect+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-group+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-speech+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.radisys.msml-dialog-transform+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rainstor.data": {
        source: "iana"
      },
      "application/vnd.rapid": {
        source: "iana"
      },
      "application/vnd.rar": {
        source: "iana",
        extensions: ["rar"]
      },
      "application/vnd.realvnc.bed": {
        source: "iana",
        extensions: ["bed"]
      },
      "application/vnd.recordare.musicxml": {
        source: "iana",
        extensions: ["mxl"]
      },
      "application/vnd.recordare.musicxml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["musicxml"]
      },
      "application/vnd.renlearn.rlprint": {
        source: "iana"
      },
      "application/vnd.resilient.logic": {
        source: "iana"
      },
      "application/vnd.restful+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.rig.cryptonote": {
        source: "iana",
        extensions: ["cryptonote"]
      },
      "application/vnd.rim.cod": {
        source: "apache",
        extensions: ["cod"]
      },
      "application/vnd.rn-realmedia": {
        source: "apache",
        extensions: ["rm"]
      },
      "application/vnd.rn-realmedia-vbr": {
        source: "apache",
        extensions: ["rmvb"]
      },
      "application/vnd.route66.link66+xml": {
        source: "iana",
        compressible: true,
        extensions: ["link66"]
      },
      "application/vnd.rs-274x": {
        source: "iana"
      },
      "application/vnd.ruckus.download": {
        source: "iana"
      },
      "application/vnd.s3sms": {
        source: "iana"
      },
      "application/vnd.sailingtracker.track": {
        source: "iana",
        extensions: ["st"]
      },
      "application/vnd.sar": {
        source: "iana"
      },
      "application/vnd.sbm.cid": {
        source: "iana"
      },
      "application/vnd.sbm.mid2": {
        source: "iana"
      },
      "application/vnd.scribus": {
        source: "iana"
      },
      "application/vnd.sealed.3df": {
        source: "iana"
      },
      "application/vnd.sealed.csf": {
        source: "iana"
      },
      "application/vnd.sealed.doc": {
        source: "iana"
      },
      "application/vnd.sealed.eml": {
        source: "iana"
      },
      "application/vnd.sealed.mht": {
        source: "iana"
      },
      "application/vnd.sealed.net": {
        source: "iana"
      },
      "application/vnd.sealed.ppt": {
        source: "iana"
      },
      "application/vnd.sealed.tiff": {
        source: "iana"
      },
      "application/vnd.sealed.xls": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.html": {
        source: "iana"
      },
      "application/vnd.sealedmedia.softseal.pdf": {
        source: "iana"
      },
      "application/vnd.seemail": {
        source: "iana",
        extensions: ["see"]
      },
      "application/vnd.seis+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.sema": {
        source: "iana",
        extensions: ["sema"]
      },
      "application/vnd.semd": {
        source: "iana",
        extensions: ["semd"]
      },
      "application/vnd.semf": {
        source: "iana",
        extensions: ["semf"]
      },
      "application/vnd.shade-save-file": {
        source: "iana"
      },
      "application/vnd.shana.informed.formdata": {
        source: "iana",
        extensions: ["ifm"]
      },
      "application/vnd.shana.informed.formtemplate": {
        source: "iana",
        extensions: ["itp"]
      },
      "application/vnd.shana.informed.interchange": {
        source: "iana",
        extensions: ["iif"]
      },
      "application/vnd.shana.informed.package": {
        source: "iana",
        extensions: ["ipk"]
      },
      "application/vnd.shootproof+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shopkick+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.shp": {
        source: "iana"
      },
      "application/vnd.shx": {
        source: "iana"
      },
      "application/vnd.sigrok.session": {
        source: "iana"
      },
      "application/vnd.simtech-mindmapper": {
        source: "iana",
        extensions: ["twd", "twds"]
      },
      "application/vnd.siren+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.smaf": {
        source: "iana",
        extensions: ["mmf"]
      },
      "application/vnd.smart.notebook": {
        source: "iana"
      },
      "application/vnd.smart.teacher": {
        source: "iana",
        extensions: ["teacher"]
      },
      "application/vnd.snesdev-page-table": {
        source: "iana"
      },
      "application/vnd.software602.filler.form+xml": {
        source: "iana",
        compressible: true,
        extensions: ["fo"]
      },
      "application/vnd.software602.filler.form-xml-zip": {
        source: "iana"
      },
      "application/vnd.solent.sdkm+xml": {
        source: "iana",
        compressible: true,
        extensions: ["sdkm", "sdkd"]
      },
      "application/vnd.spotfire.dxp": {
        source: "iana",
        extensions: ["dxp"]
      },
      "application/vnd.spotfire.sfs": {
        source: "iana",
        extensions: ["sfs"]
      },
      "application/vnd.sqlite3": {
        source: "iana"
      },
      "application/vnd.sss-cod": {
        source: "iana"
      },
      "application/vnd.sss-dtf": {
        source: "iana"
      },
      "application/vnd.sss-ntf": {
        source: "iana"
      },
      "application/vnd.stardivision.calc": {
        source: "apache",
        extensions: ["sdc"]
      },
      "application/vnd.stardivision.draw": {
        source: "apache",
        extensions: ["sda"]
      },
      "application/vnd.stardivision.impress": {
        source: "apache",
        extensions: ["sdd"]
      },
      "application/vnd.stardivision.math": {
        source: "apache",
        extensions: ["smf"]
      },
      "application/vnd.stardivision.writer": {
        source: "apache",
        extensions: ["sdw", "vor"]
      },
      "application/vnd.stardivision.writer-global": {
        source: "apache",
        extensions: ["sgl"]
      },
      "application/vnd.stepmania.package": {
        source: "iana",
        extensions: ["smzip"]
      },
      "application/vnd.stepmania.stepchart": {
        source: "iana",
        extensions: ["sm"]
      },
      "application/vnd.street-stream": {
        source: "iana"
      },
      "application/vnd.sun.wadl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wadl"]
      },
      "application/vnd.sun.xml.calc": {
        source: "apache",
        extensions: ["sxc"]
      },
      "application/vnd.sun.xml.calc.template": {
        source: "apache",
        extensions: ["stc"]
      },
      "application/vnd.sun.xml.draw": {
        source: "apache",
        extensions: ["sxd"]
      },
      "application/vnd.sun.xml.draw.template": {
        source: "apache",
        extensions: ["std"]
      },
      "application/vnd.sun.xml.impress": {
        source: "apache",
        extensions: ["sxi"]
      },
      "application/vnd.sun.xml.impress.template": {
        source: "apache",
        extensions: ["sti"]
      },
      "application/vnd.sun.xml.math": {
        source: "apache",
        extensions: ["sxm"]
      },
      "application/vnd.sun.xml.writer": {
        source: "apache",
        extensions: ["sxw"]
      },
      "application/vnd.sun.xml.writer.global": {
        source: "apache",
        extensions: ["sxg"]
      },
      "application/vnd.sun.xml.writer.template": {
        source: "apache",
        extensions: ["stw"]
      },
      "application/vnd.sus-calendar": {
        source: "iana",
        extensions: ["sus", "susp"]
      },
      "application/vnd.svd": {
        source: "iana",
        extensions: ["svd"]
      },
      "application/vnd.swiftview-ics": {
        source: "iana"
      },
      "application/vnd.sycle+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.syft+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.symbian.install": {
        source: "apache",
        extensions: ["sis", "sisx"]
      },
      "application/vnd.syncml+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xsm"]
      },
      "application/vnd.syncml.dm+wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["bdm"]
      },
      "application/vnd.syncml.dm+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["xdm"]
      },
      "application/vnd.syncml.dm.notification": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmddf+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["ddf"]
      },
      "application/vnd.syncml.dmtnds+wbxml": {
        source: "iana"
      },
      "application/vnd.syncml.dmtnds+xml": {
        source: "iana",
        charset: "UTF-8",
        compressible: true
      },
      "application/vnd.syncml.ds.notification": {
        source: "iana"
      },
      "application/vnd.tableschema+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tao.intent-module-archive": {
        source: "iana",
        extensions: ["tao"]
      },
      "application/vnd.tcpdump.pcap": {
        source: "iana",
        extensions: ["pcap", "cap", "dmp"]
      },
      "application/vnd.think-cell.ppttc+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tmd.mediaflex.api+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.tml": {
        source: "iana"
      },
      "application/vnd.tmobile-livetv": {
        source: "iana",
        extensions: ["tmo"]
      },
      "application/vnd.tri.onesource": {
        source: "iana"
      },
      "application/vnd.trid.tpt": {
        source: "iana",
        extensions: ["tpt"]
      },
      "application/vnd.triscape.mxs": {
        source: "iana",
        extensions: ["mxs"]
      },
      "application/vnd.trueapp": {
        source: "iana",
        extensions: ["tra"]
      },
      "application/vnd.truedoc": {
        source: "iana"
      },
      "application/vnd.ubisoft.webplayer": {
        source: "iana"
      },
      "application/vnd.ufdl": {
        source: "iana",
        extensions: ["ufd", "ufdl"]
      },
      "application/vnd.uiq.theme": {
        source: "iana",
        extensions: ["utz"]
      },
      "application/vnd.umajin": {
        source: "iana",
        extensions: ["umj"]
      },
      "application/vnd.unity": {
        source: "iana",
        extensions: ["unityweb"]
      },
      "application/vnd.uoml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["uoml"]
      },
      "application/vnd.uplanet.alert": {
        source: "iana"
      },
      "application/vnd.uplanet.alert-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice": {
        source: "iana"
      },
      "application/vnd.uplanet.bearer-choice-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop": {
        source: "iana"
      },
      "application/vnd.uplanet.cacheop-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.channel": {
        source: "iana"
      },
      "application/vnd.uplanet.channel-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.list": {
        source: "iana"
      },
      "application/vnd.uplanet.list-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd": {
        source: "iana"
      },
      "application/vnd.uplanet.listcmd-wbxml": {
        source: "iana"
      },
      "application/vnd.uplanet.signal": {
        source: "iana"
      },
      "application/vnd.uri-map": {
        source: "iana"
      },
      "application/vnd.valve.source.material": {
        source: "iana"
      },
      "application/vnd.vcx": {
        source: "iana",
        extensions: ["vcx"]
      },
      "application/vnd.vd-study": {
        source: "iana"
      },
      "application/vnd.vectorworks": {
        source: "iana"
      },
      "application/vnd.vel+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.verimatrix.vcas": {
        source: "iana"
      },
      "application/vnd.veritone.aion+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.veryant.thin": {
        source: "iana"
      },
      "application/vnd.ves.encrypted": {
        source: "iana"
      },
      "application/vnd.vidsoft.vidconference": {
        source: "iana"
      },
      "application/vnd.visio": {
        source: "iana",
        extensions: ["vsd", "vst", "vss", "vsw"]
      },
      "application/vnd.visionary": {
        source: "iana",
        extensions: ["vis"]
      },
      "application/vnd.vividence.scriptfile": {
        source: "iana"
      },
      "application/vnd.vsf": {
        source: "iana",
        extensions: ["vsf"]
      },
      "application/vnd.wap.sic": {
        source: "iana"
      },
      "application/vnd.wap.slc": {
        source: "iana"
      },
      "application/vnd.wap.wbxml": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["wbxml"]
      },
      "application/vnd.wap.wmlc": {
        source: "iana",
        extensions: ["wmlc"]
      },
      "application/vnd.wap.wmlscriptc": {
        source: "iana",
        extensions: ["wmlsc"]
      },
      "application/vnd.webturbo": {
        source: "iana",
        extensions: ["wtb"]
      },
      "application/vnd.wfa.dpp": {
        source: "iana"
      },
      "application/vnd.wfa.p2p": {
        source: "iana"
      },
      "application/vnd.wfa.wsc": {
        source: "iana"
      },
      "application/vnd.windows.devicepairing": {
        source: "iana"
      },
      "application/vnd.wmc": {
        source: "iana"
      },
      "application/vnd.wmf.bootstrap": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica": {
        source: "iana"
      },
      "application/vnd.wolfram.mathematica.package": {
        source: "iana"
      },
      "application/vnd.wolfram.player": {
        source: "iana",
        extensions: ["nbp"]
      },
      "application/vnd.wordperfect": {
        source: "iana",
        extensions: ["wpd"]
      },
      "application/vnd.wqd": {
        source: "iana",
        extensions: ["wqd"]
      },
      "application/vnd.wrq-hp3000-labelled": {
        source: "iana"
      },
      "application/vnd.wt.stf": {
        source: "iana",
        extensions: ["stf"]
      },
      "application/vnd.wv.csp+wbxml": {
        source: "iana"
      },
      "application/vnd.wv.csp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.wv.ssp+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xacml+json": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xara": {
        source: "iana",
        extensions: ["xar"]
      },
      "application/vnd.xfdl": {
        source: "iana",
        extensions: ["xfdl"]
      },
      "application/vnd.xfdl.webform": {
        source: "iana"
      },
      "application/vnd.xmi+xml": {
        source: "iana",
        compressible: true
      },
      "application/vnd.xmpie.cpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.dpkg": {
        source: "iana"
      },
      "application/vnd.xmpie.plan": {
        source: "iana"
      },
      "application/vnd.xmpie.ppkg": {
        source: "iana"
      },
      "application/vnd.xmpie.xlim": {
        source: "iana"
      },
      "application/vnd.yamaha.hv-dic": {
        source: "iana",
        extensions: ["hvd"]
      },
      "application/vnd.yamaha.hv-script": {
        source: "iana",
        extensions: ["hvs"]
      },
      "application/vnd.yamaha.hv-voice": {
        source: "iana",
        extensions: ["hvp"]
      },
      "application/vnd.yamaha.openscoreformat": {
        source: "iana",
        extensions: ["osf"]
      },
      "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["osfpvg"]
      },
      "application/vnd.yamaha.remote-setup": {
        source: "iana"
      },
      "application/vnd.yamaha.smaf-audio": {
        source: "iana",
        extensions: ["saf"]
      },
      "application/vnd.yamaha.smaf-phrase": {
        source: "iana",
        extensions: ["spf"]
      },
      "application/vnd.yamaha.through-ngn": {
        source: "iana"
      },
      "application/vnd.yamaha.tunnel-udpencap": {
        source: "iana"
      },
      "application/vnd.yaoweme": {
        source: "iana"
      },
      "application/vnd.yellowriver-custom-menu": {
        source: "iana",
        extensions: ["cmp"]
      },
      "application/vnd.youtube.yt": {
        source: "iana"
      },
      "application/vnd.zul": {
        source: "iana",
        extensions: ["zir", "zirz"]
      },
      "application/vnd.zzazz.deck+xml": {
        source: "iana",
        compressible: true,
        extensions: ["zaz"]
      },
      "application/voicexml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["vxml"]
      },
      "application/voucher-cms+json": {
        source: "iana",
        compressible: true
      },
      "application/vq-rtcpxr": {
        source: "iana"
      },
      "application/wasm": {
        source: "iana",
        compressible: true,
        extensions: ["wasm"]
      },
      "application/watcherinfo+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wif"]
      },
      "application/webpush-options+json": {
        source: "iana",
        compressible: true
      },
      "application/whoispp-query": {
        source: "iana"
      },
      "application/whoispp-response": {
        source: "iana"
      },
      "application/widget": {
        source: "iana",
        extensions: ["wgt"]
      },
      "application/winhlp": {
        source: "apache",
        extensions: ["hlp"]
      },
      "application/wita": {
        source: "iana"
      },
      "application/wordperfect5.1": {
        source: "iana"
      },
      "application/wsdl+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wsdl"]
      },
      "application/wspolicy+xml": {
        source: "iana",
        compressible: true,
        extensions: ["wspolicy"]
      },
      "application/x-7z-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["7z"]
      },
      "application/x-abiword": {
        source: "apache",
        extensions: ["abw"]
      },
      "application/x-ace-compressed": {
        source: "apache",
        extensions: ["ace"]
      },
      "application/x-amf": {
        source: "apache"
      },
      "application/x-apple-diskimage": {
        source: "apache",
        extensions: ["dmg"]
      },
      "application/x-arj": {
        compressible: false,
        extensions: ["arj"]
      },
      "application/x-authorware-bin": {
        source: "apache",
        extensions: ["aab", "x32", "u32", "vox"]
      },
      "application/x-authorware-map": {
        source: "apache",
        extensions: ["aam"]
      },
      "application/x-authorware-seg": {
        source: "apache",
        extensions: ["aas"]
      },
      "application/x-bcpio": {
        source: "apache",
        extensions: ["bcpio"]
      },
      "application/x-bdoc": {
        compressible: false,
        extensions: ["bdoc"]
      },
      "application/x-bittorrent": {
        source: "apache",
        extensions: ["torrent"]
      },
      "application/x-blorb": {
        source: "apache",
        extensions: ["blb", "blorb"]
      },
      "application/x-bzip": {
        source: "apache",
        compressible: false,
        extensions: ["bz"]
      },
      "application/x-bzip2": {
        source: "apache",
        compressible: false,
        extensions: ["bz2", "boz"]
      },
      "application/x-cbr": {
        source: "apache",
        extensions: ["cbr", "cba", "cbt", "cbz", "cb7"]
      },
      "application/x-cdlink": {
        source: "apache",
        extensions: ["vcd"]
      },
      "application/x-cfs-compressed": {
        source: "apache",
        extensions: ["cfs"]
      },
      "application/x-chat": {
        source: "apache",
        extensions: ["chat"]
      },
      "application/x-chess-pgn": {
        source: "apache",
        extensions: ["pgn"]
      },
      "application/x-chrome-extension": {
        extensions: ["crx"]
      },
      "application/x-cocoa": {
        source: "nginx",
        extensions: ["cco"]
      },
      "application/x-compress": {
        source: "apache"
      },
      "application/x-conference": {
        source: "apache",
        extensions: ["nsc"]
      },
      "application/x-cpio": {
        source: "apache",
        extensions: ["cpio"]
      },
      "application/x-csh": {
        source: "apache",
        extensions: ["csh"]
      },
      "application/x-deb": {
        compressible: false
      },
      "application/x-debian-package": {
        source: "apache",
        extensions: ["deb", "udeb"]
      },
      "application/x-dgc-compressed": {
        source: "apache",
        extensions: ["dgc"]
      },
      "application/x-director": {
        source: "apache",
        extensions: ["dir", "dcr", "dxr", "cst", "cct", "cxt", "w3d", "fgd", "swa"]
      },
      "application/x-doom": {
        source: "apache",
        extensions: ["wad"]
      },
      "application/x-dtbncx+xml": {
        source: "apache",
        compressible: true,
        extensions: ["ncx"]
      },
      "application/x-dtbook+xml": {
        source: "apache",
        compressible: true,
        extensions: ["dtb"]
      },
      "application/x-dtbresource+xml": {
        source: "apache",
        compressible: true,
        extensions: ["res"]
      },
      "application/x-dvi": {
        source: "apache",
        compressible: false,
        extensions: ["dvi"]
      },
      "application/x-envoy": {
        source: "apache",
        extensions: ["evy"]
      },
      "application/x-eva": {
        source: "apache",
        extensions: ["eva"]
      },
      "application/x-font-bdf": {
        source: "apache",
        extensions: ["bdf"]
      },
      "application/x-font-dos": {
        source: "apache"
      },
      "application/x-font-framemaker": {
        source: "apache"
      },
      "application/x-font-ghostscript": {
        source: "apache",
        extensions: ["gsf"]
      },
      "application/x-font-libgrx": {
        source: "apache"
      },
      "application/x-font-linux-psf": {
        source: "apache",
        extensions: ["psf"]
      },
      "application/x-font-pcf": {
        source: "apache",
        extensions: ["pcf"]
      },
      "application/x-font-snf": {
        source: "apache",
        extensions: ["snf"]
      },
      "application/x-font-speedo": {
        source: "apache"
      },
      "application/x-font-sunos-news": {
        source: "apache"
      },
      "application/x-font-type1": {
        source: "apache",
        extensions: ["pfa", "pfb", "pfm", "afm"]
      },
      "application/x-font-vfont": {
        source: "apache"
      },
      "application/x-freearc": {
        source: "apache",
        extensions: ["arc"]
      },
      "application/x-futuresplash": {
        source: "apache",
        extensions: ["spl"]
      },
      "application/x-gca-compressed": {
        source: "apache",
        extensions: ["gca"]
      },
      "application/x-glulx": {
        source: "apache",
        extensions: ["ulx"]
      },
      "application/x-gnumeric": {
        source: "apache",
        extensions: ["gnumeric"]
      },
      "application/x-gramps-xml": {
        source: "apache",
        extensions: ["gramps"]
      },
      "application/x-gtar": {
        source: "apache",
        extensions: ["gtar"]
      },
      "application/x-gzip": {
        source: "apache"
      },
      "application/x-hdf": {
        source: "apache",
        extensions: ["hdf"]
      },
      "application/x-httpd-php": {
        compressible: true,
        extensions: ["php"]
      },
      "application/x-install-instructions": {
        source: "apache",
        extensions: ["install"]
      },
      "application/x-iso9660-image": {
        source: "apache",
        extensions: ["iso"]
      },
      "application/x-iwork-keynote-sffkey": {
        extensions: ["key"]
      },
      "application/x-iwork-numbers-sffnumbers": {
        extensions: ["numbers"]
      },
      "application/x-iwork-pages-sffpages": {
        extensions: ["pages"]
      },
      "application/x-java-archive-diff": {
        source: "nginx",
        extensions: ["jardiff"]
      },
      "application/x-java-jnlp-file": {
        source: "apache",
        compressible: false,
        extensions: ["jnlp"]
      },
      "application/x-javascript": {
        compressible: true
      },
      "application/x-keepass2": {
        extensions: ["kdbx"]
      },
      "application/x-latex": {
        source: "apache",
        compressible: false,
        extensions: ["latex"]
      },
      "application/x-lua-bytecode": {
        extensions: ["luac"]
      },
      "application/x-lzh-compressed": {
        source: "apache",
        extensions: ["lzh", "lha"]
      },
      "application/x-makeself": {
        source: "nginx",
        extensions: ["run"]
      },
      "application/x-mie": {
        source: "apache",
        extensions: ["mie"]
      },
      "application/x-mobipocket-ebook": {
        source: "apache",
        extensions: ["prc", "mobi"]
      },
      "application/x-mpegurl": {
        compressible: false
      },
      "application/x-ms-application": {
        source: "apache",
        extensions: ["application"]
      },
      "application/x-ms-shortcut": {
        source: "apache",
        extensions: ["lnk"]
      },
      "application/x-ms-wmd": {
        source: "apache",
        extensions: ["wmd"]
      },
      "application/x-ms-wmz": {
        source: "apache",
        extensions: ["wmz"]
      },
      "application/x-ms-xbap": {
        source: "apache",
        extensions: ["xbap"]
      },
      "application/x-msaccess": {
        source: "apache",
        extensions: ["mdb"]
      },
      "application/x-msbinder": {
        source: "apache",
        extensions: ["obd"]
      },
      "application/x-mscardfile": {
        source: "apache",
        extensions: ["crd"]
      },
      "application/x-msclip": {
        source: "apache",
        extensions: ["clp"]
      },
      "application/x-msdos-program": {
        extensions: ["exe"]
      },
      "application/x-msdownload": {
        source: "apache",
        extensions: ["exe", "dll", "com", "bat", "msi"]
      },
      "application/x-msmediaview": {
        source: "apache",
        extensions: ["mvb", "m13", "m14"]
      },
      "application/x-msmetafile": {
        source: "apache",
        extensions: ["wmf", "wmz", "emf", "emz"]
      },
      "application/x-msmoney": {
        source: "apache",
        extensions: ["mny"]
      },
      "application/x-mspublisher": {
        source: "apache",
        extensions: ["pub"]
      },
      "application/x-msschedule": {
        source: "apache",
        extensions: ["scd"]
      },
      "application/x-msterminal": {
        source: "apache",
        extensions: ["trm"]
      },
      "application/x-mswrite": {
        source: "apache",
        extensions: ["wri"]
      },
      "application/x-netcdf": {
        source: "apache",
        extensions: ["nc", "cdf"]
      },
      "application/x-ns-proxy-autoconfig": {
        compressible: true,
        extensions: ["pac"]
      },
      "application/x-nzb": {
        source: "apache",
        extensions: ["nzb"]
      },
      "application/x-perl": {
        source: "nginx",
        extensions: ["pl", "pm"]
      },
      "application/x-pilot": {
        source: "nginx",
        extensions: ["prc", "pdb"]
      },
      "application/x-pkcs12": {
        source: "apache",
        compressible: false,
        extensions: ["p12", "pfx"]
      },
      "application/x-pkcs7-certificates": {
        source: "apache",
        extensions: ["p7b", "spc"]
      },
      "application/x-pkcs7-certreqresp": {
        source: "apache",
        extensions: ["p7r"]
      },
      "application/x-pki-message": {
        source: "iana"
      },
      "application/x-rar-compressed": {
        source: "apache",
        compressible: false,
        extensions: ["rar"]
      },
      "application/x-redhat-package-manager": {
        source: "nginx",
        extensions: ["rpm"]
      },
      "application/x-research-info-systems": {
        source: "apache",
        extensions: ["ris"]
      },
      "application/x-sea": {
        source: "nginx",
        extensions: ["sea"]
      },
      "application/x-sh": {
        source: "apache",
        compressible: true,
        extensions: ["sh"]
      },
      "application/x-shar": {
        source: "apache",
        extensions: ["shar"]
      },
      "application/x-shockwave-flash": {
        source: "apache",
        compressible: false,
        extensions: ["swf"]
      },
      "application/x-silverlight-app": {
        source: "apache",
        extensions: ["xap"]
      },
      "application/x-sql": {
        source: "apache",
        extensions: ["sql"]
      },
      "application/x-stuffit": {
        source: "apache",
        compressible: false,
        extensions: ["sit"]
      },
      "application/x-stuffitx": {
        source: "apache",
        extensions: ["sitx"]
      },
      "application/x-subrip": {
        source: "apache",
        extensions: ["srt"]
      },
      "application/x-sv4cpio": {
        source: "apache",
        extensions: ["sv4cpio"]
      },
      "application/x-sv4crc": {
        source: "apache",
        extensions: ["sv4crc"]
      },
      "application/x-t3vm-image": {
        source: "apache",
        extensions: ["t3"]
      },
      "application/x-tads": {
        source: "apache",
        extensions: ["gam"]
      },
      "application/x-tar": {
        source: "apache",
        compressible: true,
        extensions: ["tar"]
      },
      "application/x-tcl": {
        source: "apache",
        extensions: ["tcl", "tk"]
      },
      "application/x-tex": {
        source: "apache",
        extensions: ["tex"]
      },
      "application/x-tex-tfm": {
        source: "apache",
        extensions: ["tfm"]
      },
      "application/x-texinfo": {
        source: "apache",
        extensions: ["texinfo", "texi"]
      },
      "application/x-tgif": {
        source: "apache",
        extensions: ["obj"]
      },
      "application/x-ustar": {
        source: "apache",
        extensions: ["ustar"]
      },
      "application/x-virtualbox-hdd": {
        compressible: true,
        extensions: ["hdd"]
      },
      "application/x-virtualbox-ova": {
        compressible: true,
        extensions: ["ova"]
      },
      "application/x-virtualbox-ovf": {
        compressible: true,
        extensions: ["ovf"]
      },
      "application/x-virtualbox-vbox": {
        compressible: true,
        extensions: ["vbox"]
      },
      "application/x-virtualbox-vbox-extpack": {
        compressible: false,
        extensions: ["vbox-extpack"]
      },
      "application/x-virtualbox-vdi": {
        compressible: true,
        extensions: ["vdi"]
      },
      "application/x-virtualbox-vhd": {
        compressible: true,
        extensions: ["vhd"]
      },
      "application/x-virtualbox-vmdk": {
        compressible: true,
        extensions: ["vmdk"]
      },
      "application/x-wais-source": {
        source: "apache",
        extensions: ["src"]
      },
      "application/x-web-app-manifest+json": {
        compressible: true,
        extensions: ["webapp"]
      },
      "application/x-www-form-urlencoded": {
        source: "iana",
        compressible: true
      },
      "application/x-x509-ca-cert": {
        source: "iana",
        extensions: ["der", "crt", "pem"]
      },
      "application/x-x509-ca-ra-cert": {
        source: "iana"
      },
      "application/x-x509-next-ca-cert": {
        source: "iana"
      },
      "application/x-xfig": {
        source: "apache",
        extensions: ["fig"]
      },
      "application/x-xliff+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/x-xpinstall": {
        source: "apache",
        compressible: false,
        extensions: ["xpi"]
      },
      "application/x-xz": {
        source: "apache",
        extensions: ["xz"]
      },
      "application/x-zmachine": {
        source: "apache",
        extensions: ["z1", "z2", "z3", "z4", "z5", "z6", "z7", "z8"]
      },
      "application/x400-bp": {
        source: "iana"
      },
      "application/xacml+xml": {
        source: "iana",
        compressible: true
      },
      "application/xaml+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xaml"]
      },
      "application/xcap-att+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xav"]
      },
      "application/xcap-caps+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xca"]
      },
      "application/xcap-diff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xdf"]
      },
      "application/xcap-el+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xel"]
      },
      "application/xcap-error+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcap-ns+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xns"]
      },
      "application/xcon-conference-info+xml": {
        source: "iana",
        compressible: true
      },
      "application/xcon-conference-info-diff+xml": {
        source: "iana",
        compressible: true
      },
      "application/xenc+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xenc"]
      },
      "application/xhtml+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xhtml", "xht"]
      },
      "application/xhtml-voice+xml": {
        source: "apache",
        compressible: true
      },
      "application/xliff+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xlf"]
      },
      "application/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml", "xsl", "xsd", "rng"]
      },
      "application/xml-dtd": {
        source: "iana",
        compressible: true,
        extensions: ["dtd"]
      },
      "application/xml-external-parsed-entity": {
        source: "iana"
      },
      "application/xml-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/xmpp+xml": {
        source: "iana",
        compressible: true
      },
      "application/xop+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xop"]
      },
      "application/xproc+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xpl"]
      },
      "application/xslt+xml": {
        source: "iana",
        compressible: true,
        extensions: ["xsl", "xslt"]
      },
      "application/xspf+xml": {
        source: "apache",
        compressible: true,
        extensions: ["xspf"]
      },
      "application/xv+xml": {
        source: "iana",
        compressible: true,
        extensions: ["mxml", "xhvml", "xvml", "xvm"]
      },
      "application/yang": {
        source: "iana",
        extensions: ["yang"]
      },
      "application/yang-data+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-data+xml": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+json": {
        source: "iana",
        compressible: true
      },
      "application/yang-patch+xml": {
        source: "iana",
        compressible: true
      },
      "application/yin+xml": {
        source: "iana",
        compressible: true,
        extensions: ["yin"]
      },
      "application/zip": {
        source: "iana",
        compressible: false,
        extensions: ["zip"]
      },
      "application/zlib": {
        source: "iana"
      },
      "application/zstd": {
        source: "iana"
      },
      "audio/1d-interleaved-parityfec": {
        source: "iana"
      },
      "audio/32kadpcm": {
        source: "iana"
      },
      "audio/3gpp": {
        source: "iana",
        compressible: false,
        extensions: ["3gpp"]
      },
      "audio/3gpp2": {
        source: "iana"
      },
      "audio/aac": {
        source: "iana"
      },
      "audio/ac3": {
        source: "iana"
      },
      "audio/adpcm": {
        source: "apache",
        extensions: ["adp"]
      },
      "audio/amr": {
        source: "iana",
        extensions: ["amr"]
      },
      "audio/amr-wb": {
        source: "iana"
      },
      "audio/amr-wb+": {
        source: "iana"
      },
      "audio/aptx": {
        source: "iana"
      },
      "audio/asc": {
        source: "iana"
      },
      "audio/atrac-advanced-lossless": {
        source: "iana"
      },
      "audio/atrac-x": {
        source: "iana"
      },
      "audio/atrac3": {
        source: "iana"
      },
      "audio/basic": {
        source: "iana",
        compressible: false,
        extensions: ["au", "snd"]
      },
      "audio/bv16": {
        source: "iana"
      },
      "audio/bv32": {
        source: "iana"
      },
      "audio/clearmode": {
        source: "iana"
      },
      "audio/cn": {
        source: "iana"
      },
      "audio/dat12": {
        source: "iana"
      },
      "audio/dls": {
        source: "iana"
      },
      "audio/dsr-es201108": {
        source: "iana"
      },
      "audio/dsr-es202050": {
        source: "iana"
      },
      "audio/dsr-es202211": {
        source: "iana"
      },
      "audio/dsr-es202212": {
        source: "iana"
      },
      "audio/dv": {
        source: "iana"
      },
      "audio/dvi4": {
        source: "iana"
      },
      "audio/eac3": {
        source: "iana"
      },
      "audio/encaprtp": {
        source: "iana"
      },
      "audio/evrc": {
        source: "iana"
      },
      "audio/evrc-qcp": {
        source: "iana"
      },
      "audio/evrc0": {
        source: "iana"
      },
      "audio/evrc1": {
        source: "iana"
      },
      "audio/evrcb": {
        source: "iana"
      },
      "audio/evrcb0": {
        source: "iana"
      },
      "audio/evrcb1": {
        source: "iana"
      },
      "audio/evrcnw": {
        source: "iana"
      },
      "audio/evrcnw0": {
        source: "iana"
      },
      "audio/evrcnw1": {
        source: "iana"
      },
      "audio/evrcwb": {
        source: "iana"
      },
      "audio/evrcwb0": {
        source: "iana"
      },
      "audio/evrcwb1": {
        source: "iana"
      },
      "audio/evs": {
        source: "iana"
      },
      "audio/flexfec": {
        source: "iana"
      },
      "audio/fwdred": {
        source: "iana"
      },
      "audio/g711-0": {
        source: "iana"
      },
      "audio/g719": {
        source: "iana"
      },
      "audio/g722": {
        source: "iana"
      },
      "audio/g7221": {
        source: "iana"
      },
      "audio/g723": {
        source: "iana"
      },
      "audio/g726-16": {
        source: "iana"
      },
      "audio/g726-24": {
        source: "iana"
      },
      "audio/g726-32": {
        source: "iana"
      },
      "audio/g726-40": {
        source: "iana"
      },
      "audio/g728": {
        source: "iana"
      },
      "audio/g729": {
        source: "iana"
      },
      "audio/g7291": {
        source: "iana"
      },
      "audio/g729d": {
        source: "iana"
      },
      "audio/g729e": {
        source: "iana"
      },
      "audio/gsm": {
        source: "iana"
      },
      "audio/gsm-efr": {
        source: "iana"
      },
      "audio/gsm-hr-08": {
        source: "iana"
      },
      "audio/ilbc": {
        source: "iana"
      },
      "audio/ip-mr_v2.5": {
        source: "iana"
      },
      "audio/isac": {
        source: "apache"
      },
      "audio/l16": {
        source: "iana"
      },
      "audio/l20": {
        source: "iana"
      },
      "audio/l24": {
        source: "iana",
        compressible: false
      },
      "audio/l8": {
        source: "iana"
      },
      "audio/lpc": {
        source: "iana"
      },
      "audio/melp": {
        source: "iana"
      },
      "audio/melp1200": {
        source: "iana"
      },
      "audio/melp2400": {
        source: "iana"
      },
      "audio/melp600": {
        source: "iana"
      },
      "audio/mhas": {
        source: "iana"
      },
      "audio/midi": {
        source: "apache",
        extensions: ["mid", "midi", "kar", "rmi"]
      },
      "audio/mobile-xmf": {
        source: "iana",
        extensions: ["mxmf"]
      },
      "audio/mp3": {
        compressible: false,
        extensions: ["mp3"]
      },
      "audio/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["m4a", "mp4a"]
      },
      "audio/mp4a-latm": {
        source: "iana"
      },
      "audio/mpa": {
        source: "iana"
      },
      "audio/mpa-robust": {
        source: "iana"
      },
      "audio/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpga", "mp2", "mp2a", "mp3", "m2a", "m3a"]
      },
      "audio/mpeg4-generic": {
        source: "iana"
      },
      "audio/musepack": {
        source: "apache"
      },
      "audio/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["oga", "ogg", "spx", "opus"]
      },
      "audio/opus": {
        source: "iana"
      },
      "audio/parityfec": {
        source: "iana"
      },
      "audio/pcma": {
        source: "iana"
      },
      "audio/pcma-wb": {
        source: "iana"
      },
      "audio/pcmu": {
        source: "iana"
      },
      "audio/pcmu-wb": {
        source: "iana"
      },
      "audio/prs.sid": {
        source: "iana"
      },
      "audio/qcelp": {
        source: "iana"
      },
      "audio/raptorfec": {
        source: "iana"
      },
      "audio/red": {
        source: "iana"
      },
      "audio/rtp-enc-aescm128": {
        source: "iana"
      },
      "audio/rtp-midi": {
        source: "iana"
      },
      "audio/rtploopback": {
        source: "iana"
      },
      "audio/rtx": {
        source: "iana"
      },
      "audio/s3m": {
        source: "apache",
        extensions: ["s3m"]
      },
      "audio/scip": {
        source: "iana"
      },
      "audio/silk": {
        source: "apache",
        extensions: ["sil"]
      },
      "audio/smv": {
        source: "iana"
      },
      "audio/smv-qcp": {
        source: "iana"
      },
      "audio/smv0": {
        source: "iana"
      },
      "audio/sofa": {
        source: "iana"
      },
      "audio/sp-midi": {
        source: "iana"
      },
      "audio/speex": {
        source: "iana"
      },
      "audio/t140c": {
        source: "iana"
      },
      "audio/t38": {
        source: "iana"
      },
      "audio/telephone-event": {
        source: "iana"
      },
      "audio/tetra_acelp": {
        source: "iana"
      },
      "audio/tetra_acelp_bb": {
        source: "iana"
      },
      "audio/tone": {
        source: "iana"
      },
      "audio/tsvcis": {
        source: "iana"
      },
      "audio/uemclip": {
        source: "iana"
      },
      "audio/ulpfec": {
        source: "iana"
      },
      "audio/usac": {
        source: "iana"
      },
      "audio/vdvi": {
        source: "iana"
      },
      "audio/vmr-wb": {
        source: "iana"
      },
      "audio/vnd.3gpp.iufp": {
        source: "iana"
      },
      "audio/vnd.4sb": {
        source: "iana"
      },
      "audio/vnd.audiokoz": {
        source: "iana"
      },
      "audio/vnd.celp": {
        source: "iana"
      },
      "audio/vnd.cisco.nse": {
        source: "iana"
      },
      "audio/vnd.cmles.radio-events": {
        source: "iana"
      },
      "audio/vnd.cns.anp1": {
        source: "iana"
      },
      "audio/vnd.cns.inf1": {
        source: "iana"
      },
      "audio/vnd.dece.audio": {
        source: "iana",
        extensions: ["uva", "uvva"]
      },
      "audio/vnd.digital-winds": {
        source: "iana",
        extensions: ["eol"]
      },
      "audio/vnd.dlna.adts": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.1": {
        source: "iana"
      },
      "audio/vnd.dolby.heaac.2": {
        source: "iana"
      },
      "audio/vnd.dolby.mlp": {
        source: "iana"
      },
      "audio/vnd.dolby.mps": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2x": {
        source: "iana"
      },
      "audio/vnd.dolby.pl2z": {
        source: "iana"
      },
      "audio/vnd.dolby.pulse.1": {
        source: "iana"
      },
      "audio/vnd.dra": {
        source: "iana",
        extensions: ["dra"]
      },
      "audio/vnd.dts": {
        source: "iana",
        extensions: ["dts"]
      },
      "audio/vnd.dts.hd": {
        source: "iana",
        extensions: ["dtshd"]
      },
      "audio/vnd.dts.uhd": {
        source: "iana"
      },
      "audio/vnd.dvb.file": {
        source: "iana"
      },
      "audio/vnd.everad.plj": {
        source: "iana"
      },
      "audio/vnd.hns.audio": {
        source: "iana"
      },
      "audio/vnd.lucent.voice": {
        source: "iana",
        extensions: ["lvp"]
      },
      "audio/vnd.ms-playready.media.pya": {
        source: "iana",
        extensions: ["pya"]
      },
      "audio/vnd.nokia.mobile-xmf": {
        source: "iana"
      },
      "audio/vnd.nortel.vbk": {
        source: "iana"
      },
      "audio/vnd.nuera.ecelp4800": {
        source: "iana",
        extensions: ["ecelp4800"]
      },
      "audio/vnd.nuera.ecelp7470": {
        source: "iana",
        extensions: ["ecelp7470"]
      },
      "audio/vnd.nuera.ecelp9600": {
        source: "iana",
        extensions: ["ecelp9600"]
      },
      "audio/vnd.octel.sbc": {
        source: "iana"
      },
      "audio/vnd.presonus.multitrack": {
        source: "iana"
      },
      "audio/vnd.qcelp": {
        source: "iana"
      },
      "audio/vnd.rhetorex.32kadpcm": {
        source: "iana"
      },
      "audio/vnd.rip": {
        source: "iana",
        extensions: ["rip"]
      },
      "audio/vnd.rn-realaudio": {
        compressible: false
      },
      "audio/vnd.sealedmedia.softseal.mpeg": {
        source: "iana"
      },
      "audio/vnd.vmx.cvsd": {
        source: "iana"
      },
      "audio/vnd.wave": {
        compressible: false
      },
      "audio/vorbis": {
        source: "iana",
        compressible: false
      },
      "audio/vorbis-config": {
        source: "iana"
      },
      "audio/wav": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/wave": {
        compressible: false,
        extensions: ["wav"]
      },
      "audio/webm": {
        source: "apache",
        compressible: false,
        extensions: ["weba"]
      },
      "audio/x-aac": {
        source: "apache",
        compressible: false,
        extensions: ["aac"]
      },
      "audio/x-aiff": {
        source: "apache",
        extensions: ["aif", "aiff", "aifc"]
      },
      "audio/x-caf": {
        source: "apache",
        compressible: false,
        extensions: ["caf"]
      },
      "audio/x-flac": {
        source: "apache",
        extensions: ["flac"]
      },
      "audio/x-m4a": {
        source: "nginx",
        extensions: ["m4a"]
      },
      "audio/x-matroska": {
        source: "apache",
        extensions: ["mka"]
      },
      "audio/x-mpegurl": {
        source: "apache",
        extensions: ["m3u"]
      },
      "audio/x-ms-wax": {
        source: "apache",
        extensions: ["wax"]
      },
      "audio/x-ms-wma": {
        source: "apache",
        extensions: ["wma"]
      },
      "audio/x-pn-realaudio": {
        source: "apache",
        extensions: ["ram", "ra"]
      },
      "audio/x-pn-realaudio-plugin": {
        source: "apache",
        extensions: ["rmp"]
      },
      "audio/x-realaudio": {
        source: "nginx",
        extensions: ["ra"]
      },
      "audio/x-tta": {
        source: "apache"
      },
      "audio/x-wav": {
        source: "apache",
        extensions: ["wav"]
      },
      "audio/xm": {
        source: "apache",
        extensions: ["xm"]
      },
      "chemical/x-cdx": {
        source: "apache",
        extensions: ["cdx"]
      },
      "chemical/x-cif": {
        source: "apache",
        extensions: ["cif"]
      },
      "chemical/x-cmdf": {
        source: "apache",
        extensions: ["cmdf"]
      },
      "chemical/x-cml": {
        source: "apache",
        extensions: ["cml"]
      },
      "chemical/x-csml": {
        source: "apache",
        extensions: ["csml"]
      },
      "chemical/x-pdb": {
        source: "apache"
      },
      "chemical/x-xyz": {
        source: "apache",
        extensions: ["xyz"]
      },
      "font/collection": {
        source: "iana",
        extensions: ["ttc"]
      },
      "font/otf": {
        source: "iana",
        compressible: true,
        extensions: ["otf"]
      },
      "font/sfnt": {
        source: "iana"
      },
      "font/ttf": {
        source: "iana",
        compressible: true,
        extensions: ["ttf"]
      },
      "font/woff": {
        source: "iana",
        extensions: ["woff"]
      },
      "font/woff2": {
        source: "iana",
        extensions: ["woff2"]
      },
      "image/aces": {
        source: "iana",
        extensions: ["exr"]
      },
      "image/apng": {
        compressible: false,
        extensions: ["apng"]
      },
      "image/avci": {
        source: "iana",
        extensions: ["avci"]
      },
      "image/avcs": {
        source: "iana",
        extensions: ["avcs"]
      },
      "image/avif": {
        source: "iana",
        compressible: false,
        extensions: ["avif"]
      },
      "image/bmp": {
        source: "iana",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/cgm": {
        source: "iana",
        extensions: ["cgm"]
      },
      "image/dicom-rle": {
        source: "iana",
        extensions: ["drle"]
      },
      "image/emf": {
        source: "iana",
        extensions: ["emf"]
      },
      "image/fits": {
        source: "iana",
        extensions: ["fits"]
      },
      "image/g3fax": {
        source: "iana",
        extensions: ["g3"]
      },
      "image/gif": {
        source: "iana",
        compressible: false,
        extensions: ["gif"]
      },
      "image/heic": {
        source: "iana",
        extensions: ["heic"]
      },
      "image/heic-sequence": {
        source: "iana",
        extensions: ["heics"]
      },
      "image/heif": {
        source: "iana",
        extensions: ["heif"]
      },
      "image/heif-sequence": {
        source: "iana",
        extensions: ["heifs"]
      },
      "image/hej2k": {
        source: "iana",
        extensions: ["hej2"]
      },
      "image/hsj2": {
        source: "iana",
        extensions: ["hsj2"]
      },
      "image/ief": {
        source: "iana",
        extensions: ["ief"]
      },
      "image/jls": {
        source: "iana",
        extensions: ["jls"]
      },
      "image/jp2": {
        source: "iana",
        compressible: false,
        extensions: ["jp2", "jpg2"]
      },
      "image/jpeg": {
        source: "iana",
        compressible: false,
        extensions: ["jpeg", "jpg", "jpe"]
      },
      "image/jph": {
        source: "iana",
        extensions: ["jph"]
      },
      "image/jphc": {
        source: "iana",
        extensions: ["jhc"]
      },
      "image/jpm": {
        source: "iana",
        compressible: false,
        extensions: ["jpm"]
      },
      "image/jpx": {
        source: "iana",
        compressible: false,
        extensions: ["jpx", "jpf"]
      },
      "image/jxr": {
        source: "iana",
        extensions: ["jxr"]
      },
      "image/jxra": {
        source: "iana",
        extensions: ["jxra"]
      },
      "image/jxrs": {
        source: "iana",
        extensions: ["jxrs"]
      },
      "image/jxs": {
        source: "iana",
        extensions: ["jxs"]
      },
      "image/jxsc": {
        source: "iana",
        extensions: ["jxsc"]
      },
      "image/jxsi": {
        source: "iana",
        extensions: ["jxsi"]
      },
      "image/jxss": {
        source: "iana",
        extensions: ["jxss"]
      },
      "image/ktx": {
        source: "iana",
        extensions: ["ktx"]
      },
      "image/ktx2": {
        source: "iana",
        extensions: ["ktx2"]
      },
      "image/naplps": {
        source: "iana"
      },
      "image/pjpeg": {
        compressible: false
      },
      "image/png": {
        source: "iana",
        compressible: false,
        extensions: ["png"]
      },
      "image/prs.btif": {
        source: "iana",
        extensions: ["btif"]
      },
      "image/prs.pti": {
        source: "iana",
        extensions: ["pti"]
      },
      "image/pwg-raster": {
        source: "iana"
      },
      "image/sgi": {
        source: "apache",
        extensions: ["sgi"]
      },
      "image/svg+xml": {
        source: "iana",
        compressible: true,
        extensions: ["svg", "svgz"]
      },
      "image/t38": {
        source: "iana",
        extensions: ["t38"]
      },
      "image/tiff": {
        source: "iana",
        compressible: false,
        extensions: ["tif", "tiff"]
      },
      "image/tiff-fx": {
        source: "iana",
        extensions: ["tfx"]
      },
      "image/vnd.adobe.photoshop": {
        source: "iana",
        compressible: true,
        extensions: ["psd"]
      },
      "image/vnd.airzip.accelerator.azv": {
        source: "iana",
        extensions: ["azv"]
      },
      "image/vnd.cns.inf2": {
        source: "iana"
      },
      "image/vnd.dece.graphic": {
        source: "iana",
        extensions: ["uvi", "uvvi", "uvg", "uvvg"]
      },
      "image/vnd.djvu": {
        source: "iana",
        extensions: ["djvu", "djv"]
      },
      "image/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "image/vnd.dwg": {
        source: "iana",
        extensions: ["dwg"]
      },
      "image/vnd.dxf": {
        source: "iana",
        extensions: ["dxf"]
      },
      "image/vnd.fastbidsheet": {
        source: "iana",
        extensions: ["fbs"]
      },
      "image/vnd.fpx": {
        source: "iana",
        extensions: ["fpx"]
      },
      "image/vnd.fst": {
        source: "iana",
        extensions: ["fst"]
      },
      "image/vnd.fujixerox.edmics-mmr": {
        source: "iana",
        extensions: ["mmr"]
      },
      "image/vnd.fujixerox.edmics-rlc": {
        source: "iana",
        extensions: ["rlc"]
      },
      "image/vnd.globalgraphics.pgb": {
        source: "iana"
      },
      "image/vnd.microsoft.icon": {
        source: "iana",
        compressible: true,
        extensions: ["ico"]
      },
      "image/vnd.mix": {
        source: "iana"
      },
      "image/vnd.mozilla.apng": {
        source: "iana"
      },
      "image/vnd.ms-dds": {
        compressible: true,
        extensions: ["dds"]
      },
      "image/vnd.ms-modi": {
        source: "iana",
        extensions: ["mdi"]
      },
      "image/vnd.ms-photo": {
        source: "apache",
        extensions: ["wdp"]
      },
      "image/vnd.net-fpx": {
        source: "iana",
        extensions: ["npx"]
      },
      "image/vnd.pco.b16": {
        source: "iana",
        extensions: ["b16"]
      },
      "image/vnd.radiance": {
        source: "iana"
      },
      "image/vnd.sealed.png": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.gif": {
        source: "iana"
      },
      "image/vnd.sealedmedia.softseal.jpg": {
        source: "iana"
      },
      "image/vnd.svf": {
        source: "iana"
      },
      "image/vnd.tencent.tap": {
        source: "iana",
        extensions: ["tap"]
      },
      "image/vnd.valve.source.texture": {
        source: "iana",
        extensions: ["vtf"]
      },
      "image/vnd.wap.wbmp": {
        source: "iana",
        extensions: ["wbmp"]
      },
      "image/vnd.xiff": {
        source: "iana",
        extensions: ["xif"]
      },
      "image/vnd.zbrush.pcx": {
        source: "iana",
        extensions: ["pcx"]
      },
      "image/webp": {
        source: "apache",
        extensions: ["webp"]
      },
      "image/wmf": {
        source: "iana",
        extensions: ["wmf"]
      },
      "image/x-3ds": {
        source: "apache",
        extensions: ["3ds"]
      },
      "image/x-cmu-raster": {
        source: "apache",
        extensions: ["ras"]
      },
      "image/x-cmx": {
        source: "apache",
        extensions: ["cmx"]
      },
      "image/x-freehand": {
        source: "apache",
        extensions: ["fh", "fhc", "fh4", "fh5", "fh7"]
      },
      "image/x-icon": {
        source: "apache",
        compressible: true,
        extensions: ["ico"]
      },
      "image/x-jng": {
        source: "nginx",
        extensions: ["jng"]
      },
      "image/x-mrsid-image": {
        source: "apache",
        extensions: ["sid"]
      },
      "image/x-ms-bmp": {
        source: "nginx",
        compressible: true,
        extensions: ["bmp"]
      },
      "image/x-pcx": {
        source: "apache",
        extensions: ["pcx"]
      },
      "image/x-pict": {
        source: "apache",
        extensions: ["pic", "pct"]
      },
      "image/x-portable-anymap": {
        source: "apache",
        extensions: ["pnm"]
      },
      "image/x-portable-bitmap": {
        source: "apache",
        extensions: ["pbm"]
      },
      "image/x-portable-graymap": {
        source: "apache",
        extensions: ["pgm"]
      },
      "image/x-portable-pixmap": {
        source: "apache",
        extensions: ["ppm"]
      },
      "image/x-rgb": {
        source: "apache",
        extensions: ["rgb"]
      },
      "image/x-tga": {
        source: "apache",
        extensions: ["tga"]
      },
      "image/x-xbitmap": {
        source: "apache",
        extensions: ["xbm"]
      },
      "image/x-xcf": {
        compressible: false
      },
      "image/x-xpixmap": {
        source: "apache",
        extensions: ["xpm"]
      },
      "image/x-xwindowdump": {
        source: "apache",
        extensions: ["xwd"]
      },
      "message/cpim": {
        source: "iana"
      },
      "message/delivery-status": {
        source: "iana"
      },
      "message/disposition-notification": {
        source: "iana",
        extensions: [
          "disposition-notification"
        ]
      },
      "message/external-body": {
        source: "iana"
      },
      "message/feedback-report": {
        source: "iana"
      },
      "message/global": {
        source: "iana",
        extensions: ["u8msg"]
      },
      "message/global-delivery-status": {
        source: "iana",
        extensions: ["u8dsn"]
      },
      "message/global-disposition-notification": {
        source: "iana",
        extensions: ["u8mdn"]
      },
      "message/global-headers": {
        source: "iana",
        extensions: ["u8hdr"]
      },
      "message/http": {
        source: "iana",
        compressible: false
      },
      "message/imdn+xml": {
        source: "iana",
        compressible: true
      },
      "message/news": {
        source: "iana"
      },
      "message/partial": {
        source: "iana",
        compressible: false
      },
      "message/rfc822": {
        source: "iana",
        compressible: true,
        extensions: ["eml", "mime"]
      },
      "message/s-http": {
        source: "iana"
      },
      "message/sip": {
        source: "iana"
      },
      "message/sipfrag": {
        source: "iana"
      },
      "message/tracking-status": {
        source: "iana"
      },
      "message/vnd.si.simp": {
        source: "iana"
      },
      "message/vnd.wfa.wsc": {
        source: "iana",
        extensions: ["wsc"]
      },
      "model/3mf": {
        source: "iana",
        extensions: ["3mf"]
      },
      "model/e57": {
        source: "iana"
      },
      "model/gltf+json": {
        source: "iana",
        compressible: true,
        extensions: ["gltf"]
      },
      "model/gltf-binary": {
        source: "iana",
        compressible: true,
        extensions: ["glb"]
      },
      "model/iges": {
        source: "iana",
        compressible: false,
        extensions: ["igs", "iges"]
      },
      "model/mesh": {
        source: "iana",
        compressible: false,
        extensions: ["msh", "mesh", "silo"]
      },
      "model/mtl": {
        source: "iana",
        extensions: ["mtl"]
      },
      "model/obj": {
        source: "iana",
        extensions: ["obj"]
      },
      "model/step": {
        source: "iana"
      },
      "model/step+xml": {
        source: "iana",
        compressible: true,
        extensions: ["stpx"]
      },
      "model/step+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpz"]
      },
      "model/step-xml+zip": {
        source: "iana",
        compressible: false,
        extensions: ["stpxz"]
      },
      "model/stl": {
        source: "iana",
        extensions: ["stl"]
      },
      "model/vnd.collada+xml": {
        source: "iana",
        compressible: true,
        extensions: ["dae"]
      },
      "model/vnd.dwf": {
        source: "iana",
        extensions: ["dwf"]
      },
      "model/vnd.flatland.3dml": {
        source: "iana"
      },
      "model/vnd.gdl": {
        source: "iana",
        extensions: ["gdl"]
      },
      "model/vnd.gs-gdl": {
        source: "apache"
      },
      "model/vnd.gs.gdl": {
        source: "iana"
      },
      "model/vnd.gtw": {
        source: "iana",
        extensions: ["gtw"]
      },
      "model/vnd.moml+xml": {
        source: "iana",
        compressible: true
      },
      "model/vnd.mts": {
        source: "iana",
        extensions: ["mts"]
      },
      "model/vnd.opengex": {
        source: "iana",
        extensions: ["ogex"]
      },
      "model/vnd.parasolid.transmit.binary": {
        source: "iana",
        extensions: ["x_b"]
      },
      "model/vnd.parasolid.transmit.text": {
        source: "iana",
        extensions: ["x_t"]
      },
      "model/vnd.pytha.pyox": {
        source: "iana"
      },
      "model/vnd.rosette.annotated-data-model": {
        source: "iana"
      },
      "model/vnd.sap.vds": {
        source: "iana",
        extensions: ["vds"]
      },
      "model/vnd.usdz+zip": {
        source: "iana",
        compressible: false,
        extensions: ["usdz"]
      },
      "model/vnd.valve.source.compiled-map": {
        source: "iana",
        extensions: ["bsp"]
      },
      "model/vnd.vtu": {
        source: "iana",
        extensions: ["vtu"]
      },
      "model/vrml": {
        source: "iana",
        compressible: false,
        extensions: ["wrl", "vrml"]
      },
      "model/x3d+binary": {
        source: "apache",
        compressible: false,
        extensions: ["x3db", "x3dbz"]
      },
      "model/x3d+fastinfoset": {
        source: "iana",
        extensions: ["x3db"]
      },
      "model/x3d+vrml": {
        source: "apache",
        compressible: false,
        extensions: ["x3dv", "x3dvz"]
      },
      "model/x3d+xml": {
        source: "iana",
        compressible: true,
        extensions: ["x3d", "x3dz"]
      },
      "model/x3d-vrml": {
        source: "iana",
        extensions: ["x3dv"]
      },
      "multipart/alternative": {
        source: "iana",
        compressible: false
      },
      "multipart/appledouble": {
        source: "iana"
      },
      "multipart/byteranges": {
        source: "iana"
      },
      "multipart/digest": {
        source: "iana"
      },
      "multipart/encrypted": {
        source: "iana",
        compressible: false
      },
      "multipart/form-data": {
        source: "iana",
        compressible: false
      },
      "multipart/header-set": {
        source: "iana"
      },
      "multipart/mixed": {
        source: "iana"
      },
      "multipart/multilingual": {
        source: "iana"
      },
      "multipart/parallel": {
        source: "iana"
      },
      "multipart/related": {
        source: "iana",
        compressible: false
      },
      "multipart/report": {
        source: "iana"
      },
      "multipart/signed": {
        source: "iana",
        compressible: false
      },
      "multipart/vnd.bint.med-plus": {
        source: "iana"
      },
      "multipart/voice-message": {
        source: "iana"
      },
      "multipart/x-mixed-replace": {
        source: "iana"
      },
      "text/1d-interleaved-parityfec": {
        source: "iana"
      },
      "text/cache-manifest": {
        source: "iana",
        compressible: true,
        extensions: ["appcache", "manifest"]
      },
      "text/calendar": {
        source: "iana",
        extensions: ["ics", "ifb"]
      },
      "text/calender": {
        compressible: true
      },
      "text/cmd": {
        compressible: true
      },
      "text/coffeescript": {
        extensions: ["coffee", "litcoffee"]
      },
      "text/cql": {
        source: "iana"
      },
      "text/cql-expression": {
        source: "iana"
      },
      "text/cql-identifier": {
        source: "iana"
      },
      "text/css": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["css"]
      },
      "text/csv": {
        source: "iana",
        compressible: true,
        extensions: ["csv"]
      },
      "text/csv-schema": {
        source: "iana"
      },
      "text/directory": {
        source: "iana"
      },
      "text/dns": {
        source: "iana"
      },
      "text/ecmascript": {
        source: "iana"
      },
      "text/encaprtp": {
        source: "iana"
      },
      "text/enriched": {
        source: "iana"
      },
      "text/fhirpath": {
        source: "iana"
      },
      "text/flexfec": {
        source: "iana"
      },
      "text/fwdred": {
        source: "iana"
      },
      "text/gff3": {
        source: "iana"
      },
      "text/grammar-ref-list": {
        source: "iana"
      },
      "text/html": {
        source: "iana",
        compressible: true,
        extensions: ["html", "htm", "shtml"]
      },
      "text/jade": {
        extensions: ["jade"]
      },
      "text/javascript": {
        source: "iana",
        compressible: true
      },
      "text/jcr-cnd": {
        source: "iana"
      },
      "text/jsx": {
        compressible: true,
        extensions: ["jsx"]
      },
      "text/less": {
        compressible: true,
        extensions: ["less"]
      },
      "text/markdown": {
        source: "iana",
        compressible: true,
        extensions: ["markdown", "md"]
      },
      "text/mathml": {
        source: "nginx",
        extensions: ["mml"]
      },
      "text/mdx": {
        compressible: true,
        extensions: ["mdx"]
      },
      "text/mizar": {
        source: "iana"
      },
      "text/n3": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["n3"]
      },
      "text/parameters": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/parityfec": {
        source: "iana"
      },
      "text/plain": {
        source: "iana",
        compressible: true,
        extensions: ["txt", "text", "conf", "def", "list", "log", "in", "ini"]
      },
      "text/provenance-notation": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/prs.fallenstein.rst": {
        source: "iana"
      },
      "text/prs.lines.tag": {
        source: "iana",
        extensions: ["dsc"]
      },
      "text/prs.prop.logic": {
        source: "iana"
      },
      "text/raptorfec": {
        source: "iana"
      },
      "text/red": {
        source: "iana"
      },
      "text/rfc822-headers": {
        source: "iana"
      },
      "text/richtext": {
        source: "iana",
        compressible: true,
        extensions: ["rtx"]
      },
      "text/rtf": {
        source: "iana",
        compressible: true,
        extensions: ["rtf"]
      },
      "text/rtp-enc-aescm128": {
        source: "iana"
      },
      "text/rtploopback": {
        source: "iana"
      },
      "text/rtx": {
        source: "iana"
      },
      "text/sgml": {
        source: "iana",
        extensions: ["sgml", "sgm"]
      },
      "text/shaclc": {
        source: "iana"
      },
      "text/shex": {
        source: "iana",
        extensions: ["shex"]
      },
      "text/slim": {
        extensions: ["slim", "slm"]
      },
      "text/spdx": {
        source: "iana",
        extensions: ["spdx"]
      },
      "text/strings": {
        source: "iana"
      },
      "text/stylus": {
        extensions: ["stylus", "styl"]
      },
      "text/t140": {
        source: "iana"
      },
      "text/tab-separated-values": {
        source: "iana",
        compressible: true,
        extensions: ["tsv"]
      },
      "text/troff": {
        source: "iana",
        extensions: ["t", "tr", "roff", "man", "me", "ms"]
      },
      "text/turtle": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["ttl"]
      },
      "text/ulpfec": {
        source: "iana"
      },
      "text/uri-list": {
        source: "iana",
        compressible: true,
        extensions: ["uri", "uris", "urls"]
      },
      "text/vcard": {
        source: "iana",
        compressible: true,
        extensions: ["vcard"]
      },
      "text/vnd.a": {
        source: "iana"
      },
      "text/vnd.abc": {
        source: "iana"
      },
      "text/vnd.ascii-art": {
        source: "iana"
      },
      "text/vnd.curl": {
        source: "iana",
        extensions: ["curl"]
      },
      "text/vnd.curl.dcurl": {
        source: "apache",
        extensions: ["dcurl"]
      },
      "text/vnd.curl.mcurl": {
        source: "apache",
        extensions: ["mcurl"]
      },
      "text/vnd.curl.scurl": {
        source: "apache",
        extensions: ["scurl"]
      },
      "text/vnd.debian.copyright": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.dmclientscript": {
        source: "iana"
      },
      "text/vnd.dvb.subtitle": {
        source: "iana",
        extensions: ["sub"]
      },
      "text/vnd.esmertec.theme-descriptor": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.familysearch.gedcom": {
        source: "iana",
        extensions: ["ged"]
      },
      "text/vnd.ficlab.flt": {
        source: "iana"
      },
      "text/vnd.fly": {
        source: "iana",
        extensions: ["fly"]
      },
      "text/vnd.fmi.flexstor": {
        source: "iana",
        extensions: ["flx"]
      },
      "text/vnd.gml": {
        source: "iana"
      },
      "text/vnd.graphviz": {
        source: "iana",
        extensions: ["gv"]
      },
      "text/vnd.hans": {
        source: "iana"
      },
      "text/vnd.hgl": {
        source: "iana"
      },
      "text/vnd.in3d.3dml": {
        source: "iana",
        extensions: ["3dml"]
      },
      "text/vnd.in3d.spot": {
        source: "iana",
        extensions: ["spot"]
      },
      "text/vnd.iptc.newsml": {
        source: "iana"
      },
      "text/vnd.iptc.nitf": {
        source: "iana"
      },
      "text/vnd.latex-z": {
        source: "iana"
      },
      "text/vnd.motorola.reflex": {
        source: "iana"
      },
      "text/vnd.ms-mediapackage": {
        source: "iana"
      },
      "text/vnd.net2phone.commcenter.command": {
        source: "iana"
      },
      "text/vnd.radisys.msml-basic-layout": {
        source: "iana"
      },
      "text/vnd.senx.warpscript": {
        source: "iana"
      },
      "text/vnd.si.uricatalogue": {
        source: "iana"
      },
      "text/vnd.sosi": {
        source: "iana"
      },
      "text/vnd.sun.j2me.app-descriptor": {
        source: "iana",
        charset: "UTF-8",
        extensions: ["jad"]
      },
      "text/vnd.trolltech.linguist": {
        source: "iana",
        charset: "UTF-8"
      },
      "text/vnd.wap.si": {
        source: "iana"
      },
      "text/vnd.wap.sl": {
        source: "iana"
      },
      "text/vnd.wap.wml": {
        source: "iana",
        extensions: ["wml"]
      },
      "text/vnd.wap.wmlscript": {
        source: "iana",
        extensions: ["wmls"]
      },
      "text/vtt": {
        source: "iana",
        charset: "UTF-8",
        compressible: true,
        extensions: ["vtt"]
      },
      "text/x-asm": {
        source: "apache",
        extensions: ["s", "asm"]
      },
      "text/x-c": {
        source: "apache",
        extensions: ["c", "cc", "cxx", "cpp", "h", "hh", "dic"]
      },
      "text/x-component": {
        source: "nginx",
        extensions: ["htc"]
      },
      "text/x-fortran": {
        source: "apache",
        extensions: ["f", "for", "f77", "f90"]
      },
      "text/x-gwt-rpc": {
        compressible: true
      },
      "text/x-handlebars-template": {
        extensions: ["hbs"]
      },
      "text/x-java-source": {
        source: "apache",
        extensions: ["java"]
      },
      "text/x-jquery-tmpl": {
        compressible: true
      },
      "text/x-lua": {
        extensions: ["lua"]
      },
      "text/x-markdown": {
        compressible: true,
        extensions: ["mkd"]
      },
      "text/x-nfo": {
        source: "apache",
        extensions: ["nfo"]
      },
      "text/x-opml": {
        source: "apache",
        extensions: ["opml"]
      },
      "text/x-org": {
        compressible: true,
        extensions: ["org"]
      },
      "text/x-pascal": {
        source: "apache",
        extensions: ["p", "pas"]
      },
      "text/x-processing": {
        compressible: true,
        extensions: ["pde"]
      },
      "text/x-sass": {
        extensions: ["sass"]
      },
      "text/x-scss": {
        extensions: ["scss"]
      },
      "text/x-setext": {
        source: "apache",
        extensions: ["etx"]
      },
      "text/x-sfv": {
        source: "apache",
        extensions: ["sfv"]
      },
      "text/x-suse-ymp": {
        compressible: true,
        extensions: ["ymp"]
      },
      "text/x-uuencode": {
        source: "apache",
        extensions: ["uu"]
      },
      "text/x-vcalendar": {
        source: "apache",
        extensions: ["vcs"]
      },
      "text/x-vcard": {
        source: "apache",
        extensions: ["vcf"]
      },
      "text/xml": {
        source: "iana",
        compressible: true,
        extensions: ["xml"]
      },
      "text/xml-external-parsed-entity": {
        source: "iana"
      },
      "text/yaml": {
        compressible: true,
        extensions: ["yaml", "yml"]
      },
      "video/1d-interleaved-parityfec": {
        source: "iana"
      },
      "video/3gpp": {
        source: "iana",
        extensions: ["3gp", "3gpp"]
      },
      "video/3gpp-tt": {
        source: "iana"
      },
      "video/3gpp2": {
        source: "iana",
        extensions: ["3g2"]
      },
      "video/av1": {
        source: "iana"
      },
      "video/bmpeg": {
        source: "iana"
      },
      "video/bt656": {
        source: "iana"
      },
      "video/celb": {
        source: "iana"
      },
      "video/dv": {
        source: "iana"
      },
      "video/encaprtp": {
        source: "iana"
      },
      "video/ffv1": {
        source: "iana"
      },
      "video/flexfec": {
        source: "iana"
      },
      "video/h261": {
        source: "iana",
        extensions: ["h261"]
      },
      "video/h263": {
        source: "iana",
        extensions: ["h263"]
      },
      "video/h263-1998": {
        source: "iana"
      },
      "video/h263-2000": {
        source: "iana"
      },
      "video/h264": {
        source: "iana",
        extensions: ["h264"]
      },
      "video/h264-rcdo": {
        source: "iana"
      },
      "video/h264-svc": {
        source: "iana"
      },
      "video/h265": {
        source: "iana"
      },
      "video/iso.segment": {
        source: "iana",
        extensions: ["m4s"]
      },
      "video/jpeg": {
        source: "iana",
        extensions: ["jpgv"]
      },
      "video/jpeg2000": {
        source: "iana"
      },
      "video/jpm": {
        source: "apache",
        extensions: ["jpm", "jpgm"]
      },
      "video/jxsv": {
        source: "iana"
      },
      "video/mj2": {
        source: "iana",
        extensions: ["mj2", "mjp2"]
      },
      "video/mp1s": {
        source: "iana"
      },
      "video/mp2p": {
        source: "iana"
      },
      "video/mp2t": {
        source: "iana",
        extensions: ["ts"]
      },
      "video/mp4": {
        source: "iana",
        compressible: false,
        extensions: ["mp4", "mp4v", "mpg4"]
      },
      "video/mp4v-es": {
        source: "iana"
      },
      "video/mpeg": {
        source: "iana",
        compressible: false,
        extensions: ["mpeg", "mpg", "mpe", "m1v", "m2v"]
      },
      "video/mpeg4-generic": {
        source: "iana"
      },
      "video/mpv": {
        source: "iana"
      },
      "video/nv": {
        source: "iana"
      },
      "video/ogg": {
        source: "iana",
        compressible: false,
        extensions: ["ogv"]
      },
      "video/parityfec": {
        source: "iana"
      },
      "video/pointer": {
        source: "iana"
      },
      "video/quicktime": {
        source: "iana",
        compressible: false,
        extensions: ["qt", "mov"]
      },
      "video/raptorfec": {
        source: "iana"
      },
      "video/raw": {
        source: "iana"
      },
      "video/rtp-enc-aescm128": {
        source: "iana"
      },
      "video/rtploopback": {
        source: "iana"
      },
      "video/rtx": {
        source: "iana"
      },
      "video/scip": {
        source: "iana"
      },
      "video/smpte291": {
        source: "iana"
      },
      "video/smpte292m": {
        source: "iana"
      },
      "video/ulpfec": {
        source: "iana"
      },
      "video/vc1": {
        source: "iana"
      },
      "video/vc2": {
        source: "iana"
      },
      "video/vnd.cctv": {
        source: "iana"
      },
      "video/vnd.dece.hd": {
        source: "iana",
        extensions: ["uvh", "uvvh"]
      },
      "video/vnd.dece.mobile": {
        source: "iana",
        extensions: ["uvm", "uvvm"]
      },
      "video/vnd.dece.mp4": {
        source: "iana"
      },
      "video/vnd.dece.pd": {
        source: "iana",
        extensions: ["uvp", "uvvp"]
      },
      "video/vnd.dece.sd": {
        source: "iana",
        extensions: ["uvs", "uvvs"]
      },
      "video/vnd.dece.video": {
        source: "iana",
        extensions: ["uvv", "uvvv"]
      },
      "video/vnd.directv.mpeg": {
        source: "iana"
      },
      "video/vnd.directv.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dlna.mpeg-tts": {
        source: "iana"
      },
      "video/vnd.dvb.file": {
        source: "iana",
        extensions: ["dvb"]
      },
      "video/vnd.fvt": {
        source: "iana",
        extensions: ["fvt"]
      },
      "video/vnd.hns.video": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.1dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-1010": {
        source: "iana"
      },
      "video/vnd.iptvforum.2dparityfec-2005": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsavc": {
        source: "iana"
      },
      "video/vnd.iptvforum.ttsmpeg2": {
        source: "iana"
      },
      "video/vnd.motorola.video": {
        source: "iana"
      },
      "video/vnd.motorola.videop": {
        source: "iana"
      },
      "video/vnd.mpegurl": {
        source: "iana",
        extensions: ["mxu", "m4u"]
      },
      "video/vnd.ms-playready.media.pyv": {
        source: "iana",
        extensions: ["pyv"]
      },
      "video/vnd.nokia.interleaved-multimedia": {
        source: "iana"
      },
      "video/vnd.nokia.mp4vr": {
        source: "iana"
      },
      "video/vnd.nokia.videovoip": {
        source: "iana"
      },
      "video/vnd.objectvideo": {
        source: "iana"
      },
      "video/vnd.radgamettools.bink": {
        source: "iana"
      },
      "video/vnd.radgamettools.smacker": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg1": {
        source: "iana"
      },
      "video/vnd.sealed.mpeg4": {
        source: "iana"
      },
      "video/vnd.sealed.swf": {
        source: "iana"
      },
      "video/vnd.sealedmedia.softseal.mov": {
        source: "iana"
      },
      "video/vnd.uvvu.mp4": {
        source: "iana",
        extensions: ["uvu", "uvvu"]
      },
      "video/vnd.vivo": {
        source: "iana",
        extensions: ["viv"]
      },
      "video/vnd.youtube.yt": {
        source: "iana"
      },
      "video/vp8": {
        source: "iana"
      },
      "video/vp9": {
        source: "iana"
      },
      "video/webm": {
        source: "apache",
        compressible: false,
        extensions: ["webm"]
      },
      "video/x-f4v": {
        source: "apache",
        extensions: ["f4v"]
      },
      "video/x-fli": {
        source: "apache",
        extensions: ["fli"]
      },
      "video/x-flv": {
        source: "apache",
        compressible: false,
        extensions: ["flv"]
      },
      "video/x-m4v": {
        source: "apache",
        extensions: ["m4v"]
      },
      "video/x-matroska": {
        source: "apache",
        compressible: false,
        extensions: ["mkv", "mk3d", "mks"]
      },
      "video/x-mng": {
        source: "apache",
        extensions: ["mng"]
      },
      "video/x-ms-asf": {
        source: "apache",
        extensions: ["asf", "asx"]
      },
      "video/x-ms-vob": {
        source: "apache",
        extensions: ["vob"]
      },
      "video/x-ms-wm": {
        source: "apache",
        extensions: ["wm"]
      },
      "video/x-ms-wmv": {
        source: "apache",
        compressible: false,
        extensions: ["wmv"]
      },
      "video/x-ms-wmx": {
        source: "apache",
        extensions: ["wmx"]
      },
      "video/x-ms-wvx": {
        source: "apache",
        extensions: ["wvx"]
      },
      "video/x-msvideo": {
        source: "apache",
        extensions: ["avi"]
      },
      "video/x-sgi-movie": {
        source: "apache",
        extensions: ["movie"]
      },
      "video/x-smv": {
        source: "apache",
        extensions: ["smv"]
      },
      "x-conference/x-cooltalk": {
        source: "apache",
        extensions: ["ice"]
      },
      "x-shader/x-fragment": {
        compressible: true
      },
      "x-shader/x-vertex": {
        compressible: true
      }
    };
  }
});

// node_modules/mime-db/index.js
var require_mime_db = __commonJS({
  "node_modules/mime-db/index.js"(exports, module) {
    module.exports = require_db();
  }
});

// node_modules/mime-types/index.js
var require_mime_types = __commonJS({
  "node_modules/mime-types/index.js"(exports) {
    "use strict";
    var db = require_mime_db();
    var extname = require_path().extname;
    var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
    var TEXT_TYPE_REGEXP = /^text\//i;
    exports.charset = charset;
    exports.charsets = { lookup: charset };
    exports.contentType = contentType;
    exports.extension = extension;
    exports.extensions = /* @__PURE__ */ Object.create(null);
    exports.lookup = lookup;
    exports.types = /* @__PURE__ */ Object.create(null);
    populateMaps(exports.extensions, exports.types);
    function charset(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var mime = match && db[match[1].toLowerCase()];
      if (mime && mime.charset) {
        return mime.charset;
      }
      if (match && TEXT_TYPE_REGEXP.test(match[1])) {
        return "UTF-8";
      }
      return false;
    }
    function contentType(str) {
      if (!str || typeof str !== "string") {
        return false;
      }
      var mime = str.indexOf("/") === -1 ? exports.lookup(str) : str;
      if (!mime) {
        return false;
      }
      if (mime.indexOf("charset") === -1) {
        var charset2 = exports.charset(mime);
        if (charset2)
          mime += "; charset=" + charset2.toLowerCase();
      }
      return mime;
    }
    function extension(type) {
      if (!type || typeof type !== "string") {
        return false;
      }
      var match = EXTRACT_TYPE_REGEXP.exec(type);
      var exts = match && exports.extensions[match[1].toLowerCase()];
      if (!exts || !exts.length) {
        return false;
      }
      return exts[0];
    }
    function lookup(path) {
      if (!path || typeof path !== "string") {
        return false;
      }
      var extension2 = extname("x." + path).toLowerCase().substr(1);
      if (!extension2) {
        return false;
      }
      return exports.types[extension2] || false;
    }
    function populateMaps(extensions, types) {
      var preference = ["nginx", "apache", void 0, "iana"];
      Object.keys(db).forEach(function forEachMimeType(type) {
        var mime = db[type];
        var exts = mime.extensions;
        if (!exts || !exts.length) {
          return;
        }
        extensions[type] = exts;
        for (var i = 0; i < exts.length; i++) {
          var extension2 = exts[i];
          if (types[extension2]) {
            var from = preference.indexOf(db[types[extension2]].source);
            var to = preference.indexOf(mime.source);
            if (types[extension2] !== "application/octet-stream" && (from > to || from === to && types[extension2].substr(0, 12) === "application/")) {
              continue;
            }
          }
          types[extension2] = type;
        }
      });
    }
  }
});

// node_modules/striptags/src/striptags.js
var require_striptags = __commonJS({
  "node_modules/striptags/src/striptags.js"(exports, module) {
    "use strict";
    (function(global2) {
      if (typeof Symbol2 !== "function") {
        var Symbol2 = function(name) {
          return name;
        };
        Symbol2.nonNative = true;
      }
      const STATE_PLAINTEXT = Symbol2("plaintext");
      const STATE_HTML = Symbol2("html");
      const STATE_COMMENT = Symbol2("comment");
      const ALLOWED_TAGS_REGEX = /<(\w*)>/g;
      const NORMALIZE_TAG_REGEX = /<\/?([^\s\/>]+)/;
      function striptags3(html, allowable_tags, tag_replacement) {
        html = html || "";
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return striptags_internal(html, context);
      }
      function init_striptags_stream(allowable_tags, tag_replacement) {
        allowable_tags = allowable_tags || [];
        tag_replacement = tag_replacement || "";
        let context = init_context(allowable_tags, tag_replacement);
        return function striptags_stream(html) {
          return striptags_internal(html || "", context);
        };
      }
      striptags3.init_streaming_mode = init_striptags_stream;
      function init_context(allowable_tags, tag_replacement) {
        allowable_tags = parse_allowable_tags(allowable_tags);
        return {
          allowable_tags,
          tag_replacement,
          state: STATE_PLAINTEXT,
          tag_buffer: "",
          depth: 0,
          in_quote_char: ""
        };
      }
      function striptags_internal(html, context) {
        if (typeof html != "string") {
          throw new TypeError("'html' parameter must be a string");
        }
        let allowable_tags = context.allowable_tags;
        let tag_replacement = context.tag_replacement;
        let state = context.state;
        let tag_buffer = context.tag_buffer;
        let depth = context.depth;
        let in_quote_char = context.in_quote_char;
        let output = "";
        for (let idx = 0, length = html.length; idx < length; idx++) {
          let char = html[idx];
          if (state === STATE_PLAINTEXT) {
            switch (char) {
              case "<":
                state = STATE_HTML;
                tag_buffer += char;
                break;
              default:
                output += char;
                break;
            }
          } else if (state === STATE_HTML) {
            switch (char) {
              case "<":
                if (in_quote_char) {
                  break;
                }
                depth++;
                break;
              case ">":
                if (in_quote_char) {
                  break;
                }
                if (depth) {
                  depth--;
                  break;
                }
                in_quote_char = "";
                state = STATE_PLAINTEXT;
                tag_buffer += ">";
                if (allowable_tags.has(normalize_tag(tag_buffer))) {
                  output += tag_buffer;
                } else {
                  output += tag_replacement;
                }
                tag_buffer = "";
                break;
              case '"':
              case "'":
                if (char === in_quote_char) {
                  in_quote_char = "";
                } else {
                  in_quote_char = in_quote_char || char;
                }
                tag_buffer += char;
                break;
              case "-":
                if (tag_buffer === "<!-") {
                  state = STATE_COMMENT;
                }
                tag_buffer += char;
                break;
              case " ":
              case "\n":
                if (tag_buffer === "<") {
                  state = STATE_PLAINTEXT;
                  output += "< ";
                  tag_buffer = "";
                  break;
                }
                tag_buffer += char;
                break;
              default:
                tag_buffer += char;
                break;
            }
          } else if (state === STATE_COMMENT) {
            switch (char) {
              case ">":
                if (tag_buffer.slice(-2) == "--") {
                  state = STATE_PLAINTEXT;
                }
                tag_buffer = "";
                break;
              default:
                tag_buffer += char;
                break;
            }
          }
        }
        context.state = state;
        context.tag_buffer = tag_buffer;
        context.depth = depth;
        context.in_quote_char = in_quote_char;
        return output;
      }
      function parse_allowable_tags(allowable_tags) {
        let tag_set = /* @__PURE__ */ new Set();
        if (typeof allowable_tags === "string") {
          let match;
          while (match = ALLOWED_TAGS_REGEX.exec(allowable_tags)) {
            tag_set.add(match[1]);
          }
        } else if (!Symbol2.nonNative && typeof allowable_tags[Symbol2.iterator] === "function") {
          tag_set = new Set(allowable_tags);
        } else if (typeof allowable_tags.forEach === "function") {
          allowable_tags.forEach(tag_set.add, tag_set);
        }
        return tag_set;
      }
      function normalize_tag(tag_buffer) {
        let match = NORMALIZE_TAG_REGEX.exec(tag_buffer);
        return match ? match[1].toLowerCase() : null;
      }
      if (typeof define === "function" && define.amd) {
        define(function module_factory() {
          return striptags3;
        });
      } else if (typeof module === "object" && module.exports) {
        module.exports = striptags3;
      } else {
        global2.striptags = striptags3;
      }
    })(exports);
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0)
        return names;
      for (name in events = this._events) {
        if (has.call(events, name))
          names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length = listeners.length, j;
        for (i = 0; i < length; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length = listeners.length; i < length; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/axios/lib/helpers/bind.js
var require_bind = __commonJS({
  "node_modules/axios/lib/helpers/bind.js"(exports, module) {
    "use strict";
    module.exports = function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    };
  }
});

// node_modules/axios/lib/utils.js
var require_utils7 = __commonJS({
  "node_modules/axios/lib/utils.js"(exports, module) {
    "use strict";
    var bind = require_bind();
    var toString = Object.prototype.toString;
    var kindOf = /* @__PURE__ */ function(cache2) {
      return function(thing) {
        var str = toString.call(thing);
        return cache2[str] || (cache2[str] = str.slice(8, -1).toLowerCase());
      };
    }(/* @__PURE__ */ Object.create(null));
    function kindOfTest(type) {
      type = type.toLowerCase();
      return function isKindOf(thing) {
        return kindOf(thing) === type;
      };
    }
    function isArray(val) {
      return Array.isArray(val);
    }
    function isUndefined(val) {
      return typeof val === "undefined";
    }
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
    }
    var isArrayBuffer = kindOfTest("ArrayBuffer");
    function isArrayBufferView(val) {
      var result;
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && isArrayBuffer(val.buffer);
      }
      return result;
    }
    function isString(val) {
      return typeof val === "string";
    }
    function isNumber(val) {
      return typeof val === "number";
    }
    function isObject(val) {
      return val !== null && typeof val === "object";
    }
    function isPlainObject(val) {
      if (kindOf(val) !== "object") {
        return false;
      }
      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    function isEmptyObject(val) {
      return val && Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
    }
    var isDate = kindOfTest("Date");
    var isFile = kindOfTest("File");
    var isBlob = kindOfTest("Blob");
    var isFileList = kindOfTest("FileList");
    function isFunction(val) {
      return toString.call(val) === "[object Function]";
    }
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    function isFormData(thing) {
      var pattern = "[object FormData]";
      return thing && (typeof FormData === "function" && thing instanceof FormData || toString.call(thing) === pattern || isFunction(thing.toString) && thing.toString() === pattern);
    }
    var isURLSearchParams = kindOfTest("URLSearchParams");
    function trim(str) {
      return str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
    }
    function isStandardBrowserEnv() {
      var product;
      if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
        return false;
      }
      return typeof window !== "undefined" && typeof document !== "undefined";
    }
    function forEach(obj, fn) {
      if (obj === null || typeof obj === "undefined") {
        return;
      }
      if (typeof obj !== "object") {
        obj = [obj];
      }
      if (isArray(obj)) {
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    function merge() {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }
      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === "function") {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    function stripBOM(content) {
      if (content.charCodeAt(0) === 65279) {
        content = content.slice(1);
      }
      return content;
    }
    function inherits(constructor, superConstructor, props, descriptors) {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      props && Object.assign(constructor.prototype, props);
    }
    function toFlatObject(sourceObj, destObj, filter, propFilter) {
      var props;
      var i;
      var prop;
      var merged = {};
      destObj = destObj || {};
      if (sourceObj == null)
        return destObj;
      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && Object.getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);
      return destObj;
    }
    function endsWith(str, searchString, position) {
      str = String(str);
      if (position === void 0 || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      var lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    }
    function toArray(thing) {
      if (!thing)
        return null;
      if (isArray(thing))
        return thing;
      var i = thing.length;
      if (!isNumber(i))
        return null;
      var arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    }
    var isTypedArray = /* @__PURE__ */ function(TypedArray) {
      return function(thing) {
        return TypedArray && thing instanceof TypedArray;
      };
    }(typeof Uint8Array !== "undefined" && Object.getPrototypeOf(Uint8Array));
    function forEachEntry(obj, fn) {
      var generator = obj && obj[Symbol.iterator];
      var iterator = generator.call(obj);
      var result;
      while ((result = iterator.next()) && !result.done) {
        var pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    }
    function matchAll(regExp, str) {
      var matches;
      var arr = [];
      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }
      return arr;
    }
    var isHTMLForm = kindOfTest("HTMLFormElement");
    var hasOwnProperty = /* @__PURE__ */ function resolver(_hasOwnProperty) {
      return function(obj, prop) {
        return _hasOwnProperty.call(obj, prop);
      };
    }(Object.prototype.hasOwnProperty);
    module.exports = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isObject,
      isPlainObject,
      isEmptyObject,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isFunction,
      isStream,
      isURLSearchParams,
      isStandardBrowserEnv,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      isTypedArray,
      isFileList,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty
    };
  }
});

// node_modules/axios/lib/core/AxiosError.js
var require_AxiosError = __commonJS({
  "node_modules/axios/lib/core/AxiosError.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    function AxiosError(message, code, config, request, response) {
      Error.call(this);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack;
      }
      this.message = message;
      this.name = "AxiosError";
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      response && (this.response = response);
    }
    utils4.inherits(AxiosError, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code,
          status: this.response && this.response.status ? this.response.status : null
        };
      }
    });
    var prototype = AxiosError.prototype;
    var descriptors = {};
    [
      "ERR_BAD_OPTION_VALUE",
      "ERR_BAD_OPTION",
      "ECONNABORTED",
      "ETIMEDOUT",
      "ERR_NETWORK",
      "ERR_FR_TOO_MANY_REDIRECTS",
      "ERR_DEPRECATED",
      "ERR_BAD_RESPONSE",
      "ERR_BAD_REQUEST",
      "ERR_CANCELED",
      "ERR_NOT_SUPPORT",
      "ERR_INVALID_URL"
      // eslint-disable-next-line func-names
    ].forEach(function(code) {
      descriptors[code] = { value: code };
    });
    Object.defineProperties(AxiosError, descriptors);
    Object.defineProperty(prototype, "isAxiosError", { value: true });
    AxiosError.from = function(error, code, config, request, response, customProps) {
      var axiosError = Object.create(prototype);
      utils4.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      });
      AxiosError.call(axiosError, error.message, code, config, request, response);
      axiosError.cause = error;
      axiosError.name = error.name;
      customProps && Object.assign(axiosError, customProps);
      return axiosError;
    };
    module.exports = AxiosError;
  }
});

// node_modules/form-data/lib/browser.js
var require_browser5 = __commonJS({
  "node_modules/form-data/lib/browser.js"(exports, module) {
    module.exports = typeof self == "object" ? self.FormData : window.FormData;
  }
});

// node_modules/axios/lib/env/classes/FormData.js
var require_FormData = __commonJS({
  "node_modules/axios/lib/env/classes/FormData.js"(exports, module) {
    module.exports = require_browser5();
  }
});

// node_modules/axios/lib/helpers/toFormData.js
var require_toFormData = __commonJS({
  "node_modules/axios/lib/helpers/toFormData.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var AxiosError = require_AxiosError();
    var envFormData = require_FormData();
    function isVisitable(thing) {
      return utils4.isPlainObject(thing) || utils4.isArray(thing);
    }
    function removeBrackets(key) {
      return utils4.endsWith(key, "[]") ? key.slice(0, -2) : key;
    }
    function renderKey(path, key, dots) {
      if (!path)
        return key;
      return path.concat(key).map(function each(token, i) {
        token = removeBrackets(token);
        return !dots && i ? "[" + token + "]" : token;
      }).join(dots ? "." : "");
    }
    function isFlatArray(arr) {
      return utils4.isArray(arr) && !arr.some(isVisitable);
    }
    var predicates = utils4.toFlatObject(utils4, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });
    function isSpecCompliant(thing) {
      return thing && utils4.isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator];
    }
    function toFormData(obj, formData, options) {
      if (!utils4.isObject(obj)) {
        throw new TypeError("target must be an object");
      }
      formData = formData || new (envFormData || FormData)();
      options = utils4.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        return !utils4.isUndefined(source[option]);
      });
      var metaTokens = options.metaTokens;
      var visitor = options.visitor || defaultVisitor;
      var dots = options.dots;
      var indexes = options.indexes;
      var _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
      var useBlob = _Blob && isSpecCompliant(formData);
      if (!utils4.isFunction(visitor)) {
        throw new TypeError("visitor must be a function");
      }
      function convertValue(value) {
        if (value === null)
          return "";
        if (utils4.isDate(value)) {
          return value.toISOString();
        }
        if (!useBlob && utils4.isBlob(value)) {
          throw new AxiosError("Blob is not supported. Use a Buffer instead.");
        }
        if (utils4.isArrayBuffer(value) || utils4.isTypedArray(value)) {
          return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
        }
        return value;
      }
      function defaultVisitor(value, key, path) {
        var arr = value;
        if (value && !path && typeof value === "object") {
          if (utils4.endsWith(key, "{}")) {
            key = metaTokens ? key : key.slice(0, -2);
            value = JSON.stringify(value);
          } else if (utils4.isArray(value) && isFlatArray(value) || (utils4.isFileList(value) || utils4.endsWith(key, "[]") && (arr = utils4.toArray(value)))) {
            key = removeBrackets(key);
            arr.forEach(function each(el, index) {
              !utils4.isUndefined(el) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
                convertValue(el)
              );
            });
            return false;
          }
        }
        if (isVisitable(value)) {
          return true;
        }
        formData.append(renderKey(path, key, dots), convertValue(value));
        return false;
      }
      var stack = [];
      var exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });
      function build(value, path) {
        if (utils4.isUndefined(value))
          return;
        if (stack.indexOf(value) !== -1) {
          throw Error("Circular reference detected in " + path.join("."));
        }
        stack.push(value);
        utils4.forEach(value, function each(el, key) {
          var result = !utils4.isUndefined(el) && visitor.call(
            formData,
            el,
            utils4.isString(key) ? key.trim() : key,
            path,
            exposedHelpers
          );
          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });
        stack.pop();
      }
      if (!utils4.isObject(obj)) {
        throw new TypeError("data must be an object");
      }
      build(obj);
      return formData;
    }
    module.exports = toFormData;
  }
});

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
var require_AxiosURLSearchParams = __commonJS({
  "node_modules/axios/lib/helpers/AxiosURLSearchParams.js"(exports, module) {
    "use strict";
    var toFormData = require_toFormData();
    function encode(str) {
      var charMap = {
        "!": "%21",
        "'": "%27",
        "(": "%28",
        ")": "%29",
        "~": "%7E",
        "%20": "+",
        "%00": "\0"
      };
      return encodeURIComponent(str).replace(/[!'\(\)~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];
      params && toFormData(params, this, options);
    }
    var prototype = AxiosURLSearchParams.prototype;
    prototype.append = function append2(name, value) {
      this._pairs.push([name, value]);
    };
    prototype.toString = function toString(encoder2) {
      var _encode = encoder2 ? function(value) {
        return encoder2.call(this, value, encode);
      } : encode;
      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + "=" + _encode(pair[1]);
      }, "").join("&");
    };
    module.exports = AxiosURLSearchParams;
  }
});

// node_modules/axios/lib/helpers/buildURL.js
var require_buildURL = __commonJS({
  "node_modules/axios/lib/helpers/buildURL.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var AxiosURLSearchParams = require_AxiosURLSearchParams();
    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    }
    module.exports = function buildURL(url, params, options) {
      if (!params) {
        return url;
      }
      var hashmarkIndex = url.indexOf("#");
      if (hashmarkIndex !== -1) {
        url = url.slice(0, hashmarkIndex);
      }
      var _encode = options && options.encode || encode;
      var serializeFn = options && options.serialize;
      var serializedParams;
      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils4.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
      }
      if (serializedParams) {
        url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
      }
      return url;
    };
  }
});

// node_modules/axios/lib/core/InterceptorManager.js
var require_InterceptorManager = __commonJS({
  "node_modules/axios/lib/core/InterceptorManager.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    function InterceptorManager() {
      this.handlers = [];
    }
    InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    };
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    InterceptorManager.prototype.clear = function clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    };
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils4.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };
    module.exports = InterceptorManager;
  }
});

// node_modules/axios/lib/helpers/normalizeHeaderName.js
var require_normalizeHeaderName = __commonJS({
  "node_modules/axios/lib/helpers/normalizeHeaderName.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    module.exports = function normalizeHeaderName(headers, normalizedName) {
      utils4.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };
  }
});

// node_modules/axios/lib/defaults/transitional.js
var require_transitional = __commonJS({
  "node_modules/axios/lib/defaults/transitional.js"(exports, module) {
    "use strict";
    module.exports = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };
  }
});

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var require_URLSearchParams = __commonJS({
  "node_modules/axios/lib/platform/browser/classes/URLSearchParams.js"(exports, module) {
    "use strict";
    var AxiosURLSearchParams = require_AxiosURLSearchParams();
    module.exports = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  }
});

// node_modules/axios/lib/platform/browser/classes/FormData.js
var require_FormData2 = __commonJS({
  "node_modules/axios/lib/platform/browser/classes/FormData.js"(exports, module) {
    "use strict";
    module.exports = FormData;
  }
});

// node_modules/axios/lib/platform/browser/index.js
var require_browser6 = __commonJS({
  "node_modules/axios/lib/platform/browser/index.js"(exports, module) {
    "use strict";
    module.exports = {
      isBrowser: true,
      classes: {
        URLSearchParams: require_URLSearchParams(),
        FormData: require_FormData2(),
        Blob
      },
      protocols: ["http", "https", "file", "blob", "url", "data"]
    };
  }
});

// node_modules/axios/lib/platform/index.js
var require_platform = __commonJS({
  "node_modules/axios/lib/platform/index.js"(exports, module) {
    "use strict";
    module.exports = require_browser6();
  }
});

// node_modules/axios/lib/helpers/toURLEncodedForm.js
var require_toURLEncodedForm = __commonJS({
  "node_modules/axios/lib/helpers/toURLEncodedForm.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var toFormData = require_toFormData();
    var platform = require_platform();
    module.exports = function toURLEncodedForm(data, options) {
      return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils4.isBuffer(value)) {
            this.append(key, value.toString("base64"));
            return false;
          }
          return helpers.defaultVisitor.apply(this, arguments);
        }
      }, options));
    };
  }
});

// node_modules/axios/lib/helpers/formDataToJSON.js
var require_formDataToJSON = __commonJS({
  "node_modules/axios/lib/helpers/formDataToJSON.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    function parsePropPath(name) {
      return utils4.matchAll(/\w+|\[(\w*)]/g, name).map(function(match) {
        return match[0] === "[]" ? "" : match[1] || match[0];
      });
    }
    function arrayToObject(arr) {
      var obj = {};
      var keys = Object.keys(arr);
      var i;
      var len = keys.length;
      var key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        var name = path[index++];
        var isNumericKey = Number.isFinite(+name);
        var isLast = index >= path.length;
        name = !name && utils4.isArray(target) ? target.length : name;
        if (isLast) {
          if (utils4.hasOwnProperty(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }
          return !isNumericKey;
        }
        if (!target[name] || !utils4.isObject(target[name])) {
          target[name] = [];
        }
        var result = buildPath(path, value, target[name], index);
        if (result && utils4.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }
        return !isNumericKey;
      }
      if (utils4.isFormData(formData) && utils4.isFunction(formData.entries)) {
        var obj = {};
        utils4.forEachEntry(formData, function(name, value) {
          buildPath(parsePropPath(name), value, obj, 0);
        });
        return obj;
      }
      return null;
    }
    module.exports = formDataToJSON;
  }
});

// node_modules/axios/lib/core/settle.js
var require_settle = __commonJS({
  "node_modules/axios/lib/core/settle.js"(exports, module) {
    "use strict";
    var AxiosError = require_AxiosError();
    module.exports = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError(
          "Request failed with status code " + response.status,
          [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    };
  }
});

// node_modules/axios/lib/helpers/cookies.js
var require_cookies = __commonJS({
  "node_modules/axios/lib/helpers/cookies.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    module.exports = utils4.isStandardBrowserEnv() ? (
      // Standard browser envs support document.cookie
      /* @__PURE__ */ function standardBrowserEnv() {
        return {
          write: function write(name, value, expires, path, domain, secure) {
            var cookie = [];
            cookie.push(name + "=" + encodeURIComponent(value));
            if (utils4.isNumber(expires)) {
              cookie.push("expires=" + new Date(expires).toGMTString());
            }
            if (utils4.isString(path)) {
              cookie.push("path=" + path);
            }
            if (utils4.isString(domain)) {
              cookie.push("domain=" + domain);
            }
            if (secure === true) {
              cookie.push("secure");
            }
            document.cookie = cookie.join("; ");
          },
          read: function read(name) {
            var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
            return match ? decodeURIComponent(match[3]) : null;
          },
          remove: function remove(name) {
            this.write(name, "", Date.now() - 864e5);
          }
        };
      }()
    ) : (
      // Non standard browser env (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return {
          write: function write() {
          },
          read: function read() {
            return null;
          },
          remove: function remove() {
          }
        };
      }()
    );
  }
});

// node_modules/axios/lib/helpers/isAbsoluteURL.js
var require_isAbsoluteURL = __commonJS({
  "node_modules/axios/lib/helpers/isAbsoluteURL.js"(exports, module) {
    "use strict";
    module.exports = function isAbsoluteURL(url) {
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    };
  }
});

// node_modules/axios/lib/helpers/combineURLs.js
var require_combineURLs = __commonJS({
  "node_modules/axios/lib/helpers/combineURLs.js"(exports, module) {
    "use strict";
    module.exports = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
    };
  }
});

// node_modules/axios/lib/core/buildFullPath.js
var require_buildFullPath = __commonJS({
  "node_modules/axios/lib/core/buildFullPath.js"(exports, module) {
    "use strict";
    var isAbsoluteURL = require_isAbsoluteURL();
    var combineURLs = require_combineURLs();
    module.exports = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };
  }
});

// node_modules/axios/lib/helpers/parseHeaders.js
var require_parseHeaders = __commonJS({
  "node_modules/axios/lib/helpers/parseHeaders.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var ignoreDuplicateOf = [
      "age",
      "authorization",
      "content-length",
      "content-type",
      "etag",
      "expires",
      "from",
      "host",
      "if-modified-since",
      "if-unmodified-since",
      "last-modified",
      "location",
      "max-forwards",
      "proxy-authorization",
      "referer",
      "retry-after",
      "user-agent"
    ];
    module.exports = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;
      if (!headers) {
        return parsed;
      }
      utils4.forEach(headers.split("\n"), function parser(line) {
        i = line.indexOf(":");
        key = utils4.trim(line.slice(0, i)).toLowerCase();
        val = utils4.trim(line.slice(i + 1));
        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === "set-cookie") {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
          }
        }
      });
      return parsed;
    };
  }
});

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var require_isURLSameOrigin = __commonJS({
  "node_modules/axios/lib/helpers/isURLSameOrigin.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    module.exports = utils4.isStandardBrowserEnv() ? (
      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
      function standardBrowserEnv() {
        var msie = /(msie|trident)/i.test(navigator.userAgent);
        var urlParsingNode = document.createElement("a");
        var originURL;
        function resolveURL(url) {
          var href = url;
          if (msie) {
            urlParsingNode.setAttribute("href", href);
            href = urlParsingNode.href;
          }
          urlParsingNode.setAttribute("href", href);
          return {
            href: urlParsingNode.href,
            protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
            host: urlParsingNode.host,
            search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
            hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
            hostname: urlParsingNode.hostname,
            port: urlParsingNode.port,
            pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
          };
        }
        originURL = resolveURL(window.location.href);
        return function isURLSameOrigin(requestURL) {
          var parsed = utils4.isString(requestURL) ? resolveURL(requestURL) : requestURL;
          return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
        };
      }()
    ) : (
      // Non standard browser envs (web workers, react-native) lack needed support.
      /* @__PURE__ */ function nonStandardBrowserEnv() {
        return function isURLSameOrigin() {
          return true;
        };
      }()
    );
  }
});

// node_modules/axios/lib/cancel/CanceledError.js
var require_CanceledError = __commonJS({
  "node_modules/axios/lib/cancel/CanceledError.js"(exports, module) {
    "use strict";
    var AxiosError = require_AxiosError();
    var utils4 = require_utils7();
    function CanceledError(message, config, request) {
      AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
      this.name = "CanceledError";
    }
    utils4.inherits(CanceledError, AxiosError, {
      __CANCEL__: true
    });
    module.exports = CanceledError;
  }
});

// node_modules/axios/lib/helpers/parseProtocol.js
var require_parseProtocol = __commonJS({
  "node_modules/axios/lib/helpers/parseProtocol.js"(exports, module) {
    "use strict";
    module.exports = function parseProtocol(url) {
      var match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || "";
    };
  }
});

// node_modules/axios/lib/adapters/xhr.js
var require_xhr = __commonJS({
  "node_modules/axios/lib/adapters/xhr.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var settle = require_settle();
    var cookies = require_cookies();
    var buildURL = require_buildURL();
    var buildFullPath = require_buildFullPath();
    var parseHeaders = require_parseHeaders();
    var isURLSameOrigin = require_isURLSameOrigin();
    var transitionalDefaults = require_transitional();
    var AxiosError = require_AxiosError();
    var CanceledError = require_CanceledError();
    var parseProtocol = require_parseProtocol();
    var platform = require_platform();
    module.exports = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;
        var responseType = config.responseType;
        var withXSRFToken = config.withXSRFToken;
        var onCanceled;
        function done() {
          if (config.cancelToken) {
            config.cancelToken.unsubscribe(onCanceled);
          }
          if (config.signal) {
            config.signal.removeEventListener("abort", onCanceled);
          }
        }
        if (utils4.isFormData(requestData) && utils4.isStandardBrowserEnv()) {
          delete requestHeaders["Content-Type"];
        }
        var request = new XMLHttpRequest();
        if (config.auth) {
          var username = config.auth.username || "";
          var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
          requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
        }
        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
        request.timeout = config.timeout;
        function onloadend() {
          if (!request) {
            return;
          }
          var responseHeaders = "getAllResponseHeaders" in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };
          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);
          request = null;
        }
        if ("onloadend" in request) {
          request.onloadend = onloadend;
        } else {
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
              return;
            }
            setTimeout(onloadend);
          };
        }
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }
          reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
          request = null;
        };
        request.onerror = function handleError() {
          reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
          request = null;
        };
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
          var transitional = config.transitional || transitionalDefaults;
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(new AxiosError(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
            config,
            request
          ));
          request = null;
        };
        if (utils4.isStandardBrowserEnv()) {
          withXSRFToken && utils4.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(config));
          if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(fullPath)) {
            var xsrfValue = config.xsrfHeaderName && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
            if (xsrfValue) {
              requestHeaders[config.xsrfHeaderName] = xsrfValue;
            }
          }
        }
        if ("setRequestHeader" in request) {
          utils4.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
              delete requestHeaders[key];
            } else {
              request.setRequestHeader(key, val);
            }
          });
        }
        if (!utils4.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }
        if (responseType && responseType !== "json") {
          request.responseType = config.responseType;
        }
        if (typeof config.onDownloadProgress === "function") {
          request.addEventListener("progress", config.onDownloadProgress);
        }
        if (typeof config.onUploadProgress === "function" && request.upload) {
          request.upload.addEventListener("progress", config.onUploadProgress);
        }
        if (config.cancelToken || config.signal) {
          onCanceled = function(cancel) {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
            request.abort();
            request = null;
          };
          config.cancelToken && config.cancelToken.subscribe(onCanceled);
          if (config.signal) {
            config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
          }
        }
        if (!requestData && requestData !== false && requestData !== 0 && requestData !== "") {
          requestData = null;
        }
        var protocol = parseProtocol(fullPath);
        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
          return;
        }
        request.send(requestData);
      });
    };
  }
});

// node_modules/axios/lib/defaults/index.js
var require_defaults = __commonJS({
  "node_modules/axios/lib/defaults/index.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var normalizeHeaderName = require_normalizeHeaderName();
    var AxiosError = require_AxiosError();
    var transitionalDefaults = require_transitional();
    var toFormData = require_toFormData();
    var toURLEncodedForm = require_toURLEncodedForm();
    var platform = require_platform();
    var formDataToJSON = require_formDataToJSON();
    var DEFAULT_CONTENT_TYPE = {
      "Content-Type": "application/x-www-form-urlencoded"
    };
    function setContentTypeIfUnset(headers, value) {
      if (!utils4.isUndefined(headers) && utils4.isUndefined(headers["Content-Type"])) {
        headers["Content-Type"] = value;
      }
    }
    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== "undefined") {
        adapter = require_xhr();
      } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
        adapter = require_xhr();
      }
      return adapter;
    }
    function stringifySafely(rawValue, parser, encoder2) {
      if (utils4.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils4.trim(rawValue);
        } catch (e) {
          if (e.name !== "SyntaxError") {
            throw e;
          }
        }
      }
      return (encoder2 || JSON.stringify)(rawValue);
    }
    var defaults = {
      transitional: transitionalDefaults,
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, "Accept");
        normalizeHeaderName(headers, "Content-Type");
        var contentType = headers && headers["Content-Type"] || "";
        var hasJSONContentType = contentType.indexOf("application/json") > -1;
        var isObjectPayload = utils4.isObject(data);
        if (isObjectPayload && utils4.isHTMLForm(data)) {
          data = new FormData(data);
        }
        var isFormData = utils4.isFormData(data);
        if (isFormData) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }
        if (utils4.isArrayBuffer(data) || utils4.isBuffer(data) || utils4.isStream(data) || utils4.isFile(data) || utils4.isBlob(data)) {
          return data;
        }
        if (utils4.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils4.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
          return data.toString();
        }
        var isFileList;
        if (isObjectPayload) {
          if (contentType.indexOf("application/x-www-form-urlencoded") !== -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }
          if ((isFileList = utils4.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
            var _FormData = this.env && this.env.FormData;
            return toFormData(
              isFileList ? { "files[]": data } : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }
        if (isObjectPayload || hasJSONContentType) {
          setContentTypeIfUnset(headers, "application/json");
          return stringifySafely(data);
        }
        return data;
      }],
      transformResponse: [function transformResponse(data) {
        var transitional = this.transitional || defaults.transitional;
        var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        var JSONRequested = this.responseType === "json";
        if (data && utils4.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
          var silentJSONParsing = transitional && transitional.silentJSONParsing;
          var strictJSONParsing = !silentJSONParsing && JSONRequested;
          try {
            return JSON.parse(data);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === "SyntaxError") {
                throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }
        return data;
      }],
      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: "XSRF-TOKEN",
      xsrfHeaderName: "X-XSRF-TOKEN",
      maxContentLength: -1,
      maxBodyLength: -1,
      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },
      headers: {
        common: {
          "Accept": "application/json, text/plain, */*"
        }
      }
    };
    utils4.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      defaults.headers[method] = utils4.merge(DEFAULT_CONTENT_TYPE);
    });
    module.exports = defaults;
  }
});

// node_modules/axios/lib/core/transformData.js
var require_transformData = __commonJS({
  "node_modules/axios/lib/core/transformData.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var defaults = require_defaults();
    module.exports = function transformData(data, headers, status, fns) {
      var context = this || defaults;
      utils4.forEach(fns, function transform(fn) {
        data = fn.call(context, data, headers, status);
      });
      return data;
    };
  }
});

// node_modules/axios/lib/cancel/isCancel.js
var require_isCancel = __commonJS({
  "node_modules/axios/lib/cancel/isCancel.js"(exports, module) {
    "use strict";
    module.exports = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };
  }
});

// node_modules/axios/lib/core/dispatchRequest.js
var require_dispatchRequest = __commonJS({
  "node_modules/axios/lib/core/dispatchRequest.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var transformData = require_transformData();
    var isCancel = require_isCancel();
    var defaults = require_defaults();
    var CanceledError = require_CanceledError();
    var normalizeHeaderName = require_normalizeHeaderName();
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
      if (config.signal && config.signal.aborted) {
        throw new CanceledError();
      }
    }
    module.exports = function dispatchRequest(config) {
      throwIfCancellationRequested(config);
      config.headers = config.headers || {};
      config.data = transformData.call(
        config,
        config.data,
        config.headers,
        null,
        config.transformRequest
      );
      normalizeHeaderName(config.headers, "Accept");
      normalizeHeaderName(config.headers, "Content-Type");
      config.headers = utils4.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );
      utils4.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );
      var adapter = config.adapter || defaults.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);
        response.data = transformData.call(
          config,
          response.data,
          response.headers,
          response.status,
          config.transformResponse
        );
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              reason.response.data,
              reason.response.headers,
              reason.response.status,
              config.transformResponse
            );
          }
        }
        return Promise.reject(reason);
      });
    };
  }
});

// node_modules/axios/lib/core/mergeConfig.js
var require_mergeConfig = __commonJS({
  "node_modules/axios/lib/core/mergeConfig.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    module.exports = function mergeConfig(config1, config2) {
      config2 = config2 || {};
      var config = {};
      function getMergedValue(target, source) {
        if (utils4.isPlainObject(target) && utils4.isPlainObject(source)) {
          return utils4.merge(target, source);
        } else if (utils4.isEmptyObject(source)) {
          return utils4.merge({}, target);
        } else if (utils4.isPlainObject(source)) {
          return utils4.merge({}, source);
        } else if (utils4.isArray(source)) {
          return source.slice();
        }
        return source;
      }
      function mergeDeepProperties(prop) {
        if (!utils4.isUndefined(config2[prop])) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (!utils4.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function valueFromConfig2(prop) {
        if (!utils4.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        }
      }
      function defaultToConfig2(prop) {
        if (!utils4.isUndefined(config2[prop])) {
          return getMergedValue(void 0, config2[prop]);
        } else if (!utils4.isUndefined(config1[prop])) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      function mergeDirectKeys(prop) {
        if (prop in config2) {
          return getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          return getMergedValue(void 0, config1[prop]);
        }
      }
      var mergeMap = {
        "url": valueFromConfig2,
        "method": valueFromConfig2,
        "data": valueFromConfig2,
        "baseURL": defaultToConfig2,
        "transformRequest": defaultToConfig2,
        "transformResponse": defaultToConfig2,
        "paramsSerializer": defaultToConfig2,
        "timeout": defaultToConfig2,
        "timeoutMessage": defaultToConfig2,
        "withCredentials": defaultToConfig2,
        "withXSRFToken": defaultToConfig2,
        "adapter": defaultToConfig2,
        "responseType": defaultToConfig2,
        "xsrfCookieName": defaultToConfig2,
        "xsrfHeaderName": defaultToConfig2,
        "onUploadProgress": defaultToConfig2,
        "onDownloadProgress": defaultToConfig2,
        "decompress": defaultToConfig2,
        "maxContentLength": defaultToConfig2,
        "maxBodyLength": defaultToConfig2,
        "beforeRedirect": defaultToConfig2,
        "transport": defaultToConfig2,
        "httpAgent": defaultToConfig2,
        "httpsAgent": defaultToConfig2,
        "cancelToken": defaultToConfig2,
        "socketPath": defaultToConfig2,
        "responseEncoding": defaultToConfig2,
        "validateStatus": mergeDirectKeys
      };
      utils4.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {
        var merge = mergeMap[prop] || mergeDeepProperties;
        var configValue = merge(prop);
        utils4.isUndefined(configValue) && merge !== mergeDirectKeys || (config[prop] = configValue);
      });
      return config;
    };
  }
});

// node_modules/axios/lib/env/data.js
var require_data = __commonJS({
  "node_modules/axios/lib/env/data.js"(exports, module) {
    module.exports = {
      "version": "0.28.1"
    };
  }
});

// node_modules/axios/lib/helpers/validator.js
var require_validator = __commonJS({
  "node_modules/axios/lib/helpers/validator.js"(exports, module) {
    "use strict";
    var VERSION = require_data().version;
    var AxiosError = require_AxiosError();
    var validators = {};
    ["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
      validators[type] = function validator(thing) {
        return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
      };
    });
    var deprecatedWarnings = {};
    validators.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
      }
      return function(value, opt, opts) {
        if (validator === false) {
          throw new AxiosError(
            formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
            AxiosError.ERR_DEPRECATED
          );
        }
        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          console.warn(
            formatMessage(
              opt,
              " has been deprecated since v" + version + " and will be removed in the near future"
            )
          );
        }
        return validator ? validator(value, opt, opts) : true;
      };
    };
    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== "object") {
        throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
      }
      var keys = Object.keys(options);
      var i = keys.length;
      while (i-- > 0) {
        var opt = keys[i];
        var validator = schema[opt];
        if (validator) {
          var value = options[opt];
          var result = value === void 0 || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
        }
      }
    }
    module.exports = {
      assertOptions,
      validators
    };
  }
});

// node_modules/axios/lib/core/Axios.js
var require_Axios = __commonJS({
  "node_modules/axios/lib/core/Axios.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var buildURL = require_buildURL();
    var InterceptorManager = require_InterceptorManager();
    var dispatchRequest = require_dispatchRequest();
    var mergeConfig = require_mergeConfig();
    var buildFullPath = require_buildFullPath();
    var validator = require_validator();
    var validators = validator.validators;
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager(),
        response: new InterceptorManager()
      };
    }
    Axios.prototype.request = function request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = "get";
      }
      var transitional = config.transitional;
      if (transitional !== void 0) {
        validator.assertOptions(transitional, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      var paramsSerializer = config.paramsSerializer;
      if (paramsSerializer !== void 0) {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
      utils4.isFunction(paramsSerializer) && (config.paramsSerializer = { serialize: paramsSerializer });
      var requestInterceptorChain = [];
      var synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      var responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      var promise;
      if (!synchronousRequestInterceptors) {
        var chain = [dispatchRequest, void 0];
        Array.prototype.unshift.apply(chain, requestInterceptorChain);
        chain = chain.concat(responseInterceptorChain);
        promise = Promise.resolve(config);
        while (chain.length) {
          promise = promise.then(chain.shift(), chain.shift());
        }
        return promise;
      }
      var newConfig = config;
      while (requestInterceptorChain.length) {
        var onFulfilled = requestInterceptorChain.shift();
        var onRejected = requestInterceptorChain.shift();
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected(error);
          break;
        }
      }
      try {
        promise = dispatchRequest(newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      while (responseInterceptorChain.length) {
        promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
      }
      return promise;
    };
    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      var fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    };
    utils4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });
    utils4.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig(config || {}, {
            method,
            headers: isForm ? {
              "Content-Type": "multipart/form-data"
            } : {},
            url,
            data
          }));
        };
      }
      Axios.prototype[method] = generateHTTPMethod();
      Axios.prototype[method + "Form"] = generateHTTPMethod(true);
    });
    module.exports = Axios;
  }
});

// node_modules/axios/lib/cancel/CancelToken.js
var require_CancelToken = __commonJS({
  "node_modules/axios/lib/cancel/CancelToken.js"(exports, module) {
    "use strict";
    var CanceledError = require_CanceledError();
    function CancelToken(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      this.promise.then(function(cancel) {
        if (!token._listeners)
          return;
        var i = token._listeners.length;
        while (i-- > 0) {
          token._listeners[i](cancel);
        }
        token._listeners = null;
      });
      this.promise.then = function(onfulfilled) {
        var _resolve;
        var promise = new Promise(function(resolve) {
          token.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token.reason) {
          return;
        }
        token.reason = new CanceledError(message, config, request);
        resolvePromise(token.reason);
      });
    }
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    CancelToken.prototype.subscribe = function subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    };
    CancelToken.prototype.unsubscribe = function unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      var index = this._listeners.indexOf(listener);
      if (index !== -1) {
        this._listeners.splice(index, 1);
      }
    };
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token,
        cancel
      };
    };
    module.exports = CancelToken;
  }
});

// node_modules/axios/lib/helpers/spread.js
var require_spread = __commonJS({
  "node_modules/axios/lib/helpers/spread.js"(exports, module) {
    "use strict";
    module.exports = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };
  }
});

// node_modules/axios/lib/helpers/isAxiosError.js
var require_isAxiosError = __commonJS({
  "node_modules/axios/lib/helpers/isAxiosError.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    module.exports = function isAxiosError(payload) {
      return utils4.isObject(payload) && payload.isAxiosError === true;
    };
  }
});

// node_modules/axios/lib/axios.js
var require_axios = __commonJS({
  "node_modules/axios/lib/axios.js"(exports, module) {
    "use strict";
    var utils4 = require_utils7();
    var bind = require_bind();
    var Axios = require_Axios();
    var mergeConfig = require_mergeConfig();
    var defaults = require_defaults();
    var formDataToJSON = require_formDataToJSON();
    function createInstance(defaultConfig) {
      var context = new Axios(defaultConfig);
      var instance = bind(Axios.prototype.request, context);
      utils4.extend(instance, Axios.prototype, context);
      utils4.extend(instance, context);
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig(defaultConfig, instanceConfig));
      };
      return instance;
    }
    var axios2 = createInstance(defaults);
    axios2.Axios = Axios;
    axios2.CanceledError = require_CanceledError();
    axios2.CancelToken = require_CancelToken();
    axios2.isCancel = require_isCancel();
    axios2.VERSION = require_data().version;
    axios2.toFormData = require_toFormData();
    axios2.AxiosError = require_AxiosError();
    axios2.Cancel = axios2.CanceledError;
    axios2.all = function all(promises) {
      return Promise.all(promises);
    };
    axios2.spread = require_spread();
    axios2.isAxiosError = require_isAxiosError();
    axios2.formToJSON = function(thing) {
      return formDataToJSON(utils4.isHTMLForm(thing) ? new FormData(thing) : thing);
    };
    module.exports = axios2;
    module.exports.default = axios2;
  }
});

// node_modules/axios/index.js
var require_axios2 = __commonJS({
  "node_modules/axios/index.js"(exports, module) {
    module.exports = require_axios();
  }
});

// node_modules/@filen/sdk/dist/browser/utils.js
var import_path = __toESM(require_path());

// node_modules/uuid/dist/esm-browser/regex.js
var regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;

// node_modules/uuid/dist/esm-browser/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default = validate;

// node_modules/uuid/dist/esm-browser/parse.js
function parse(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  var v;
  var arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default = parse;

// node_modules/uuid/dist/esm-browser/stringify.js
var byteToHex = [];
for (i = 0; i < 256; ++i) {
  byteToHex.push((i + 256).toString(16).slice(1));
}
var i;
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}

// node_modules/uuid/dist/esm-browser/rng.js
var getRandomValues;
var rnds8 = new Uint8Array(16);
function rng() {
  if (!getRandomValues) {
    getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
    if (!getRandomValues) {
      throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
    }
  }
  return getRandomValues(rnds8);
}

// node_modules/uuid/dist/esm-browser/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  var bytes = [];
  for (var i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function v35(name, version, hashfunc) {
  function generateUUID(value, namespace, buf, offset) {
    var _namespace;
    if (typeof value === "string") {
      value = stringToBytes(value);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    var bytes = new Uint8Array(16 + value.length);
    bytes.set(namespace);
    bytes.set(value, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (var i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}

// node_modules/uuid/dist/esm-browser/md5.js
function md5(bytes) {
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = new Uint8Array(msg.length);
    for (var i = 0; i < msg.length; ++i) {
      bytes[i] = msg.charCodeAt(i);
    }
  }
  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
}
function md5ToHexEncodedArray(input) {
  var output = [];
  var length32 = input.length * 32;
  var hexTab = "0123456789abcdef";
  for (var i = 0; i < length32; i += 8) {
    var x = input[i >> 5] >>> i % 32 & 255;
    var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
    output.push(hex);
  }
  return output;
}
function getOutputLength(inputLength8) {
  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
}
function wordsToMd5(x, len) {
  x[len >> 5] |= 128 << len % 32;
  x[getOutputLength(len) - 1] = len;
  var a = 1732584193;
  var b = -271733879;
  var c = -1732584194;
  var d = 271733878;
  for (var i = 0; i < x.length; i += 16) {
    var olda = a;
    var oldb = b;
    var oldc = c;
    var oldd = d;
    a = md5ff(a, b, c, d, x[i], 7, -680876936);
    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
    b = md5gg(b, c, d, a, x[i], 20, -373897302);
    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
    d = md5hh(d, a, b, c, x[i], 11, -358537222);
    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
    a = md5ii(a, b, c, d, x[i], 6, -198630844);
    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
    a = safeAdd(a, olda);
    b = safeAdd(b, oldb);
    c = safeAdd(c, oldc);
    d = safeAdd(d, oldd);
  }
  return [a, b, c, d];
}
function bytesToWords(input) {
  if (input.length === 0) {
    return [];
  }
  var length8 = input.length * 8;
  var output = new Uint32Array(getOutputLength(length8));
  for (var i = 0; i < length8; i += 8) {
    output[i >> 5] |= (input[i / 8] & 255) << i % 32;
  }
  return output;
}
function safeAdd(x, y) {
  var lsw = (x & 65535) + (y & 65535);
  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
  return msw << 16 | lsw & 65535;
}
function bitRotateLeft(num, cnt) {
  return num << cnt | num >>> 32 - cnt;
}
function md5cmn(q, a, b, x, s, t) {
  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
}
function md5ff(a, b, c, d, x, s, t) {
  return md5cmn(b & c | ~b & d, a, b, x, s, t);
}
function md5gg(a, b, c, d, x, s, t) {
  return md5cmn(b & d | c & ~d, a, b, x, s, t);
}
function md5hh(a, b, c, d, x, s, t) {
  return md5cmn(b ^ c ^ d, a, b, x, s, t);
}
function md5ii(a, b, c, d, x, s, t) {
  return md5cmn(c ^ (b | ~d), a, b, x, s, t);
}
var md5_default = md5;

// node_modules/uuid/dist/esm-browser/v3.js
var v3 = v35("v3", 48, md5_default);

// node_modules/uuid/dist/esm-browser/native.js
var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
var native_default = {
  randomUUID
};

// node_modules/uuid/dist/esm-browser/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  var rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (var i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default = v4;

// node_modules/uuid/dist/esm-browser/sha1.js
function f(s, x, y, z) {
  switch (s) {
    case 0:
      return x & y ^ ~x & z;
    case 1:
      return x ^ y ^ z;
    case 2:
      return x & y ^ x & z ^ y & z;
    case 3:
      return x ^ y ^ z;
  }
}
function ROTL(x, n) {
  return x << n | x >>> 32 - n;
}
function sha1(bytes) {
  var K = [1518500249, 1859775393, 2400959708, 3395469782];
  var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof bytes === "string") {
    var msg = unescape(encodeURIComponent(bytes));
    bytes = [];
    for (var i = 0; i < msg.length; ++i) {
      bytes.push(msg.charCodeAt(i));
    }
  } else if (!Array.isArray(bytes)) {
    bytes = Array.prototype.slice.call(bytes);
  }
  bytes.push(128);
  var l = bytes.length / 4 + 2;
  var N = Math.ceil(l / 16);
  var M = new Array(N);
  for (var _i = 0; _i < N; ++_i) {
    var arr = new Uint32Array(16);
    for (var j = 0; j < 16; ++j) {
      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];
    }
    M[_i] = arr;
  }
  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
  M[N - 1][14] = Math.floor(M[N - 1][14]);
  M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
  for (var _i2 = 0; _i2 < N; ++_i2) {
    var W = new Uint32Array(80);
    for (var t = 0; t < 16; ++t) {
      W[t] = M[_i2][t];
    }
    for (var _t = 16; _t < 80; ++_t) {
      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);
    }
    var a = H[0];
    var b = H[1];
    var c = H[2];
    var d = H[3];
    var e = H[4];
    for (var _t2 = 0; _t2 < 80; ++_t2) {
      var s = Math.floor(_t2 / 20);
      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;
      e = d;
      d = c;
      c = ROTL(b, 30) >>> 0;
      b = a;
      a = T;
    }
    H[0] = H[0] + a >>> 0;
    H[1] = H[1] + b >>> 0;
    H[2] = H[2] + c >>> 0;
    H[3] = H[3] + d >>> 0;
    H[4] = H[4] + e >>> 0;
  }
  return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
}
var sha1_default = sha1;

// node_modules/uuid/dist/esm-browser/v5.js
var v5 = v35("v5", 80, sha1_default);

// node_modules/@filen/sdk/dist/browser/constants.js
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.navigator !== "undefined" || // @ts-expect-error WorkerEnv's are not typed
typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope || // @ts-expect-error WorkerEnv's are not typed
typeof ServiceWorkerGlobalScope !== "undefined" && self instanceof ServiceWorkerGlobalScope;
var environment = isBrowser ? "browser" : "node";
var CHUNK_SIZE = 1024 * 1024;
var BUFFER_SIZE = 4096;
var BASE64_BUFFER_SIZE = 3 * 1024;
var MAX_CONCURRENT_DOWNLOADS = 16;
var MAX_DOWNLOAD_THREADS = 32;
var MAX_DOWNLOAD_WRITERS = 64;
var MAX_UPLOAD_THREADS = 16;
var CURRENT_FILE_ENCRYPTION_VERSION = 2;
var DEFAULT_UPLOAD_REGION = "de-1";
var DEFAULT_UPLOAD_BUCKET = "filen-1";
var UPLOAD_CHUNK_SIZE = 1024 * 1024;
var MAX_NOTE_SIZE = 1024 * 1024 - 1;
var MAX_CONCURRENT_LISTING_OPS = 128;
var MAX_CONCURRENT_UPLOADS = 8;
var MAX_CONCURRENT_DIRECTORY_UPLOADS = 2;
var MAX_CONCURRENT_DIRECTORY_DOWNLOADS = 2;
var MAX_CHAT_SIZE = 1024 * 64;
var MAX_CONCURRENT_SHARES = 64;

// node_modules/@filen/sdk/dist/browser/utils.js
var import_crypto = __toESM(require_crypto());
var import_os = __toESM(require_os());
var import_fs_extra = __toESM(require_lib());

// node_modules/js-xxhash/dist/esm/xxHash32.js
var PRIME32_1 = 2654435761;
var PRIME32_2 = 2246822519;
var PRIME32_3 = 3266489917;
var PRIME32_4 = 668265263;
var PRIME32_5 = 374761393;
var encoder;
function xxHash32(input, seed = 0) {
  const buffer = typeof input === "string" ? (encoder ?? (encoder = new TextEncoder())).encode(input) : input;
  const b = buffer;
  let acc = seed + PRIME32_5 & 4294967295;
  let offset = 0;
  if (b.length >= 16) {
    const accN = [
      seed + PRIME32_1 + PRIME32_2 & 4294967295,
      seed + PRIME32_2 & 4294967295,
      seed + 0 & 4294967295,
      seed - PRIME32_1 & 4294967295
    ];
    const b2 = buffer;
    const limit2 = b2.length - 16;
    let lane = 0;
    for (offset = 0; (offset & 4294967280) <= limit2; offset += 4) {
      const i = offset;
      const laneN0 = b2[i + 0] + (b2[i + 1] << 8);
      const laneN1 = b2[i + 2] + (b2[i + 3] << 8);
      const laneNP = laneN0 * PRIME32_2 + (laneN1 * PRIME32_2 << 16);
      let acc2 = accN[lane] + laneNP & 4294967295;
      acc2 = acc2 << 13 | acc2 >>> 19;
      const acc0 = acc2 & 65535;
      const acc1 = acc2 >>> 16;
      accN[lane] = acc0 * PRIME32_1 + (acc1 * PRIME32_1 << 16) & 4294967295;
      lane = lane + 1 & 3;
    }
    acc = (accN[0] << 1 | accN[0] >>> 31) + (accN[1] << 7 | accN[1] >>> 25) + (accN[2] << 12 | accN[2] >>> 20) + (accN[3] << 18 | accN[3] >>> 14) & 4294967295;
  }
  acc = acc + buffer.length & 4294967295;
  const limit = buffer.length - 4;
  for (; offset <= limit; offset += 4) {
    const i = offset;
    const laneN0 = b[i + 0] + (b[i + 1] << 8);
    const laneN1 = b[i + 2] + (b[i + 3] << 8);
    const laneP = laneN0 * PRIME32_3 + (laneN1 * PRIME32_3 << 16);
    acc = acc + laneP & 4294967295;
    acc = acc << 17 | acc >>> 15;
    acc = (acc & 65535) * PRIME32_4 + ((acc >>> 16) * PRIME32_4 << 16) & 4294967295;
  }
  for (; offset < b.length; ++offset) {
    const lane = b[offset];
    acc = acc + lane * PRIME32_5;
    acc = acc << 11 | acc >>> 21;
    acc = (acc & 65535) * PRIME32_1 + ((acc >>> 16) * PRIME32_1 << 16) & 4294967295;
  }
  acc = acc ^ acc >>> 15;
  acc = ((acc & 65535) * PRIME32_2 & 4294967295) + ((acc >>> 16) * PRIME32_2 << 16);
  acc = acc ^ acc >>> 13;
  acc = ((acc & 65535) * PRIME32_3 & 4294967295) + ((acc >>> 16) * PRIME32_3 << 16);
  acc = acc ^ acc >>> 16;
  return acc < 0 ? acc + 4294967296 : acc;
}

// node_modules/@filen/sdk/dist/browser/utils.js
async function sleep(ms) {
  await new Promise((resolve) => setTimeout(resolve, ms));
}
function convertTimestampToMs(timestamp) {
  const now = Date.now();
  if (Math.abs(now - timestamp) < Math.abs(now - timestamp * 1e3)) {
    return timestamp;
  }
  return Math.floor(timestamp * 1e3);
}
function normalizePath(path) {
  return import_path.default.normalize(path.split("file://").join("").split("file:/").join("").split("file:").join(""));
}
async function uuidv4() {
  if (environment === "node") {
    return import_crypto.default.randomUUID();
  }
  return v4_default();
}
function Uint8ArrayConcat(a1, a2) {
  const mergedArray = new Uint8Array(a1.length + a2.length);
  mergedArray.set(a1);
  mergedArray.set(a2, a1.length);
  return mergedArray;
}
async function promiseAllChunked(promises, chunkSize = 1e4) {
  const results = [];
  for (let i = 0; i < promises.length; i += chunkSize) {
    const chunkResults = await Promise.all(promises.slice(i, i + chunkSize));
    results.push(...chunkResults);
  }
  return results;
}
async function promiseAllSettledChunked(promises, chunkSize = 1e4) {
  const results = [];
  for (let i = 0; i < promises.length; i += chunkSize) {
    const chunkPromisesSettled = await Promise.allSettled(promises.slice(i, i + chunkSize));
    const chunkResults = chunkPromisesSettled.reduce((acc, current) => {
      if (current.status === "fulfilled") {
        acc.push(current.value);
      } else {
      }
      return acc;
    }, []);
    results.push(...chunkResults);
  }
  return results;
}
function getRandomArbitrary(min, max) {
  return Math.floor(Math.random() * (max - min) + min);
}
async function clearTempDirectory({ tmpDir }) {
  if (environment !== "node") {
    return;
  }
  tmpDir = normalizePath(tmpDir ? tmpDir : import_path.default.join(import_os.default.tmpdir(), "filen-sdk"));
  await import_fs_extra.default.rm(tmpDir, {
    force: true,
    maxRetries: 60 * 10,
    recursive: true,
    retryDelay: 100
  });
  await import_fs_extra.default.mkdir(tmpDir, {
    recursive: true
  });
}
function parseURLParams({ url }) {
  const urlParams = new URLSearchParams(new URL(url).search);
  const params = {};
  urlParams.forEach((value, key) => {
    params[key] = value;
  });
  return params;
}
function getEveryPossibleDirectoryPath(path) {
  const ex = path.split("/");
  if (ex.length <= 1) {
    return [path];
  }
  const paths = [];
  for (let i = 0; i < ex.length; i++) {
    const toJoin = [];
    for (let x = 0; x < i + 1; x++) {
      toJoin.push(ex[x]);
    }
    paths.push(toJoin.join("/"));
  }
  if (paths.length <= 0) {
    return [path];
  }
  return paths;
}
function simpleDate(timestamp) {
  try {
    return new Date(convertTimestampToMs(timestamp)).toString().split(" ").slice(0, 5).join(" ");
  } catch (e) {
    return (/* @__PURE__ */ new Date()).toString().split(" ").slice(0, 5).join(" ");
  }
}
function replacePathStartWithFromAndTo(path, from, to) {
  if (path.endsWith("/")) {
    path = path.slice(0, path.length - 1);
  }
  if (from.endsWith("/")) {
    from = from.slice(0, from.length - 1);
  }
  if (to.endsWith("/")) {
    to = to.slice(0, to.length - 1);
  }
  if (!path.startsWith("/")) {
    path = `/${path}`;
  }
  if (!from.startsWith("/")) {
    from = `/${from}`;
  }
  if (!to.startsWith("/")) {
    to = `/${to}`;
  }
  return `${to}${path.slice(from.length)}`;
}
function fastStringHash(input) {
  return input.substring(0, 8) + xxHash32(input, 0).toString(16) + input.substring(input.length - 8, input.length);
}
function realFileSize({ chunksSize, metadataDecrypted }) {
  return metadataDecrypted.name.length > 0 ? metadataDecrypted.size : typeof chunksSize === "number" && chunksSize > 0 ? chunksSize : 1;
}
async function nodeStreamToBuffer(stream) {
  const chunks = [];
  for await (const chunk of stream) {
    chunks.push(Buffer.isBuffer(chunk) ? chunk : Buffer.from(chunk));
  }
  return Buffer.concat(chunks);
}
var utils = {
  sleep,
  convertTimestampToMs,
  normalizePath,
  uuidv4,
  Uint8ArrayConcat,
  promiseAllChunked,
  getRandomArbitrary,
  clearTempDirectory,
  parseURLParams,
  getEveryPossibleDirectoryPath,
  simpleDate,
  replacePathStartWithFromAndTo,
  fastStringHash,
  nodeStreamToBuffer
};
var utils_default = utils;

// node_modules/@filen/sdk/dist/browser/api/client.js
var import_util = __toESM(require_util());
var import_stream = __toESM(require_stream());
var import_fs_extra2 = __toESM(require_lib());

// node_modules/@filen/sdk/dist/browser/api/errors.js
var APIError = class _APIError extends Error {
  /**
   * Creates an instance of APIError.
   * @date 2/16/2024 - 5:19:35 AM
   *
   * @constructor
   * @public
   * @param {{ code: string, message: string }} param0
   * @param {string} param0.code
   * @param {string} param0.message
   */
  constructor({ code, message }) {
    super(message);
    __publicField(this, "code");
    __publicField(this, "message");
    __publicField(this, "name");
    this.name = "APIError";
    this.code = code;
    this.message = message;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _APIError);
    }
  }
};

// node_modules/@filen/sdk/dist/browser/api/client.js
var import_https = __toESM(require_https());
var import_url = __toESM(require_url());
var import_progress_stream = __toESM(require_progress_stream());
var import_agentkeepalive = __toESM(require_browser2());
var pipelineAsync = (0, import_util.promisify)(import_stream.pipeline);
var keepAliveAgent = new import_agentkeepalive.default.HttpsAgent();
var APIClientDefaults = {
  gatewayURLs: [
    "https://gateway.filen.io",
    "https://gateway.filen.net",
    "https://gateway.filen-1.net",
    "https://gateway.filen-2.net",
    "https://gateway.filen-3.net",
    "https://gateway.filen-4.net",
    "https://gateway.filen-5.net",
    "https://gateway.filen-6.net"
  ],
  egestURLs: [
    "https://egest.filen.io",
    "https://egest.filen.net",
    "https://egest.filen-1.net",
    "https://egest.filen-2.net",
    "https://egest.filen-3.net",
    "https://egest.filen-4.net",
    "https://egest.filen-5.net",
    "https://egest.filen-6.net"
  ],
  ingestURLs: [
    "https://ingest.filen.io",
    "https://ingest.filen.net",
    "https://ingest.filen-1.net",
    "https://ingest.filen-2.net",
    "https://ingest.filen-3.net",
    "https://ingest.filen-4.net",
    "https://ingest.filen-5.net",
    "https://ingest.filen-6.net"
  ],
  gatewayTimeout: 3e5,
  egestTimeout: 18e5,
  ingestTimeout: 36e5,
  maxRetries: 3600 * 3,
  retryTimeout: 1e3
};
var APIClient = class {
  /**
   * Creates an instance of APIClient.
   * @date 1/31/2024 - 4:09:17 PM
   *
   * @constructor
   * @public
   * @param {APIClientConfig} params
   */
  constructor(params) {
    __publicField(this, "apiKey");
    __publicField(this, "sdk");
    this.apiKey = params.apiKey;
    this.sdk = params.sdk;
  }
  /**
   * Build API request headers.
   * @date 2/21/2024 - 8:42:27 AM
   *
   * @private
   * @param {?{ apiKey?: string }} [params]
   * @returns {Record<string, string>}
   */
  buildHeaders(params) {
    return {
      Authorization: "Bearer " + (params && params.apiKey ? params.apiKey : this.apiKey),
      Accept: "application/json, text/plain, */*",
      ...environment === "node" ? { "User-Agent": "filen-sdk" } : {}
    };
  }
  /**
   * Send a POST request.
   * @date 2/1/2024 - 2:48:57 AM
   *
   * @private
   * @async
   * @param {PostRequestParameters} params
   * @returns {Promise<AxiosResponse<any, any>>}
   */
  async post(params) {
    let headers = params.headers ? params.headers : this.buildHeaders({ apiKey: params.apiKey });
    if (params.apiKey && !headers["Authorization"]) {
      headers["Authorization"] = `Bearer ${params.apiKey}`;
    }
    const url = params.url ? params.url : APIClientDefaults.gatewayURLs[getRandomArbitrary(0, APIClientDefaults.gatewayURLs.length - 1)];
    if (!url) {
      throw new Error("No URL.");
    }
    const postDataIsBuffer = params.data instanceof Buffer || params.data instanceof Uint8Array || params.data instanceof ArrayBuffer;
    if (!params.headers && !postDataIsBuffer) {
      headers = {
        ...headers,
        Checksum: await this.sdk.getWorker().crypto.utils.bufferToHash({
          buffer: Buffer.from(JSON.stringify(params.data), "utf-8"),
          algorithm: "sha512"
        })
      };
    }
    let lastBytesUploaded = 0;
    if (environment === "node") {
      return new Promise((resolve, reject) => {
        const urlParsed = import_url.default.parse(url, true);
        const timeout = params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout;
        const request = import_https.default.request({
          method: "POST",
          hostname: urlParsed.hostname,
          path: params.endpoint,
          port: 443,
          timeout,
          agent: keepAliveAgent,
          headers: {
            ...headers,
            ...postDataIsBuffer ? {} : { "Content-Type": "application/json" }
          }
        }, (response) => {
          var _a;
          if ((_a = params.abortSignal) == null ? void 0 : _a.aborted) {
            request.destroy();
            response.destroy();
            reject(new Error("Aborted"));
            return;
          }
          if (request.destroyed || response.destroyed) {
            reject(new Error("Aborted"));
            return;
          }
          if (response.statusCode !== 200) {
            resolve({
              status: response.statusCode ?? 500,
              statusText: "",
              data: null,
              headers,
              config: null
            });
            return;
          }
          if (params.responseType === "stream") {
            resolve({
              status: 200,
              statusText: "",
              data: response,
              headers,
              config: null
            });
          } else {
            const chunks = [];
            response.on("data", (chunk) => {
              if (!response || !(chunk instanceof Buffer)) {
                return;
              }
              chunks.push(chunk);
            });
            response.on("end", () => {
              try {
                resolve({
                  status: 200,
                  statusText: "",
                  data: !params.responseType ? JSON.parse(Buffer.concat(chunks).toString("utf-8")) : params.responseType === "json" ? JSON.parse(Buffer.concat(chunks).toString("utf-8")) : Buffer.concat(chunks),
                  headers,
                  config: null
                });
              } catch (e) {
                reject(e);
              }
            });
            response.on("error", reject);
          }
        });
        request.on("error", reject);
        request.on("timeout", () => reject(new Error(`Request timed out after ${timeout}ms`)));
        request.on("socket", (socket) => {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        request.setTimeout(params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout, () => {
          request.destroy();
          reject(new Error(`Request timed out after ${params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout}ms`));
        });
        if (postDataIsBuffer) {
          const readableBuffer = params.data;
          const progressStreamInstance = (0, import_progress_stream.default)({
            length: readableBuffer.byteLength,
            time: 100
          });
          progressStreamInstance.on("progress", (info) => {
            var _a;
            if (!info || typeof info.transferred !== "number") {
              return;
            }
            let bytes = info.transferred;
            if (lastBytesUploaded === 0) {
              lastBytesUploaded = info.transferred;
            } else {
              bytes = Math.floor(info.transferred - lastBytesUploaded);
              lastBytesUploaded = info.transferred;
            }
            (_a = params.onUploadProgress) == null ? void 0 : _a.call(params, bytes, params.onUploadProgressId);
          });
          import_stream.Readable.from([readableBuffer]).pipe(progressStreamInstance).pipe(request);
        } else {
          request.write(JSON.stringify(params.data));
          request.end();
        }
      });
    }
    return await this.sdk.axiosInstance.post(url + params.endpoint, params.data, {
      headers,
      signal: params.abortSignal,
      timeout: params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout,
      responseType: params.responseType ? params.responseType : "json",
      maxRedirects: 0,
      maxBodyLength: Infinity,
      maxContentLength: Infinity,
      onUploadProgress: (event) => {
        var _a;
        if (!event || typeof event.loaded !== "number") {
          return;
        }
        let bytes = event.loaded;
        if (lastBytesUploaded === 0) {
          lastBytesUploaded = event.loaded;
        } else {
          bytes = Math.floor(event.loaded - lastBytesUploaded);
          lastBytesUploaded = event.loaded;
        }
        (_a = params.onUploadProgress) == null ? void 0 : _a.call(params, bytes, params.onUploadProgressId);
      }
    });
  }
  /**
   * Send a GET request.
   * @date 2/1/2024 - 2:49:04 AM
   *
   * @private
   * @async
   * @param {GetRequestParameters} params
   * @returns {Promise<AxiosResponse<any, any>>}
   */
  async get(params) {
    const headers = params.headers ? params.headers : this.buildHeaders({ apiKey: params.apiKey });
    if (params.apiKey && !headers["Authorization"]) {
      headers["Authorization"] = `Bearer ${params.apiKey}`;
    }
    const url = params.url ? params.url : APIClientDefaults.gatewayURLs[getRandomArbitrary(0, APIClientDefaults.gatewayURLs.length - 1)];
    if (!url) {
      throw new Error("No URL.");
    }
    if (url.includes("egest.") || url.includes("down.")) {
      delete headers["Authorization"];
    }
    let lastBytesDownloaded = 0;
    if (environment === "node") {
      return new Promise((resolve, reject) => {
        const urlParsed = import_url.default.parse(url, true);
        const timeout = params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout;
        const calculateProgress = (transferred) => {
          var _a;
          let bytes = transferred;
          if (lastBytesDownloaded === 0) {
            lastBytesDownloaded = transferred;
          } else {
            bytes = Math.floor(transferred - lastBytesDownloaded);
            lastBytesDownloaded = transferred;
          }
          (_a = params.onDownloadProgress) == null ? void 0 : _a.call(params, bytes, params.onDownloadProgressId);
        };
        const calculateProgressTransform = new import_stream.Transform({
          transform(chunk, _, callback) {
            if (params.onDownloadProgress && chunk instanceof Buffer) {
              params.onDownloadProgress(chunk.byteLength, params.onDownloadProgressId);
            }
            this.push(chunk);
            callback();
          }
        });
        const request = import_https.default.request({
          method: "GET",
          hostname: urlParsed.hostname,
          path: params.endpoint,
          port: 443,
          timeout,
          headers,
          agent: keepAliveAgent
        }, (response) => {
          var _a;
          if ((_a = params.abortSignal) == null ? void 0 : _a.aborted) {
            request.destroy();
            response.destroy();
            reject(new Error("Aborted"));
            return;
          }
          if (request.destroyed || response.destroyed) {
            reject(new Error("Aborted"));
            return;
          }
          if (response.statusCode !== 200) {
            resolve({
              status: response.statusCode ?? 500,
              statusText: "",
              data: null,
              headers,
              config: null
            });
            return;
          }
          if (params.responseType === "stream") {
            resolve({
              status: 200,
              statusText: "",
              data: response.pipe(calculateProgressTransform),
              headers,
              config: null
            });
          } else {
            const chunks = [];
            response.on("data", (chunk) => {
              if (!response || !(chunk instanceof Buffer)) {
                return;
              }
              chunks.push(chunk);
              calculateProgress(chunk.byteLength);
            });
            response.on("end", () => {
              try {
                resolve({
                  status: 200,
                  statusText: "",
                  data: !params.responseType ? JSON.parse(Buffer.concat(chunks).toString("utf-8")) : params.responseType === "json" ? JSON.parse(Buffer.concat(chunks).toString("utf-8")) : Buffer.concat(chunks),
                  headers,
                  config: null
                });
              } catch (e) {
                reject(e);
              }
            });
            response.on("error", reject);
          }
        });
        request.on("error", reject);
        request.on("timeout", () => reject(new Error(`Request timed out after ${timeout}ms`)));
        request.on("socket", (socket) => {
          socket.setKeepAlive(true, 1e3 * 60);
        });
        request.setTimeout(params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout, () => {
          request.destroy();
          reject(new Error(`Request timed out after ${params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout}ms`));
        });
        request.end();
      });
    }
    return await this.sdk.axiosInstance.get(url + params.endpoint, {
      headers,
      signal: params.abortSignal,
      timeout: params.timeout ? params.timeout : APIClientDefaults.gatewayTimeout,
      responseType: params.responseType ? params.responseType : "json",
      maxRedirects: 0,
      maxBodyLength: Infinity,
      maxContentLength: Infinity,
      onDownloadProgress: (event) => {
        var _a;
        if (!event || typeof event.loaded !== "number") {
          return;
        }
        let bytes = event.loaded;
        if (lastBytesDownloaded === 0) {
          lastBytesDownloaded = event.loaded;
        } else {
          bytes = Math.floor(event.loaded - lastBytesDownloaded);
          lastBytesDownloaded = event.loaded;
        }
        (_a = params.onDownloadProgress) == null ? void 0 : _a.call(params, bytes, params.onDownloadProgressId);
      }
    });
  }
  /**
   * Sends the request to the API.
   * @date 2/1/2024 - 2:49:20 AM
   *
   * @public
   * @async
   * @template T
   * @param {RequestParameters} params
   * @returns {Promise<T>}
   */
  async request(params) {
    const maxRetries = params.maxRetries ? params.maxRetries : APIClientDefaults.maxRetries;
    const retryTimeout = params.retryTimeout ? params.retryTimeout : APIClientDefaults.retryTimeout;
    let tries = 0;
    let lastError;
    let returnImmediately = false;
    const send = async () => {
      if (tries >= maxRetries) {
        if (lastError) {
          throw lastError;
        }
        throw new APIError({
          code: "request_failed_after_max_tries",
          message: `Request failed after ${maxRetries} tries`
        });
      }
      tries += 1;
      try {
        const response = params.method === "GET" ? await this.get(params) : await this.post(params);
        if (!response || response.status !== 200) {
          throw new APIError({
            code: "invalid_http_status_code",
            message: `Invalid HTTP status code: ${response.status}`
          });
        }
        if (typeof response.data === "object" && typeof response.data.status === "boolean" && !response.data.status) {
          returnImmediately = true;
          throw new APIError({
            code: response.data.code,
            message: response.data.message
          });
        }
        if (params.includeRaw) {
          const data = response.data && (response.data.data || typeof response.data.data === "number" || typeof response.data.data === "string") ? response.data.data : response.data;
          return {
            ...data,
            raw: JSON.stringify(data)
          };
        }
        return response.data && (response.data.data || typeof response.data.data === "number" || typeof response.data.data === "string") ? response.data.data : response.data;
      } catch (e) {
        if (returnImmediately) {
          throw e;
        }
        lastError = e;
        await sleep(retryTimeout);
        return await send();
      }
    };
    return await send();
  }
  /**
   * Downloads a file chunk to a local path.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunk: number
   * 		to: string
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		maxRetries?: number
   * 		retryTimeout?: number
   * 		onProgress?: ProgressCallback,
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunk
   * @param {string} param0.to
   * @param {number} param0.timeout
   * @param {AbortSignal} param0.abortSignal
   * @param {number} param0.maxRetries
   * @param {number} param0.retryTimeout
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<void>}
   */
  async downloadChunkToLocal({ uuid, bucket, region, chunk, to, timeout, abortSignal, maxRetries, retryTimeout, onProgress, onProgressId }) {
    if (environment !== "node") {
      throw new Error("cloud.downloadChunkToLocal is only available in a Node.JS environment");
    }
    to = normalizePath(to);
    const response = await this.request({
      method: "GET",
      url: `${APIClientDefaults.egestURLs[getRandomArbitrary(0, APIClientDefaults.egestURLs.length - 1)]}`,
      endpoint: `/${region}/${bucket}/${uuid}/${chunk}`,
      abortSignal,
      timeout: timeout ? timeout : APIClientDefaults.egestTimeout,
      responseType: "stream",
      maxRetries,
      retryTimeout,
      onDownloadProgress: onProgress,
      onDownloadProgressId: onProgressId
    });
    await pipelineAsync(response, import_fs_extra2.default.createWriteStream(to));
  }
  /**
   * Downloads a file chunk and returns a readable stream.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunk: number
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		maxRetries?: number
   * 		retryTimeout?: number
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunk
   * @param {number} param0.timeout
   * @param {AbortSignal} param0.abortSignal
   * @param {number} param0.maxRetries
   * @param {number} param0.retryTimeout
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<ReadableStream | fs.ReadStream>}
   */
  async downloadChunkToStream({ uuid, bucket, region, chunk, timeout, abortSignal, maxRetries, retryTimeout, onProgress, onProgressId }) {
    const response = await this.request({
      method: "GET",
      url: `${APIClientDefaults.egestURLs[getRandomArbitrary(0, APIClientDefaults.egestURLs.length - 1)]}`,
      endpoint: `/${region}/${bucket}/${uuid}/${chunk}`,
      abortSignal,
      timeout: timeout ? timeout : APIClientDefaults.egestTimeout,
      responseType: "stream",
      maxRetries,
      retryTimeout,
      onDownloadProgress: onProgress,
      onDownloadProgressId: onProgressId
    });
    return response;
  }
  /**
   * Download a chunk buffer.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunk: number
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		maxRetries?: number
   * 		retryTimeout?: number
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunk
   * @param {number} param0.timeout
   * @param {AbortSignal} param0.abortSignal
   * @param {number} param0.maxRetries
   * @param {number} param0.retryTimeout
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<Buffer>}
   */
  async downloadChunkToBuffer({ uuid, bucket, region, chunk, timeout, abortSignal, maxRetries, retryTimeout, onProgress, onProgressId }) {
    const response = await this.request({
      method: "GET",
      url: `${APIClientDefaults.egestURLs[getRandomArbitrary(0, APIClientDefaults.egestURLs.length - 1)]}`,
      endpoint: `/${region}/${bucket}/${uuid}/${chunk}`,
      abortSignal,
      timeout: timeout ? timeout : APIClientDefaults.egestTimeout,
      responseType: "arraybuffer",
      maxRetries,
      retryTimeout,
      onDownloadProgress: onProgress,
      onDownloadProgressId: onProgressId
    });
    return Buffer.from(response);
  }
  /**
   * Upload a chunk buffer.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		index: number
   * 		parent: string
   * 		uploadKey: string
   * 		buffer: Buffer
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		maxRetries?: number
   * 		retryTimeout?: number
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {number} param0.index
   * @param {string} param0.parent
   * @param {string} param0.uploadKey
   * @param {Buffer} param0.buffer
   * @param {AbortSignal} param0.abortSignal
   * @param {number} param0.maxRetries
   * @param {number} param0.timeout
   * @param {number} param0.retryTimeout
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<UploadChunkResponse>}
   */
  async uploadChunkBuffer({ uuid, index, parent, uploadKey, buffer, abortSignal, maxRetries, timeout, retryTimeout, onProgress, onProgressId }) {
    const urlParams = new URLSearchParams({
      uuid,
      index,
      parent,
      uploadKey
    }).toString();
    const bufferHash = await this.sdk.getWorker().crypto.utils.bufferToHash({
      buffer,
      algorithm: "sha512"
    });
    const fullURL = `${APIClientDefaults.ingestURLs[getRandomArbitrary(0, APIClientDefaults.ingestURLs.length - 1)]}/v3/upload?${urlParams}&hash=${bufferHash}`;
    const parsedURLParams = parseURLParams({ url: fullURL });
    const urlParamsHash = await this.sdk.getWorker().crypto.utils.bufferToHash({
      buffer: Buffer.from(JSON.stringify(parsedURLParams), "utf-8"),
      algorithm: "sha512"
    });
    const builtHeaders = this.buildHeaders({ apiKey: void 0 });
    const response = await this.request({
      method: "POST",
      url: `${APIClientDefaults.ingestURLs[getRandomArbitrary(0, APIClientDefaults.ingestURLs.length - 1)]}`,
      endpoint: `/v3/upload?${urlParams}&hash=${bufferHash}`,
      data: buffer,
      abortSignal,
      maxRetries,
      timeout: timeout ? timeout : APIClientDefaults.ingestTimeout,
      retryTimeout,
      headers: {
        ...builtHeaders,
        Checksum: urlParamsHash
      },
      onUploadProgress: onProgress,
      onUploadProgressId: onProgressId
    });
    return response;
  }
};
var client_default = APIClient;

// node_modules/@filen/sdk/dist/browser/api/v3/health/index.js
var Health = class {
  /**
   * Creates an instance of Health.
   * @date 2/1/2024 - 3:19:24 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Returns "OK" when API is healthy.
   * @date 2/1/2024 - 3:23:14 AM
   *
   * @public
   * @async
   * @returns {Promise<"OK">}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/health"
    });
    return response;
  }
};
var health_default = Health;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/content.js
var DirContent = class {
  /**
   * Creates an instance of DirContent.
   * @date 2/1/2024 - 3:19:31 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Returns all files and folders inside a folder.
   * Use "recents" as the UUID parameter to get the recently uploaded files.
   * @date 2/1/2024 - 4:42:23 PM
   *
   * @public
   * @async
   * @param {({ uuid: string | "recents"; dirsOnly?: boolean })} param0
   * @param {string} param0.uuid
   * @param {boolean} [param0.dirsOnly=false]
   * @returns {Promise<DirContentResponse>}
   */
  async fetch({ uuid, dirsOnly = false }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/content",
      data: {
        uuid,
        ...dirsOnly ? { foldersOnly: true } : {}
      }
    });
    return response;
  }
};
var content_default = DirContent;

// node_modules/@filen/sdk/dist/browser/api/v3/auth/info.js
var AuthInfo = class {
  /**
   * Creates an instance of AuthInfo.
   * @date 2/1/2024 - 3:19:19 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Returns authentication info.
   * @date 2/1/2024 - 3:23:14 AM
   *
   * @public
   * @async
   * @returns {Promise<AuthInfoResponse>}
   */
  async fetch({ email }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/auth/info",
      data: {
        email
      }
    });
    return response;
  }
};
var info_default = AuthInfo;

// node_modules/@filen/sdk/dist/browser/api/v3/login.js
var Login = class {
  /**
   * Creates an instance of Login.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Login. Send "XXXXXX" as the twoFactorCode when 2FA is disabled.
   * @date 2/1/2024 - 3:10:59 PM
   *
   * @public
   * @async
   * @param {{ email: string, password: string, twoFactorCode: string, authVersion: AuthVersion }} param0
   * @param {string} param0.email
   * @param {string} param0.password
   * @param {string} param0.twoFactorCode
   * @param {AuthVersion} param0.authVersion
   * @returns {Promise<LoginResponse>}
   */
  async fetch({ email, password, twoFactorCode = "XXXXXX", authVersion }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/login",
      data: {
        email,
        password,
        twoFactorCode,
        authVersion
      }
    });
    return response;
  }
};
var login_default = Login;

// node_modules/@filen/sdk/dist/browser/api/v3/user/info.js
var UserInfo = class {
  /**
   * Creates an instance of UserInfo.
   * @date 2/1/2024 - 3:19:01 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch user info.
   * @date 2/1/2024 - 3:19:04 PM
   *
   * @public
   * @async
   * @returns {Promise<UserInfoResponse>}
   */
  async fetch({ apiKey }) {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/user/info",
      apiKey
    });
    return response;
  }
};
var info_default2 = UserInfo;

// node_modules/@filen/sdk/dist/browser/api/v3/user/baseFolder.js
var UserBaseFolder = class {
  /**
   * Creates an instance of UserBaseFolder.
   * @date 2/1/2024 - 3:26:33 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch the user's base folder information.
   * @date 2/1/2024 - 3:26:36 PM
   *
   * @public
   * @async
   * @returns {Promise<UserBaseFolderResponse>}
   */
  async fetch({ apiKey }) {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/user/baseFolder",
      apiKey
    });
    return response;
  }
};
var baseFolder_default = UserBaseFolder;

// node_modules/@filen/sdk/dist/browser/api/v3/shared/in.js
var SharedIn = class {
  /**
   * Creates an instance of SharedIn.
   * @date 2/1/2024 - 4:04:08 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch files and folder shared to the user based on the parent UUID.
   * @date 2/1/2024 - 4:25:28 PM
   *
   * @public
   * @async
   * @param {?{ uuid?: string }} [params]
   * @returns {Promise<SharedInResponse>}
   */
  async fetch(params) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/shared/in",
      data: {
        uuid: params ? params.uuid : "shared-in"
      }
    });
    return response;
  }
};
var in_default = SharedIn;

// node_modules/@filen/sdk/dist/browser/api/v3/shared/out.js
var SharedOut = class {
  /**
   * Creates an instance of SharedOut.
   * @date 2/1/2024 - 4:20:03 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch shared files and folders based on the given UUID and receiverId.
   * @date 2/1/2024 - 4:26:07 PM
   *
   * @public
   * @async
   * @param {?{ uuid?: string; receiverId?: number }} [params]
   * @returns {Promise<SharedOutResponse>}
   */
  async fetch(params) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/shared/out",
      data: {
        uuid: params ? params.uuid : "shared-out",
        receiverId: params ? params.receiverId : 0
      }
    });
    return response;
  }
};
var out_default = SharedOut;

// node_modules/@filen/sdk/dist/browser/api/v3/upload/done.js
var UploadDone = class {
  /**
   * Creates an instance of UploadDone.
   * @date 2/1/2024 - 4:45:31 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Mark an upload as done.
   * @date 2/1/2024 - 4:45:36 PM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		name: string
   * 		nameHashed: string
   * 		size: string
   * 		chunks: number
   * 		mime: string
   * 		rm: string
   * 		metadata: string
   * 		version: FileEncryptionVersion
   * 		uploadKey: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.name
   * @param {string} param0.nameHashed
   * @param {string} param0.size
   * @param {number} param0.chunks
   * @param {string} param0.mime
   * @param {string} param0.rm
   * @param {string} param0.metadata
   * @param {FileEncryptionVersion} param0.version
   * @param {string} param0.uploadKey
   * @returns {Promise<UploadDoneResponse>}
   */
  async fetch({ uuid, name, nameHashed, size, chunks, mime, rm, metadata, version, uploadKey }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/upload/done",
      data: {
        uuid,
        name,
        nameHashed,
        size,
        chunks,
        mime,
        rm,
        metadata,
        version,
        uploadKey
      }
    });
    return response;
  }
};
var done_default = UploadDone;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/download.js
var DirDownload = class {
  /**
   * Creates an instance of DirDownload.
   * @date 2/1/2024 - 6:04:54 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Download directory contents recursively in one call. Supports normal, shared and linked directories.
   * @date 2/22/2024 - 1:45:11 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		type?: DirDownloadType
   * 		linkUUID?: string
   * 		linkHasPassword?: boolean
   * 		linkPassword?: string
   * 		linkSalt?: string
   * 		skipCache?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {DirDownloadType} [param0.type="normal"]
   * @param {string} param0.linkUUID
   * @param {boolean} param0.linkHasPassword
   * @param {string} param0.linkPassword
   * @param {string} param0.linkSalt
   * @param {boolean} param0.skipCache
   * @returns {Promise<DirDownloadResponse>}
   */
  async fetch({ uuid, type = "normal", linkUUID, linkHasPassword, linkPassword, linkSalt, skipCache }) {
    const endpoint = type === "shared" ? "/v3/dir/download/shared" : type === "linked" ? "/v3/dir/download/link" : "/v3/dir/download";
    const data = type === "shared" || type === "normal" ? {
      uuid,
      ...skipCache ? { skipCache } : {}
    } : {
      uuid: linkUUID,
      parent: uuid,
      password: linkHasPassword && linkSalt && linkPassword ? linkSalt.length === 32 ? await this.apiClient.sdk.getWorker().crypto.utils.deriveKeyFromPassword({
        password: linkPassword,
        salt: linkSalt,
        iterations: 2e5,
        hash: "sha512",
        bitLength: 512,
        returnHex: true
      }) : await this.apiClient.sdk.getWorker().crypto.utils.hashFn({ input: linkPassword.length === 0 ? "empty" : linkPassword }) : await this.apiClient.sdk.getWorker().crypto.utils.hashFn({ input: "empty" }),
      ...skipCache ? { skipCache } : {}
    };
    const response = await this.apiClient.request({
      method: "POST",
      endpoint,
      data
    });
    return response;
  }
};
var download_default = DirDownload;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/shared.js
var DirShared = class {
  /**
   * Creates an instance of DirShared.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Returns sharing information about a directory.
   * @date 2/1/2024 - 8:16:46 PM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 	}} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirSharedResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/shared",
      data: {
        uuid
      }
    });
    return response;
  }
};
var shared_default = DirShared;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/linked.js
var DirLinked = class {
  /**
   * Creates an instance of DirLinked.
   * @date 2/1/2024 - 8:21:11 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Returns public link information about a directory.
   * @date 2/1/2024 - 8:21:37 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirLinkedResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/linked",
      data: {
        uuid
      }
    });
    return response;
  }
};
var linked_default = DirLinked;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/link/add.js
var DirLinkAdd = class {
  /**
   * Creates an instance of DirLinkAdd.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Add an item to a public linked folder.
   * @date 2/9/2024 - 4:24:27 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		parent: string
   * 		linkUUID: string
   * 		type: string
   * 		metadata: string
   * 		key: string
   * 		expiration: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.parent
   * @param {string} param0.linkUUID
   * @param {string} param0.type
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @param {string} param0.expiration
   * @returns {Promise<void>}
   */
  async fetch({ uuid, parent, linkUUID, type, metadata, key, expiration }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/link/add",
      data: {
        uuid,
        parent,
        linkUUID,
        type,
        metadata,
        key,
        expiration
      }
    });
  }
};
var add_default = DirLinkAdd;

// node_modules/@filen/sdk/dist/browser/api/v3/item/share.js
var ItemShare = class {
  /**
   * Creates an instance of ItemShare.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Share an item.
   * @date 2/9/2024 - 4:27:13 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; parent: string; email: string; type: "file" | "folder"; metadata: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.parent
   * @param {string} param0.email
   * @param {"file" | "folder"} param0.type
   * @param {string} param0.metadata
   * @returns {Promise<void>}
   */
  async fetch({ uuid, parent, email, type, metadata }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/share",
      data: {
        uuid,
        parent,
        email,
        type,
        metadata
      }
    });
  }
};
var share_default = ItemShare;

// node_modules/@filen/sdk/dist/browser/api/v3/item/shared.js
var ItemShared = class {
  /**
   * Creates an instance of ItemShared.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get sharing information about an item.
   * @date 2/9/2024 - 4:30:58 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<ItemSharedResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/shared",
      data: {
        uuid
      }
    });
    return response;
  }
};
var shared_default2 = ItemShared;

// node_modules/@filen/sdk/dist/browser/api/v3/item/linked.js
var ItemLinked = class {
  /**
   * Creates an instance of ItemLinked.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get public link information about an item.
   * @date 2/9/2024 - 4:30:58 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<ItemLinkedResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/linked",
      data: {
        uuid
      }
    });
    return response;
  }
};
var linked_default2 = ItemLinked;

// node_modules/@filen/sdk/dist/browser/api/v3/item/linked/rename.js
var ItemLinkedRename = class {
  /**
   * Creates an instance of ItemLinkedRename.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Rename a public linked item
   * @date 2/9/2024 - 4:37:35 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; linkUUID: string; metadata: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.linkUUID
   * @param {string} param0.metadata
   * @returns {Promise<void>}
   */
  async fetch({ uuid, linkUUID, metadata }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/linked/rename",
      data: {
        uuid,
        linkUUID,
        metadata
      }
    });
  }
};
var rename_default = ItemLinkedRename;

// node_modules/@filen/sdk/dist/browser/api/v3/item/shared/rename.js
var ItemSharedRename = class {
  /**
   * Creates an instance of ItemSharedRename.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Rename a shared item.
   * @date 2/9/2024 - 4:39:59 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; receiverId: number; metadata: string }} param0
   * @param {string} param0.uuid
   * @param {number} param0.receiverId
   * @param {string} param0.metadata
   * @returns {Promise<void>}
   */
  async fetch({ uuid, receiverId, metadata }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/shared/rename",
      data: {
        uuid,
        receiverId,
        metadata
      }
    });
  }
};
var rename_default2 = ItemSharedRename;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/exists.js
var DirExists = class {
  /**
   * Creates an instance of DirExists.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Check if a directory already exists.
   * @date 2/9/2024 - 4:44:34 AM
   *
   * @public
   * @async
   * @param {{
   *         nameHashed: string
   *         parent: string
   *     }} param0
   * @param {string} param0.nameHashed
   * @param {string} param0.parent
   * @returns {Promise<DirExistsResponse>}
   */
  async fetch({ nameHashed, parent }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/exists",
      data: {
        parent,
        nameHashed
      }
    });
    return response;
  }
};
var exists_default = DirExists;

// node_modules/@filen/sdk/dist/browser/api/v3/file/exists.js
var FileExists = class {
  /**
   * Creates an instance of FileExists.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Check if a directory already exists.
   * @date 2/9/2024 - 4:44:34 AM
   *
   * @public
   * @async
   * @param {{
   *         nameHashed: string
   *         parent: string
   *     }} param0
   * @param {string} param0.nameHashed
   * @param {string} param0.parent
   * @returns {Promise<DirExistsResponse>}
   */
  async fetch({ nameHashed, parent }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/exists",
      data: {
        parent,
        nameHashed
      }
    });
    return response;
  }
};
var exists_default2 = FileExists;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/create.js
var DirCreate = class {
  /**
   * Creates an instance of DirCreate.
   * @date 2/14/2024 - 4:35:07 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient; }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Create a new folder.
   * @date 2/14/2024 - 4:35:02 AM
   *
   * @public
   * @async
   * @param {{ uuid?: string; metadataEncrypted: string; parent: string, nameHashed: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.metadataEncrypted
   * @param {string} param0.parent
   * @param {string} param0.nameHashed
   * @returns {Promise<DirCreateResponse>}
   */
  async fetch({ uuid, metadataEncrypted, parent, nameHashed }) {
    const uuidToUse = uuid ? uuid : await uuidv4();
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/create",
      data: {
        uuid: uuidToUse,
        name: metadataEncrypted,
        nameHashed,
        parent
      }
    });
    return response;
  }
};
var create_default = DirCreate;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/present.js
var DirPresent = class {
  /**
   * Creates an instance of DirPresent.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Check if a directory is present.
   * @date 2/9/2024 - 4:59:21 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirPresentResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/present",
      data: {
        uuid
      }
    });
    return response;
  }
};
var present_default = DirPresent;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/trash.js
var DirTrash = class {
  /**
   * Creates an instance of DirTrash.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Move a directory to the trash bin.
   * @date 2/9/2024 - 4:59:21 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirPresentResponse>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/trash",
      data: {
        uuid
      }
    });
  }
};
var trash_default = DirTrash;

// node_modules/@filen/sdk/dist/browser/api/v3/file/trash.js
var FileTrash = class {
  /**
   * Creates an instance of FileTrash.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Move a file to the trash bin.
   * @date 2/9/2024 - 4:59:21 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirPresentResponse>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/trash",
      data: {
        uuid
      }
    });
  }
};
var trash_default2 = FileTrash;

// node_modules/@filen/sdk/dist/browser/api/v3/file/move.js
var FileMove = class {
  /**
   * Creates an instance of FileMove.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Move a file.
   * @date 2/9/2024 - 5:06:42 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, to: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.to
   * @returns {Promise<void>}
   */
  async fetch({ uuid, to }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/move",
      data: {
        uuid,
        to
      }
    });
  }
};
var move_default = FileMove;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/move.js
var DirMove = class {
  /**
   * Creates an instance of DirMove.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Move a directory.
   * @date 2/9/2024 - 5:06:42 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, to: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.to
   * @returns {Promise<void>}
   */
  async fetch({ uuid, to }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/move",
      data: {
        uuid,
        to
      }
    });
  }
};
var move_default2 = DirMove;

// node_modules/@filen/sdk/dist/browser/api/v3/file/rename.js
var FileRename = class {
  /**
   * Creates an instance of FileRename.
   * @date 2/14/2024 - 4:40:52 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient; }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Rename a file.
   * @date 2/14/2024 - 4:40:39 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; metadataEncrypted: string; nameEncrypted: string, nameHashed: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.metadataEncrypted
   * @param {string} param0.nameEncrypted
   * @param {string} param0.nameHashed
   * @returns {Promise<void>}
   */
  async fetch({ uuid, metadataEncrypted, nameEncrypted, nameHashed }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/rename",
      data: {
        uuid,
        name: nameEncrypted,
        nameHashed,
        metadata: metadataEncrypted
      }
    });
  }
};
var rename_default3 = FileRename;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/rename.js
var DirRename = class {
  /**
   * Creates an instance of DirRename.
   * @date 2/14/2024 - 4:41:14 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Rename a directory.
   * @date 2/14/2024 - 4:41:08 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		metadataEncrypted: string
   * 		nameHashed: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.metadataEncrypted
   * @param {string} param0.nameHashed
   * @returns {Promise<void>}
   */
  async fetch({ uuid, metadataEncrypted, nameHashed }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/rename",
      data: {
        uuid,
        name: metadataEncrypted,
        nameHashed
      }
    });
  }
};
var rename_default4 = DirRename;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/size.js
var DirSize = class {
  /**
   * Creates an instance of DirSize.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get the size of a directory.
   * @date 2/9/2024 - 5:33:34 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; sharerId?: number, receiverId?: number, trash?: boolean }} param0
   * @param {string} param0.uuid
   * @param {number} [param0.sharerId= 0]
   * @param {number} [param0.receiverId= 0]
   * @param {boolean} [param0.trash=false]
   * @returns {Promise<DirSizeResponse>}
   */
  async fetch({ uuid, sharerId = 0, receiverId = 0, trash = false }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/size",
      data: {
        uuid,
        sharerId,
        receiverId,
        trash: trash ? 1 : 0
      }
    });
    return response;
  }
};
var size_default = DirSize;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/sizeLink.js
var DirSizeLink = class {
  /**
   * Creates an instance of DirSizeLink.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get the size of a directory inside a public link.
   * @date 2/9/2024 - 5:36:04 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; linkUUID: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.linkUUID
   * @returns {Promise<DirSizeLinkResponse>}
   */
  async fetch({ uuid, linkUUID }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/size/link",
      data: {
        uuid,
        linkUUID
      }
    });
    return response;
  }
};
var sizeLink_default = DirSizeLink;

// node_modules/@filen/sdk/dist/browser/api/v3/item/favorite.js
var ItemFavorite = class {
  /**
   * Creates an instance of ItemFavorite.
   * @date 2/9/2024 - 5:39:43 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle favorite status of an item.
   * @date 2/9/2024 - 5:39:46 AM
   *
   * @public
   * @async
   * @param {({ uuid: string; type: "file" | "folder"; favorite: boolean })} param0
   * @param {string} param0.uuid
   * @param {("file" | "folder")} param0.type
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async fetch({ uuid, type, favorite }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/favorite",
      data: {
        uuid,
        type,
        value: favorite ? 1 : 0
      }
    });
  }
};
var favorite_default = ItemFavorite;

// node_modules/@filen/sdk/dist/browser/api/v3/trash/empty.js
var TrashEmpty = class {
  /**
   * Creates an instance of TrashEmpty.
   * @date 2/9/2024 - 5:39:43 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Empty the trash bin.
   * @date 2/9/2024 - 5:41:49 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async fetch() {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/trash/empty",
      data: {}
    });
  }
};
var empty_default = TrashEmpty;

// node_modules/@filen/sdk/dist/browser/api/v3/file/delete/permanent.js
var FileDeletePermanent = class {
  /**
   * Creates an instance of FileDeletePermanent.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a file permanently.
   * @date 2/9/2024 - 7:13:10 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/delete/permanent",
      data: {
        uuid
      }
    });
  }
};
var permanent_default = FileDeletePermanent;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/delete/permanent.js
var DirDeletePermanent = class {
  /**
   * Creates an instance of DirDeletePermanent.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a directory permanently.
   * @date 2/9/2024 - 7:13:10 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/delete/permanent",
      data: {
        uuid
      }
    });
  }
};
var permanent_default2 = DirDeletePermanent;

// node_modules/@filen/sdk/dist/browser/api/v3/file/restore.js
var FileRestore = class {
  /**
   * Creates an instance of FileRestore.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Restore a file from the trash bin.
   * @date 2/9/2024 - 7:13:10 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/restore",
      data: {
        uuid
      }
    });
  }
};
var restore_default = FileRestore;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/restore.js
var DirRestore = class {
  /**
   * Creates an instance of DirRestore.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Restore a directory from the trash bin.
   * @date 2/9/2024 - 7:13:10 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/restore",
      data: {
        uuid
      }
    });
  }
};
var restore_default2 = DirRestore;

// node_modules/@filen/sdk/dist/browser/api/v3/file/version/restore.js
var FileVersionRestore = class {
  /**
   * Creates an instance of FileVersionRestore.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Restore an old file version.
   * @date 2/9/2024 - 7:19:29 PM
   *
   * @public
   * @async
   * @param {{ uuid: string; currentUUID: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.currentUUID
   * @returns {Promise<void>}
   */
  async fetch({ uuid, currentUUID }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/version/restore",
      data: {
        uuid,
        current: currentUUID
      }
    });
  }
};
var restore_default3 = FileVersionRestore;

// node_modules/@filen/sdk/dist/browser/api/v3/user/publicKey.js
var UserPublicKey = class {
  /**
   * Creates an instance of UserPublicKey.
   * @date 2/1/2024 - 3:19:01 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get a user's public key.
   * @date 2/9/2024 - 7:22:21 PM
   *
   * @public
   * @async
   * @param {{email:string}} param0
   * @param {string} param0.email
   * @returns {Promise<UserPublicKeyResponse>}
   */
  async fetch({ email }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/publicKey",
      data: {
        email
      }
    });
    return response;
  }
};
var publicKey_default = UserPublicKey;

// node_modules/@filen/sdk/dist/browser/api/v3/item/shared/out/remove.js
var ItemSharedOutRemove = class {
  /**
   * Creates an instance of ItemSharedOutRemove.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Remove an item that you are sharing.
   * @date 2/9/2024 - 7:48:27 PM
   *
   * @public
   * @async
   * @param {{ uuid: string; receiverId: number; }} param0
   * @param {string} param0.uuid
   * @param {number} param0.receiverId
   * @returns {Promise<void>}
   */
  async fetch({ uuid, receiverId }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/shared/out/remove",
      data: {
        uuid,
        receiverId
      }
    });
  }
};
var remove_default = ItemSharedOutRemove;

// node_modules/@filen/sdk/dist/browser/api/v3/item/shared/in/remove.js
var ItemSharedInRemove = class {
  /**
   * Creates an instance of ItemSharedInRemove.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Remove an item that has been shared with you.
   * @date 2/9/2024 - 7:49:19 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/item/shared/in/remove",
      data: {
        uuid
      }
    });
  }
};
var remove_default2 = ItemSharedInRemove;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/link/status.js
var DirLinkStatus = class {
  /**
   * Creates an instance of DirLinkStatus.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get public link status of a directory.
   * @date 2/10/2024 - 12:46:07 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirLinkStatusResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/link/status",
      data: {
        uuid
      }
    });
    return response;
  }
};
var status_default = DirLinkStatus;

// node_modules/@filen/sdk/dist/browser/api/v3/file/link/status.js
var FileLinkStatus = class {
  /**
   * Creates an instance of FileLinkStatus.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get public link status of a file.
   * @date 2/10/2024 - 12:46:07 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<FileLinkStatusResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/link/status",
      data: {
        uuid
      }
    });
    return response;
  }
};
var status_default2 = FileLinkStatus;

// node_modules/@filen/sdk/dist/browser/api/v3/file/link/edit.js
var FileLinkEdit = class {
  /**
   * Creates an instance of FileLinkEdit.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Enable/disable/edit a file's public link.
   * @date 2/19/2024 - 4:45:17 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		fileUUID: string
   * 		expiration: PublicLinkExpiration
   * 		password: string
   * 		passwordHashed: string
   * 		downloadBtn: boolean
   * 		type: "enable" | "disable"
   * 		salt: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.fileUUID
   * @param {PublicLinkExpiration} [param0.expiration="never"]
   * @param {string} param0.password
   * @param {boolean} [param0.downloadBtn=true]
   * @param {("enable" | "disable")} param0.type
   * @param {string} param0.passwordHashed
   * @param {string} param0.salt
   * @returns {Promise<void>}
   */
  async fetch({ uuid, fileUUID, expiration = "never", password, downloadBtn = true, type, passwordHashed, salt }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/link/edit",
      data: {
        uuid,
        fileUUID,
        expiration,
        password,
        passwordHashed,
        salt,
        downloadBtn,
        type
      }
    });
  }
};
var edit_default = FileLinkEdit;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/link/remove.js
var DirLinkRemove = class {
  /**
   * Creates an instance of DirLinkRemove.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Remove a directory public link.
   * @date 2/10/2024 - 1:10:50 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 	}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/link/remove",
      data: {
        uuid
      }
    });
  }
};
var remove_default3 = DirLinkRemove;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/link/edit.js
var DirLinkEdit = class {
  /**
   * Creates an instance of DirLinkEdit.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Edit a directory public link.
   * @date 2/19/2024 - 4:52:28 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		expiration: PublicLinkExpiration
   * 		password: string
   * 		downloadBtn: boolean
   * 		passwordHashed: string
   * 		salt: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {PublicLinkExpiration} [param0.expiration="never"]
   * @param {string} param0.password
   * @param {boolean} [param0.downloadBtn=true]
   * @param {string} param0.passwordHashed
   * @param {string} param0.salt
   * @returns {Promise<void>}
   */
  async fetch({ uuid, expiration = "never", password, downloadBtn = true, passwordHashed, salt }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/link/edit",
      data: {
        uuid,
        expiration,
        password,
        passwordHashed,
        salt,
        downloadBtn
      }
    });
  }
};
var edit_default2 = DirLinkEdit;

// node_modules/@filen/sdk/dist/browser/api/v3/file/versions.js
var FileVersions = class {
  /**
   * Creates an instance of FileVersions.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get all versions of a file.
   * @date 2/10/2024 - 1:17:28 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<FileVersionsResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/versions",
      data: {
        uuid
      }
    });
    return response;
  }
};
var versions_default = FileVersions;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/color.js
var DirColor = class {
  /**
   * Creates an instance of DirColor.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Change the display color of a directory.
   * @date 2/10/2024 - 1:21:30 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; color: DirColors }} param0
   * @param {string} param0.uuid
   * @param {DirColors} param0.color
   * @returns {Promise<void>}
   */
  async fetch({ uuid, color }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/color",
      data: {
        uuid,
        color
      }
    });
  }
};
var color_default = DirColor;

// node_modules/@filen/sdk/dist/browser/api/v3/user/settings.js
var UserSettings = class {
  /**
   * Creates an instance of UserSettings.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get the user's settings/info.
   * @date 2/10/2024 - 1:23:53 AM
   *
   * @public
   * @async
   * @returns {Promise<UserSettingsResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/user/settings"
    });
    return response;
  }
};
var settings_default = UserSettings;

// node_modules/@filen/sdk/dist/browser/api/v3/user/account.js
var UserAccount = class {
  /**
   * Creates an instance of UserAccount.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get the user's account information.
   * @date 2/10/2024 - 1:25:53 AM
   *
   * @public
   * @async
   * @returns {Promise<UserAccountResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/user/account"
    });
    return response;
  }
};
var account_default = UserAccount;

// node_modules/@filen/sdk/dist/browser/api/v3/user/gdpr.js
var UserGDPR = class {
  /**
   * Creates an instance of UserGDPR.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get the user's GDPR info.
   * @date 2/10/2024 - 1:23:53 AM
   *
   * @public
   * @async
   * @returns {Promise<UserGDPRResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/user/gdpr"
    });
    return response;
  }
};
var gdpr_default = UserGDPR;

// node_modules/@filen/sdk/dist/browser/api/v3/user/avatar.js
var UserAvatar = class {
  /**
   * Creates an instance of UserAvatar.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Upload an avatar.
   * @date 2/20/2024 - 6:45:34 AM
   *
   * @public
   * @async
   * @param {{ base64: string, hash: string }} param0
   * @param {string} param0.base64
   * @param {string} param0.hash
   * @returns {Promise<void>}
   */
  async fetch({ base64, hash }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/avatar",
      data: {
        avatar: base64,
        hash
      }
    });
  }
};
var avatar_default = UserAvatar;

// node_modules/@filen/sdk/dist/browser/api/v3/user/settings/email/change.js
var UserSettingsEmailChange = class {
  /**
   * Creates an instance of UserSettingsEmailChange.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Change the user's email. Requires derived hashed password.
   * @date 2/10/2024 - 1:40:31 AM
   *
   * @public
   * @async
   * @param {{ email: string, password: string, authVersion: AuthVersion }} param0
   * @param {string} param0.email
   * @param {string} param0.password
   * @param {AuthVersion} param0.authVersion
   * @returns {Promise<void>}
   */
  async fetch({ email, password, authVersion }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/settings/email/change",
      data: {
        email,
        password,
        authVersion
      }
    });
  }
};
var change_default = UserSettingsEmailChange;

// node_modules/@filen/sdk/dist/browser/api/v3/user/personal/update.js
var UserPersonalUpdate = class {
  /**
   * Creates an instance of UserPersonalUpdate.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Update personal information.
   * @date 2/20/2024 - 6:52:39 AM
   *
   * @public
   * @async
   * @param {{
   * 		city: string
   * 		companyName: string
   * 		country: string
   * 		firstName: string
   * 		lastName: string
   * 		postalCode: string
   * 		street: string
   * 		streetNumber: string
   * 		vatId: string
   * 	}} param0
   * @param {string} param0.city
   * @param {string} param0.companyName
   * @param {string} param0.country
   * @param {string} param0.firstName
   * @param {string} param0.lastName
   * @param {string} param0.postalCode
   * @param {string} param0.street
   * @param {string} param0.streetNumber
   * @param {string} param0.vatId
   * @returns {Promise<void>}
   */
  async fetch({ city, companyName, country, firstName, lastName, postalCode, street, streetNumber, vatId }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/personal/update",
      data: {
        city,
        companyName,
        country,
        firstName,
        lastName,
        postalCode,
        street,
        streetNumber,
        vatId
      }
    });
  }
};
var update_default = UserPersonalUpdate;

// node_modules/@filen/sdk/dist/browser/api/v3/user/delete.js
var UserDelete = class {
  /**
   * Creates an instance of UserDelete.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Request account deletion.
   * @date 2/10/2024 - 1:49:19 AM
   *
   * @public
   * @async
   * @param {{ twoFactorCode?: string }} param0
   * @param {string} [param0.twoFactorCode="XXXXXX"]
   * @returns {Promise<void>}
   */
  async fetch({ twoFactorCode = "XXXXXX" }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/delete",
      data: {
        twoFactorKey: twoFactorCode
      }
    });
  }
};
var delete_default = UserDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/user/delete/versions.js
var UserDeleteVersions = class {
  /**
   * Creates an instance of UserDeleteVersions.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete all file versions.
   * @date 2/10/2024 - 1:50:50 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async fetch() {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/delete/versions",
      data: {}
    });
  }
};
var versions_default2 = UserDeleteVersions;

// node_modules/@filen/sdk/dist/browser/api/v3/user/delete/all.js
var UserDeleteAll = class {
  /**
   * Creates an instance of UserDeleteAll.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete all files and directories.
   * @date 2/10/2024 - 1:50:50 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async fetch() {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/delete/all",
      data: {}
    });
  }
};
var all_default = UserDeleteAll;

// node_modules/@filen/sdk/dist/browser/api/v3/user/settings/password/change.js
var UserSettingsPasswordChange = class {
  /**
   * Creates an instance of UserSettingsPasswordChange.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Change password. Requires derived hashed current && new password. Master keys are in encrypted form.
   * @date 2/10/2024 - 1:56:33 AM
   *
   * @public
   * @async
   * @param {{
   *         password: string
   *         currentPassword: string
   *         authVersion: AuthVersion
   *         salt: string
   *         masterKeys: string
   *     }} param0
   * @param {string} param0.password
   * @param {string} param0.currentPassword
   * @param {AuthVersion} param0.authVersion
   * @param {string} param0.salt
   * @param {string} param0.masterKeys
   * @returns {Promise<UserSettingsPasswordChangeResponse>}
   */
  async fetch({ password, currentPassword, authVersion, salt, masterKeys }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/settings/password/change",
      data: {
        password,
        currentPassword,
        authVersion,
        salt,
        masterKeys
      }
    });
    return response;
  }
};
var change_default2 = UserSettingsPasswordChange;

// node_modules/@filen/sdk/dist/browser/api/v3/user/2fa/enable.js
var User2FAEnable = class {
  /**
   * Creates an instance of User2FAEnable.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Enable 2FA.
   * @date 2/10/2024 - 1:59:21 AM
   *
   * @public
   * @async
   * @param {{
   * 		code: string
   * 	}} param0
   * @param {string} param0.code
   * @returns {Promise<User2FAEnableResponse>}
   */
  async fetch({ code }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/2fa/enable",
      data: {
        code
      }
    });
    return response;
  }
};
var enable_default = User2FAEnable;

// node_modules/@filen/sdk/dist/browser/api/v3/user/2fa/disable.js
var User2FADisable = class {
  /**
   * Creates an instance of User2FADisable.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Disable 2FA.
   * @date 2/10/2024 - 1:59:21 AM
   *
   * @public
   * @async
   * @param {{
   * 		code: string
   * 	}} param0
   * @param {string} param0.code
   * @returns {Promise<void>}
   */
  async fetch({ code }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/2fa/disable",
      data: {
        code
      }
    });
  }
};
var disable_default = User2FADisable;

// node_modules/@filen/sdk/dist/browser/api/v3/user/events.js
var UserEvents = class {
  /**
   * Creates an instance of UserEvents.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get user account events.
   * @date 2/20/2024 - 7:09:44 AM
   *
   * @public
   * @async
   * @param {{
   * 		lastTimestamp: number
   * 		filter: string
   * 	}} param0
   * @param {number} param0.lastTimestamp
   * @param {string} param0.filter
   * @returns {Promise<UserEvent[]>}
   */
  async fetch({ lastTimestamp, filter }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/events",
      data: {
        filter,
        timestamp: lastTimestamp
      }
    });
    return response.events;
  }
};
var events_default = UserEvents;

// node_modules/@filen/sdk/dist/browser/api/v3/user/event.js
var UserEvent = class {
  /**
   * Creates an instance of UserEvent.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get event information.
   * @date 2/10/2024 - 2:09:37 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 	}} param0
   * @param {string} param0.uuid
   * @returns {Promise<UserEventResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/event",
      data: {
        uuid
      }
    });
    return response;
  }
};
var event_default = UserEvent;

// node_modules/@filen/sdk/dist/browser/api/v3/file/link/info.js
var FileLinkInfo = class {
  /**
   * Creates an instance of FileLinkInfo.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get file public link info.
   * @date 2/10/2024 - 2:13:05 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, password: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.password
   * @returns {Promise<FileLinkInfoResponse>}
   */
  async fetch({ uuid, password }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/link/info",
      data: {
        uuid,
        password
      }
    });
    return response;
  }
};
var info_default3 = FileLinkInfo;

// node_modules/@filen/sdk/dist/browser/api/v3/file/link/password.js
var FileLinkPassword = class {
  /**
   * Creates an instance of FileLinkPassword.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Check if a file public link is password protected.
   * @date 2/10/2024 - 2:15:06 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<FileLinkPasswordResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/link/password",
      data: {
        uuid
      }
    });
    return response;
  }
};
var password_default = FileLinkPassword;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/link/info.js
var DirLinkInfo = class {
  /**
   * Creates an instance of DirLinkInfo.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get public link info of a directory.
   * @date 2/10/2024 - 12:46:07 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirLinkInfoResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/link/info",
      data: {
        uuid
      }
    });
    return response;
  }
};
var info_default4 = DirLinkInfo;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/link/content.js
var DirLinkContent = class {
  /**
   * Creates an instance of DirLinkContent.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get contents of a directory public link.
   * @date 2/10/2024 - 2:20:01 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, password: string, parent: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.password
   * @param {string} param0.parent
   * @returns {Promise<DirLinkContentResponse>}
   */
  async fetch({ uuid, password, parent }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/link/content",
      data: {
        uuid,
        password,
        parent
      }
    });
    return response;
  }
};
var content_default2 = DirLinkContent;

// node_modules/@filen/sdk/dist/browser/api/v3/user/sub/cancel.js
var UserSubCancel = class {
  /**
   * Creates an instance of UserSubCancel.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Cancel a subscription.
   * @date 2/10/2024 - 2:21:56 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/sub/cancel",
      data: {
        uuid
      }
    });
  }
};
var cancel_default = UserSubCancel;

// node_modules/@filen/sdk/dist/browser/api/v3/user/invoice.js
var UserInvoice = class {
  /**
   * Creates an instance of UserInvoice.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Generate an invoice PDF (Base64 encoded).
   * @date 2/10/2024 - 2:24:05 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<string>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/invoice",
      data: {
        uuid
      }
    });
    return response;
  }
};
var invoice_default = UserInvoice;

// node_modules/@filen/sdk/dist/browser/api/v3/user/sub/create.js
var UserSubCreate = class {
  /**
   * Creates an instance of UserSubCreate.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Create a subscription payment flow.
   * @date 2/10/2024 - 2:26:46 AM
   *
   * @public
   * @async
   * @param {{ planId: number, method: PaymentMethods }} param0
   * @param {number} param0.planId
   * @param {PaymentMethods} param0.method
   * @returns {Promise<UserSubCreateResponse>}
   */
  async fetch({ planId, method }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/sub/create",
      data: {
        planId,
        method
      }
    });
    return response;
  }
};
var create_default2 = UserSubCreate;

// node_modules/@filen/sdk/dist/browser/api/v3/user/affiliate/payout.js
var UserAffiliatePayout = class {
  /**
   * Creates an instance of UserAffiliatePayout.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Request an affiliate payout.
   * @date 2/10/2024 - 2:28:58 AM
   *
   * @public
   * @async
   * @param {{ address: string; method: string }} param0
   * @param {string} param0.address
   * @param {string} param0.method
   * @returns {Promise<void>}
   */
  async fetch({ address, method }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/affiliate/payout",
      data: {
        method,
        address
      }
    });
  }
};
var payout_default = UserAffiliatePayout;

// node_modules/@filen/sdk/dist/browser/api/v3/user/versioning.js
var UserVersioning = class {
  /**
   * Creates an instance of UserVersioning.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle file versioning.
   * @date 2/10/2024 - 2:31:30 AM
   *
   * @public
   * @async
   * @param {{ enable: boolean }} param0
   * @param {boolean} param0.enable
   * @returns {Promise<void>}
   */
  async fetch({ enable }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/versioning",
      data: {
        enabled: enable ? 1 : 0
      }
    });
  }
};
var versioning_default = UserVersioning;

// node_modules/@filen/sdk/dist/browser/api/v3/user/loginAlerts.js
var UserLoginAlerts = class {
  /**
   * Creates an instance of UserLoginAlerts.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle login alerts.
   * @date 2/10/2024 - 2:31:30 AM
   *
   * @public
   * @async
   * @param {{ enable: boolean }} param0
   * @param {boolean} param0.enable
   * @returns {Promise<void>}
   */
  async fetch({ enable }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/loginAlerts",
      data: {
        enabled: enable ? 1 : 0
      }
    });
  }
};
var loginAlerts_default = UserLoginAlerts;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations.js
var ChatConversations = class {
  /**
   * Creates an instance of ChatConversations.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all chat conversations.
   * @date 2/13/2024 - 4:44:37 AM
   *
   * @public
   * @async
   * @returns {Promise<ChatConversation[]>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/chat/conversations"
    });
    return response;
  }
};
var conversations_default = ChatConversations;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/messages.js
var ChatMessages = class {
  /**
   * Creates an instance of ChatMessages.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch chat messages from the given timestamp ordered DESC. Can be used for pagination.
   * @date 2/20/2024 - 5:57:33 AM
   *
   * @public
   * @async
   * @param {{
   * 		conversation: string
   * 		timestamp: number
   * 	}} param0
   * @param {string} param0.conversation
   * @param {number} param0.timestamp
   * @returns {Promise<ChatMessage[]>}
   */
  async fetch({ conversation, timestamp }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/messages",
      data: {
        conversation,
        timestamp
      }
    });
    return response;
  }
};
var messages_default = ChatMessages;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/name/edit.js
var ChatConversationsNameEdit = class {
  /**
   * Creates an instance of ChatConversationsNameEdit.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Edit conversation name.
   * @date 2/13/2024 - 4:49:46 AM
   *
   * @public
   * @async
   * @param {{uuid: string, name: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.name
   * @returns {Promise<void>}
   */
  async fetch({ uuid, name }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/name/edit",
      data: {
        uuid,
        name
      }
    });
  }
};
var edit_default3 = ChatConversationsNameEdit;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/send.js
var ChatSend = class {
  /**
   * Creates an instance of ChatSend.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Send a chat message.
   * @date 2/13/2024 - 4:52:10 AM
   *
   * @public
   * @async
   * @param {{ conversation: string, uuid:string, message: string, replyTo: string }} param0
   * @param {string} param0.conversation
   * @param {string} param0.uuid
   * @param {string} param0.message
   * @param {string} param0.replyTo
   * @returns {Promise<void>}
   */
  async fetch({ conversation, uuid, message, replyTo }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/send",
      data: {
        conversation,
        uuid,
        message,
        replyTo
      }
    });
  }
};
var send_default = ChatSend;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/edit.js
var ChatEdit = class {
  /**
   * Creates an instance of ChatEdit.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Edit a chat message.
   * @date 2/13/2024 - 4:53:28 AM
   *
   * @public
   * @async
   * @param {{
   * 		conversation: string
   * 		uuid: string
   * 		message: string
   * 	}} param0
   * @param {string} param0.conversation
   * @param {string} param0.uuid
   * @param {string} param0.message
   * @returns {Promise<void>}
   */
  async fetch({ conversation, uuid, message }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/edit",
      data: {
        conversation,
        uuid,
        message
      }
    });
  }
};
var edit_default4 = ChatEdit;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/create.js
var ChatConversationsCreate = class {
  /**
   * Creates an instance of ChatConversationsCreate.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Create a chat conversation.
   *
   * @public
   * @async
   * @param {{ uuid: string; metadata: string, ownerMetadata: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.metadata
   * @param {string} param0.ownerMetadata
   * @returns {Promise<void>}
   */
  async fetch({ uuid, metadata, ownerMetadata }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/create",
      data: {
        uuid,
        metadata,
        ownerMetadata
      }
    });
  }
};
var create_default3 = ChatConversationsCreate;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/participants/add.js
var ChatConversationsParticipantsAdd = class {
  /**
   * Creates an instance of ChatConversationsParticipantsAdd.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Add a participant to a chat conversation.
   * @date 2/13/2024 - 4:56:51 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; contactUUID: string; metadata: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.contactUUID
   * @param {string} param0.metadata
   * @returns {Promise<void>}
   */
  async fetch({ uuid, contactUUID, metadata }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/participants/add",
      data: {
        uuid,
        contactUUID,
        metadata
      }
    });
  }
};
var add_default2 = ChatConversationsParticipantsAdd;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/typing.js
var ChatTyping = class {
  /**
   * Creates an instance of ChatTyping.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Send a typing event to a chat conversation.
   * @date 2/13/2024 - 4:59:42 AM
   *
   * @public
   * @async
   * @param {{
   * 		conversation: string
   * 		type: ChatTypingType
   * 	}} param0
   * @param {string} param0.conversation
   * @param {ChatTypingType} param0.type
   * @returns {Promise<void>}
   */
  async fetch({ conversation, type }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/typing",
      data: {
        conversation,
        type
      }
    });
  }
};
var typing_default = ChatTyping;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/read.js
var ChatConversationsRead = class {
  /**
   * Creates an instance of ChatConversationsRead.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Mark all messages in a chat conversation as read.
   * @date 2/13/2024 - 5:01:39 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/read",
      data: {
        uuid
      }
    });
  }
};
var read_default = ChatConversationsRead;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/unread.js
var ChatConversationsUnread = class {
  /**
   * Creates an instance of ChatConversationsUnread.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch unread messages count of a chat conversation.
   * @date 2/13/2024 - 5:01:39 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<ChatConversationsUnreadResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/unread",
      data: {
        uuid
      }
    });
    return response;
  }
};
var unread_default = ChatConversationsUnread;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/unread.js
var ChatUnread = class {
  /**
   * Creates an instance of ChatUnread.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch overall unread messages count.
   * @date 2/13/2024 - 5:05:26 AM
   *
   * @public
   * @async
   * @returns {Promise<ChatUnreadResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/chat/unread"
    });
    return response;
  }
};
var unread_default2 = ChatUnread;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/online.js
var ChatConversationsOnline = class {
  /**
   * Creates an instance of ChatConversationsOnline.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch online status info of all participants in a chat conversation.
   * @date 2/13/2024 - 5:17:03 AM
   *
   * @public
   * @async
   * @param {{ conversation: string }} param0
   * @param {string} param0.conversation
   * @returns {Promise<ChatConversationsOnlineResponse>}
   */
  async fetch({ conversation }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/online",
      data: {
        conversation
      }
    });
    return response;
  }
};
var online_default = ChatConversationsOnline;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/delete.js
var ChatDelete = class {
  /**
   * Creates an instance of ChatDelete.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a chat conversation.
   * @date 2/13/2024 - 5:19:07 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default2 = ChatDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/notes.js
var Notes = class {
  /**
   * Creates an instance of Notes.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all notes.
   * @date 2/13/2024 - 5:21:41 AM
   *
   * @public
   * @async
   * @returns {Promise<NotesResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/notes"
    });
    return response;
  }
};
var notes_default = Notes;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/content.js
var NotesContent = class {
  /**
   * Creates an instance of NotesContent.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch note content.
   * @date 2/13/2024 - 5:24:20 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<NotesContentResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/content",
      data: {
        uuid
      }
    });
    return response;
  }
};
var content_default3 = NotesContent;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/create.js
var NotesCreate = class {
  /**
   * Creates an instance of NotesCreate.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Create a note.
   * @date 2/13/2024 - 5:26:26 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, title: string, metadata: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.title
   * @param {string} param0.metadata
   * @returns {Promise<void>}
   */
  async fetch({ uuid, title, metadata }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/create",
      data: {
        uuid,
        title,
        metadata
      }
    });
  }
};
var create_default4 = NotesCreate;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/content/edit.js
var NotesContentEdit = class {
  /**
   * Creates an instance of NotesContentEdit.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Edit a note.
   * @date 2/13/2024 - 5:28:18 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; preview: string; content: string, type: NoteType }} param0
   * @param {string} param0.uuid
   * @param {string} param0.preview
   * @param {string} param0.content
   * @param {NoteType} param0.type
   * @returns {Promise<void>}
   */
  async fetch({ uuid, preview, content, type }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/content/edit",
      data: {
        uuid,
        preview,
        content,
        type
      }
    });
  }
};
var edit_default5 = NotesContentEdit;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/title/edit.js
var NoteTitleEdit = class {
  /**
   * Creates an instance of NoteTitleEdit.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Edit a note's title.
   * @date 2/13/2024 - 5:30:02 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		title: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.title
   * @returns {Promise<void>}
   */
  async fetch({ uuid, title }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/title/edit",
      data: {
        uuid,
        title
      }
    });
  }
};
var edit_default6 = NoteTitleEdit;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/delete.js
var NotesDelete = class {
  /**
   * Creates an instance of NotesDelete.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a note.
   * @date 2/13/2024 - 5:31:43 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default3 = NotesDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/trash.js
var NotesTrash = class {
  /**
   * Creates an instance of NotesTrash.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Trash a note.
   * @date 2/13/2024 - 5:31:43 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/trash",
      data: {
        uuid
      }
    });
  }
};
var trash_default3 = NotesTrash;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/archive.js
var NotesArchive = class {
  /**
   * Creates an instance of NotesArchive.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Archive a note.
   * @date 2/13/2024 - 5:31:43 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/archive",
      data: {
        uuid
      }
    });
  }
};
var archive_default = NotesArchive;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/restore.js
var NotesRestore = class {
  /**
   * Creates an instance of NotesRestore.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Restore a note.
   * @date 2/13/2024 - 5:31:43 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/restore",
      data: {
        uuid
      }
    });
  }
};
var restore_default4 = NotesRestore;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/type/change.js
var NotesTypeChange = class {
  /**
   * Creates an instance of NotesTypeChange.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Change a note's type.
   * @date 2/13/2024 - 5:39:10 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, type: NoteType, preview: string, content: string }} param0
   * @param {string} param0.uuid
   * @param {NoteType} param0.type
   * @param {string} param0.preview
   * @param {string} param0.content
   * @returns {Promise<void>}
   */
  async fetch({ uuid, type, preview, content }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/type/change",
      data: {
        uuid,
        type,
        preview,
        content
      }
    });
  }
};
var change_default3 = NotesTypeChange;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/pinned.js
var NotesPinned = class {
  /**
   * Creates an instance of NotesPinned.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle the pinned status of a note.
   * @date 2/13/2024 - 5:40:57 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, pinned: boolean }} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.pinned
   * @returns {Promise<void>}
   */
  async fetch({ uuid, pinned }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/pinned",
      data: {
        uuid,
        pinned
      }
    });
  }
};
var pinned_default = NotesPinned;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/favorite.js
var NotesFavorite = class {
  /**
   * Creates an instance of NotesFavorite.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle the favorite status of a note.
   * @date 2/13/2024 - 5:40:57 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, favorite: boolean }} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async fetch({ uuid, favorite }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/favorite",
      data: {
        uuid,
        favorite
      }
    });
  }
};
var favorite_default2 = NotesFavorite;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/history.js
var NotesHistory = class {
  /**
   * Creates an instance of NotesHistory.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch a note's history.
   * @date 2/13/2024 - 5:43:55 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<NotesHistoryResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/history",
      data: {
        uuid
      }
    });
    return response;
  }
};
var history_default = NotesHistory;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/history/restore.js
var NotesHistoryRestore = class {
  /**
   * Creates an instance of NotesHistoryRestore.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Restore a note from history.
   * @date 2/13/2024 - 5:45:45 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; id: number }} param0
   * @param {string} param0.uuid
   * @param {number} param0.id
   * @returns {Promise<void>}
   */
  async fetch({ uuid, id }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/history/restore",
      data: {
        uuid,
        id
      }
    });
  }
};
var restore_default5 = NotesHistoryRestore;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/participants/remove.js
var NotesParticipantsRemove = class {
  /**
   * Creates an instance of NotesParticipantsRemove.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Remove a participant from a note.
   * @date 2/13/2024 - 5:50:29 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; userId: number }} param0
   * @param {string} param0.uuid
   * @param {number} param0.userId
   * @returns {Promise<void>}
   */
  async fetch({ uuid, userId }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/participants/remove",
      data: {
        uuid,
        userId
      }
    });
  }
};
var remove_default4 = NotesParticipantsRemove;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/participants/permissions.js
var NotesParticipantsPermissions = class {
  /**
   * Creates an instance of NotesParticipantsPermissions.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Change permissions of a note participant.
   * @date 2/13/2024 - 5:52:06 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; userId: number, permissionsWrite: boolean }} param0
   * @param {string} param0.uuid
   * @param {number} param0.userId
   * @param {boolean} param0.permissionsWrite
   * @returns {Promise<void>}
   */
  async fetch({ uuid, userId, permissionsWrite }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/participants/permissions",
      data: {
        uuid,
        userId,
        permissionsWrite
      }
    });
  }
};
var permissions_default = NotesParticipantsPermissions;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts.js
var Contacts = class {
  /**
   * Creates an instance of Contacts.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all contacts.
   * @date 2/13/2024 - 5:54:05 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactsResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/contacts"
    });
    return response;
  }
};
var contacts_default = Contacts;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/in.js
var ContactsRequestsIn = class {
  /**
   * Creates an instance of ContactsRequestsIn.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all incoming contact requests.
   * @date 2/13/2024 - 5:56:16 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactsRequestsInResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/contacts/requests/in"
    });
    return response;
  }
};
var in_default2 = ContactsRequestsIn;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/in/count.js
var ContactsRequestsInCount = class {
  /**
   * Creates an instance of ContactsRequestsInCount.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch count of incoming contact requests.
   * @date 2/13/2024 - 5:58:45 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactsRequestsInCountResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/contacts/requests/in/count"
    });
    return response;
  }
};
var count_default = ContactsRequestsInCount;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/out.js
var ContactsRequestsOut = class {
  /**
   * Creates an instance of ContactsRequestsOut.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all outgoing contact requests.
   * @date 2/13/2024 - 6:00:33 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactsRequestsOutResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/contacts/requests/out"
    });
    return response;
  }
};
var out_default2 = ContactsRequestsOut;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/out/delete.js
var ContactsRequestsOutDelete = class {
  /**
   * Creates an instance of ContactsRequestsOutDelete.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete an outgoing contact request.
   * @date 2/13/2024 - 6:02:09 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/requests/out/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default4 = ContactsRequestsOutDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/send.js
var ContactsRequestsSend = class {
  /**
   * Creates an instance of ContactsRequestsSend.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Send a contact request.
   * @date 2/13/2024 - 6:03:33 AM
   *
   * @public
   * @async
   * @param {{ email: string }} param0
   * @param {string} param0.email
   * @returns {Promise<void>}
   */
  async fetch({ email }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/requests/send",
      data: {
        email
      }
    });
  }
};
var send_default2 = ContactsRequestsSend;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/accept.js
var ContactsRequestsAccept = class {
  /**
   * Creates an instance of ContactsRequestsAccept.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Accept a contact request.
   * @date 2/13/2024 - 6:04:55 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/requests/accept",
      data: {
        uuid
      }
    });
  }
};
var accept_default = ContactsRequestsAccept;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/requests/deny.js
var ContactsRequestsDeny = class {
  /**
   * Creates an instance of ContactsRequestsDeny.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Deny a contact request.
   * @date 2/13/2024 - 6:04:55 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/requests/deny",
      data: {
        uuid
      }
    });
  }
};
var deny_default = ContactsRequestsDeny;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/delete.js
var ContactsDelete = class {
  /**
   * Creates an instance of ContactsDelete.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a contact.
   * @date 2/13/2024 - 6:07:40 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default5 = ContactsDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/user/nickname.js
var UserNickname = class {
  /**
   * Creates an instance of UserNickname.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Change nickname.
   * @date 2/13/2024 - 6:09:23 AM
   *
   * @public
   * @async
   * @param {{ nickname: string }} param0
   * @param {string} param0.nickname
   * @returns {Promise<void>}
   */
  async fetch({ nickname }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/nickname",
      data: {
        nickname
      }
    });
  }
};
var nickname_default = UserNickname;

// node_modules/@filen/sdk/dist/browser/api/v3/user/appearOffline.js
var UserAppearOffline = class {
  /**
   * Creates an instance of UserAppearOffline.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle appear offline status.
   * @date 2/13/2024 - 6:10:56 AM
   *
   * @public
   * @async
   * @param {{ appearOffline: boolean }} param0
   * @param {boolean} param0.appearOffline
   * @returns {Promise<void>}
   */
  async fetch({ appearOffline }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/appearOffline",
      data: {
        appearOffline
      }
    });
  }
};
var appearOffline_default = UserAppearOffline;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/blocked.js
var ContactsBlocked = class {
  /**
   * Creates an instance of ContactsBlocked.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all blocked contacts.
   * @date 2/13/2024 - 5:56:16 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactsBlockedResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/contacts/blocked"
    });
    return response;
  }
};
var blocked_default = ContactsBlocked;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/blocked/add.js
var ContactsBlockedAdd = class {
  /**
   * Creates an instance of ContactsBlockedAdd.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Block a contact or a user.
   * @date 2/13/2024 - 6:14:38 AM
   *
   * @public
   * @async
   * @param {{ email: string }} param0
   * @param {string} param0.email
   * @returns {Promise<void>}
   */
  async fetch({ email }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/blocked/add",
      data: {
        email
      }
    });
  }
};
var add_default3 = ContactsBlockedAdd;

// node_modules/@filen/sdk/dist/browser/api/v3/contacts/blocked/delete.js
var ContactsBlockedDelete = class {
  /**
   * Creates an instance of ContactsBlockedDelete.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Unblock a contact.
   * @date 2/13/2024 - 6:16:03 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/contacts/blocked/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default6 = ContactsBlockedDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/tags.js
var NotesTags = class {
  /**
   * Creates an instance of NotesTags.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch all note tags.
   * @date 2/13/2024 - 6:18:25 AM
   *
   * @public
   * @async
   * @returns {Promise<NotesTagsResponse>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/notes/tags"
    });
    return response;
  }
};
var tags_default = NotesTags;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/tags/create.js
var NotesTagsCreate = class {
  /**
   * Creates an instance of NotesTagsCreate.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Create a note tag.
   * @date 2/13/2024 - 6:20:19 AM
   *
   * @public
   * @async
   * @param {{ name: string }} param0
   * @param {string} param0.name
   * @returns {Promise<NotesTagsCreateResponse>}
   */
  async fetch({ name }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/tags/create",
      data: {
        name
      }
    });
    return response;
  }
};
var create_default5 = NotesTagsCreate;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/tags/rename.js
var NotesTagsRename = class {
  /**
   * Creates an instance of NotesTagsRename.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Rename a note tag.
   * @date 2/13/2024 - 6:22:00 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, name: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.name
   * @returns {Promise<void>}
   */
  async fetch({ uuid, name }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/tags/rename",
      data: {
        uuid,
        name
      }
    });
  }
};
var rename_default5 = NotesTagsRename;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/tags/delete.js
var NotesTagsDelete = class {
  /**
   * Creates an instance of NotesTagsDelete.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a note tag.
   * @date 2/13/2024 - 6:23:19 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/tags/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default7 = NotesTagsDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/tags/favorite.js
var NotesTagsFavorite = class {
  /**
   * Creates an instance of NotesTagsFavorite.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Toggle the favorite status of a note tag.
   * @date 2/13/2024 - 6:24:56 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, favorite: boolean }} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async fetch({ uuid, favorite }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/tags/favorite",
      data: {
        uuid,
        favorite
      }
    });
  }
};
var favorite_default3 = NotesTagsFavorite;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/tag.js
var NotesTag = class {
  /**
   * Creates an instance of NotesTag.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Tag a note.
   * @date 2/13/2024 - 6:26:37 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; tag: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.tag
   * @returns {Promise<void>}
   */
  async fetch({ uuid, tag }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/tag",
      data: {
        uuid,
        tag
      }
    });
  }
};
var tag_default = NotesTag;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/untag.js
var NotesUntag = class {
  /**
   * Creates an instance of NotesUntag.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * UNtag a note.
   * @date 2/13/2024 - 6:26:37 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; tag: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.tag
   * @returns {Promise<void>}
   */
  async fetch({ uuid, tag }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/untag",
      data: {
        uuid,
        tag
      }
    });
  }
};
var untag_default = NotesUntag;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/message/embed/disable.js
var ChatMessageEmbedDisable = class {
  /**
   * Creates an instance of ChatMessageEmbedDisable.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Disable a chat embed from displaying.
   * @date 2/13/2024 - 6:29:00 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/message/embed/disable",
      data: {
        uuid
      }
    });
  }
};
var disable_default2 = ChatMessageEmbedDisable;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/participants/remove.js
var ChatConversationsParticipantsRemove = class {
  /**
   * Creates an instance of ChatConversationsParticipantsRemove.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Remove a participant from a chat conversation.
   * @date 2/13/2024 - 6:32:02 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; userId: number }} param0
   * @param {string} param0.uuid
   * @param {number} param0.userId
   * @returns {Promise<void>}
   */
  async fetch({ uuid, userId }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/participants/remove",
      data: {
        uuid,
        userId
      }
    });
  }
};
var remove_default5 = ChatConversationsParticipantsRemove;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/leave.js
var ChatConversationsLeave = class {
  /**
   * Creates an instance of ChatConversationsLeave.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Leave a chat conversation.
   * @date 2/13/2024 - 6:33:49 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/leave",
      data: {
        uuid
      }
    });
  }
};
var leave_default = ChatConversationsLeave;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/conversations/delete.js
var ChatConversationsDelete = class {
  /**
   * Creates an instance of ChatConversationsDelete.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Delete a chat conversation.
   * @date 2/13/2024 - 6:33:49 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async fetch({ uuid }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/conversations/delete",
      data: {
        uuid
      }
    });
  }
};
var delete_default8 = ChatConversationsDelete;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/lastFocusUpdate.js
var ChatLastFocusUpdate = class {
  /**
   * Creates an instance of ChatLastFocusUpdate.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Update last focus values.
   * @date 2/13/2024 - 6:37:14 AM
   *
   * @public
   * @async
   * @param {{ conversations: ChatLastFocusValues[] }} param0
   * @param {{}} param0.conversations
   * @returns {Promise<void>}
   */
  async fetch({ conversations }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/chat/lastFocus",
      data: {
        conversations
      }
    });
  }
};
var lastFocusUpdate_default = ChatLastFocusUpdate;

// node_modules/@filen/sdk/dist/browser/api/v3/chat/lastFocus.js
var ChatLastFocus = class {
  /**
   * Creates an instance of ChatLastFocus.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch chat last focus values.
   * @date 2/13/2024 - 6:40:39 AM
   *
   * @public
   * @async
   * @returns {Promise<ChatLastFocusValues[]>}
   */
  async fetch() {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/chat/lastFocus"
    });
    return response;
  }
};
var lastFocus_default = ChatLastFocus;

// node_modules/@filen/sdk/dist/browser/api/v3/user/profile.js
var UserProfile = class {
  /**
   * Creates an instance of UserProfile.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch a user's public profile.
   * @date 2/13/2024 - 6:42:31 AM
   *
   * @public
   * @async
   * @param {{ id: number }} param0
   * @param {number} param0.id
   * @returns {Promise<UserProfileResponse>}
   */
  async fetch({ id }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/profile",
      data: {
        id
      }
    });
    return response;
  }
};
var profile_default = UserProfile;

// node_modules/@filen/sdk/dist/browser/api/v3/user/lastActive/desktop.js
var UserLastActiveDesktop = class {
  /**
   * Creates an instance of UserLastActiveDesktop.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Update last active timestamp for the desktop platform.
   * @date 2/13/2024 - 6:44:14 AM
   *
   * @public
   * @async
   * @param {{ timestamp: number }} param0
   * @param {number} param0.timestamp
   * @returns {Promise<void>}
   */
  async fetch({ timestamp }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/lastActive/desktop",
      data: {
        timestamp
      }
    });
  }
};
var desktop_default = UserLastActiveDesktop;

// node_modules/@filen/sdk/dist/browser/api/v3/file/download/chunk/buffer.js
var FileDownloadChunkBuffer = class {
  /**
   * Creates an instance of FileDownloadChunkBuffer.
   * @date 2/15/2024 - 4:39:25 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Download a file chunk.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunk: number
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunk
   * @param {number} param0.timeout
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<Buffer>}
   */
  async fetch({ uuid, bucket, region, chunk, timeout, abortSignal, onProgress, onProgressId }) {
    return await this.apiClient.downloadChunkToBuffer({
      uuid,
      bucket,
      region,
      chunk,
      timeout,
      abortSignal,
      onProgress,
      onProgressId
    });
  }
};
var buffer_default = FileDownloadChunkBuffer;

// node_modules/@filen/sdk/dist/browser/api/v3/file/download/chunk/stream.js
var FileDownloadChunkStream = class {
  /**
   * Creates an instance of FileDownloadChunkStream.
   * @date 2/15/2024 - 4:39:25 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Download a file chunk.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunk: number
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunk
   * @param {number} param0.timeout
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<ReadableStream | fs.ReadStream>}
   */
  async fetch({ uuid, bucket, region, chunk, timeout, abortSignal, onProgress, onProgressId }) {
    return await this.apiClient.downloadChunkToStream({
      uuid,
      bucket,
      region,
      chunk,
      timeout,
      abortSignal,
      onProgress,
      onProgressId
    });
  }
};
var stream_default = FileDownloadChunkStream;

// node_modules/@filen/sdk/dist/browser/api/v3/file/download/chunk/local.js
var FileDownloadChunkLocal = class {
  /**
   * Creates an instance of FileDownloadChunkLocal.
   * @date 2/15/2024 - 4:39:25 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Download a file chunk.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunk: number
   * 		timeout?: number
   * 		abortSignal?: AbortSignal
   * 		to: string
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunk
   * @param {number} param0.timeout
   * @param {AbortSignal} param0.abortSignal
   * @param {string} param0.to
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<void>}
   */
  async fetch({ uuid, bucket, region, chunk, timeout, abortSignal, to, onProgress, onProgressId }) {
    await this.apiClient.downloadChunkToLocal({
      uuid,
      bucket,
      region,
      chunk,
      timeout,
      abortSignal,
      to,
      onProgress,
      onProgressId
    });
  }
};
var local_default = FileDownloadChunkLocal;

// node_modules/@filen/sdk/dist/browser/api/v3/file/upload/chunk/buffer.js
var FileUploadChunkBuffer = class {
  /**
   * Creates an instance of FileUploadChunkBuffer.
   * @date 2/15/2024 - 4:39:25 AM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Upload a file chunk buffer.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		index: number
   * 		parent: string
   * 		uploadKey: string
   * 		abortSignal?: AbortSignal
   * 		maxRetries?: number
   * 		retryTimeout?: number
   * 		timeout?: number
   * 		buffer: Buffer
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {number} param0.index
   * @param {string} param0.parent
   * @param {string} param0.uploadKey
   * @param {AbortSignal} param0.abortSignal
   * @param {number} param0.maxRetries
   * @param {number} param0.retryTimeout
   * @param {number} param0.timeout
   * @param {Buffer} param0.buffer
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<UploadChunkResponse>}
   */
  async fetch({ uuid, index, parent, uploadKey, abortSignal, maxRetries, retryTimeout, timeout, buffer, onProgress, onProgressId }) {
    return await this.apiClient.uploadChunkBuffer({
      uuid,
      index,
      parent,
      uploadKey,
      abortSignal,
      maxRetries,
      retryTimeout,
      timeout,
      buffer,
      onProgress,
      onProgressId
    });
  }
};
var buffer_default2 = FileUploadChunkBuffer;

// node_modules/@filen/sdk/dist/browser/api/v3/notes/participants/add.js
var NotesParticipantsAdd = class {
  /**
   * Creates an instance of NotesParticipantsAdd.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Add a participant to a note.
   * @date 2/19/2024 - 11:53:39 PM
   *
   * @public
   * @async
   * @param {{ uuid: string; contactUUID: string; metadata: string; permissionsWrite: boolean }} param0
   * @param {string} param0.uuid
   * @param {string} param0.contactUUID
   * @param {string} param0.metadata
   * @param {boolean} param0.permissionsWrite
   * @returns {Promise<void>}
   */
  async fetch({ uuid, contactUUID, metadata, permissionsWrite }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/notes/participants/add",
      data: {
        uuid,
        contactUUID,
        metadata,
        permissionsWrite
      }
    });
  }
};
var add_default4 = NotesParticipantsAdd;

// node_modules/@filen/sdk/dist/browser/api/v3/user/keyPair/update.js
var UserKeyPairUpdate = class {
  /**
   * Creates an instance of UserKeyPairUpdate.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Update keypair.
   * @date 2/20/2024 - 7:41:01 AM
   *
   * @public
   * @async
   * @param {{ publicKey: string, encryptedPrivateKey: string, apiKey?: string }} param0
   * @param {string} param0.publicKey
   * @param {string} param0.encryptedPrivateKey
   * @param {string} param0.apiKey
   * @returns {Promise<void>}
   */
  async fetch({ publicKey, encryptedPrivateKey, apiKey }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/keyPair/update",
      data: {
        publicKey,
        privateKey: encryptedPrivateKey
      },
      apiKey
    });
  }
};
var update_default2 = UserKeyPairUpdate;

// node_modules/@filen/sdk/dist/browser/api/v3/user/keyPair/set.js
var UserKeyPairSet = class {
  /**
   * Creates an instance of UserKeyPairSet.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Set keypair.
   * @date 2/20/2024 - 7:41:01 AM
   *
   * @public
   * @async
   * @param {{ publicKey: string, encryptedPrivateKey: string, apiKey?: string }} param0
   * @param {string} param0.publicKey
   * @param {string} param0.encryptedPrivateKey
   * @param {string} param0.apiKey
   * @returns {Promise<void>}
   */
  async fetch({ publicKey, encryptedPrivateKey, apiKey }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/keyPair/set",
      data: {
        publicKey,
        privateKey: encryptedPrivateKey
      },
      apiKey
    });
  }
};
var set_default = UserKeyPairSet;

// node_modules/@filen/sdk/dist/browser/api/v3/user/keyPair/info.js
var UserKeyPairInfo = class {
  /**
   * Creates an instance of UserKeyPairInfo.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get keypair info.
   * @date 2/20/2024 - 7:42:40 AM
   *
   * @public
   * @async
   * @param {{
   * 		apiKey?: string
   * 	}} param0
   * @param {string} [param0.apiKey=undefined]
   * @returns {Promise<UserKeyPairInfoResponse>}
   */
  async fetch({ apiKey = void 0 }) {
    const response = await this.apiClient.request({
      method: "GET",
      endpoint: "/v3/user/keyPair/info",
      apiKey
    });
    return response;
  }
};
var info_default5 = UserKeyPairInfo;

// node_modules/@filen/sdk/dist/browser/api/v3/user/masterKeys.js
var UserMasterKeys = class {
  /**
   * Creates an instance of UserMasterKeys.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Update master keys.
   * @date 2/20/2024 - 7:43:35 AM
   *
   * @public
   * @async
   * @param {{
   * 		encryptedMasterKeys: string
   * 		apiKey?: string
   * 	}} param0
   * @param {string} param0.encryptedMasterKeys
   * @param {string} param0.apiKey
   * @returns {Promise<UserMasterKeysResponse>}
   */
  async fetch({ encryptedMasterKeys, apiKey }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/masterKeys",
      data: {
        masterKeys: encryptedMasterKeys
      },
      apiKey
    });
    return response;
  }
};
var masterKeys_default = UserMasterKeys;

// node_modules/@filen/sdk/dist/browser/api/v3/register.js
var Register = class {
  /**
   * Creates an instance of Register.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Create an account.
   *
   * @public
   * @async
   * @param {{
   * 		email: string
   * 		password: string
   * 		salt: string
   * 		authVersion: AuthVersion,
   * 		refId?: string,
   * 		affId?: string
   * 	}} param0
   * @param {string} param0.email
   * @param {string} param0.password
   * @param {string} param0.salt
   * @param {AuthVersion} param0.authVersion
   * @param {string} param0.refId
   * @param {string} param0.affId
   * @returns {Promise<void>}
   */
  async fetch({ email, password, salt, authVersion, refId, affId }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/register",
      data: {
        email,
        password,
        salt,
        authVersion,
        refId,
        affId
      }
    });
  }
};
var register_default = Register;

// node_modules/@filen/sdk/dist/browser/api/v3/confirmationSend.js
var ConfirmationSend = class {
  /**
   * Creates an instance of ConfirmationSend.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Send a registration confirmation email.
   *
   * @public
   * @async
   * @param {{
   * 		email: string
   * 	}} param0
   * @param {string} param0.email
   * @returns {Promise<void>}
   */
  async fetch({ email }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/confirmation/send",
      data: {
        email
      }
    });
  }
};
var confirmationSend_default = ConfirmationSend;

// node_modules/@filen/sdk/dist/browser/api/v3/user/password/forgot.js
var UserPasswordForgot = class {
  /**
   * Creates an instance of UserPasswordForgot.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Send password reset instruction email.
   *
   * @public
   * @async
   * @param {{
   * 		email: string
   * 	}} param0
   * @param {string} param0.email
   * @returns {Promise<void>}
   */
  async fetch({ email }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/password/forgot",
      data: {
        email
      }
    });
  }
};
var forgot_default = UserPasswordForgot;

// node_modules/@filen/sdk/dist/browser/api/v3/user/password/forgotReset.js
var UserPasswordForgotReset = class {
  /**
   * Creates an instance of UserPasswordForgotReset.
   * @date 2/1/2024 - 3:19:15 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Reset password.
   *
   * @public
   * @async
   * @param {{
   * 		token: string
   * 		password: string
   * 		authVersion: number
   * 		salt: string
   * 		hasRecoveryKeys: boolean
   * 		newMasterKeys: string
   * 	}} param0
   * @param {string} param0.token
   * @param {string} param0.password
   * @param {number} param0.authVersion
   * @param {string} param0.salt
   * @param {boolean} param0.hasRecoveryKeys
   * @param {string} param0.newMasterKeys
   * @returns {Promise<void>}
   */
  async fetch({ token, password, authVersion, salt, hasRecoveryKeys, newMasterKeys }) {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/password/forgot/reset",
      data: {
        token,
        password,
        authVersion,
        salt,
        hasRecoveryKeys,
        newMasterKeys
      }
    });
  }
};
var forgotReset_default = UserPasswordForgotReset;

// node_modules/@filen/sdk/dist/browser/api/v3/user/didExportMasterKeys.js
var UserDidExportMasterKeys = class {
  /**
   * Creates an instance of UserDidExportMasterKeys.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Set current master keys as exported.
   * @date 2/10/2024 - 1:50:50 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async fetch() {
    await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/didExportMasterKeys",
      data: {}
    });
  }
};
var didExportMasterKeys_default = UserDidExportMasterKeys;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/tree.js
var DirTree = class {
  /**
   * Creates an instance of DirTree.
   * @date 2/1/2024 - 6:04:54 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Fetch the dir tree used for syncing.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		deviceId: string
   * 		skipCache?: boolean
   * 		includeRaw?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.deviceId
   * @param {boolean} [param0.skipCache=false]
   * @param {boolean} [param0.includeRaw=false]
   * @returns {Promise<DirTreeResponse>}
   */
  async fetch({ uuid, deviceId, skipCache = false, includeRaw = false }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir/tree",
      data: {
        uuid,
        deviceId,
        skipCache: skipCache ? 1 : 0
      },
      includeRaw
    });
    return response;
  }
};
var tree_default = DirTree;

// node_modules/@filen/sdk/dist/browser/api/v3/user/lock.js
var UserLock = class {
  /**
   * Creates an instance of UserLock.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Lock/unlock/refresh/status a resource.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		resource: string
   * 		type: "acquire" | "refresh" | "status" | "release"
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.resource
   * @param {("acquire" | "refresh" | "status" | "release")} param0.type
   * @returns {Promise<UserLockResponse>}
   */
  async fetch({ uuid, resource, type }) {
    return await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/user/lock",
      data: {
        uuid,
        type,
        resource
      }
    });
  }
};
var lock_default = UserLock;

// node_modules/@filen/sdk/dist/browser/api/v3/dir/get.js
var DirGet = class {
  /**
   * Creates an instance of DirGet.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get dir info.
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<DirGetResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/dir",
      data: {
        uuid
      }
    });
    return response;
  }
};
var get_default = DirGet;

// node_modules/@filen/sdk/dist/browser/api/v3/file/get.js
var FileGet = class {
  /**
   * Creates an instance of FileGet.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Get file info.
   *
   * @public
   * @async
   * @param {{ uuid: string; }} param0
   * @param {string} param0.uuid
   * @returns {Promise<FileGetResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file",
      data: {
        uuid
      }
    });
    return response;
  }
};
var get_default2 = FileGet;

// node_modules/@filen/sdk/dist/browser/api/v3/file/present.js
var FilePresent = class {
  /**
   * Creates an instance of FilePresent.
   * @date 2/1/2024 - 8:16:39 PM
   *
   * @constructor
   * @public
   * @param {{ apiClient: APIClient }} param0
   * @param {APIClient} param0.apiClient
   */
  constructor({ apiClient }) {
    __publicField(this, "apiClient");
    this.apiClient = apiClient;
  }
  /**
   * Check if a file is present.
   * @date 2/9/2024 - 4:59:21 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<FilePresentResponse>}
   */
  async fetch({ uuid }) {
    const response = await this.apiClient.request({
      method: "POST",
      endpoint: "/v3/file/present",
      data: {
        uuid
      }
    });
    return response;
  }
};
var present_default2 = FilePresent;

// node_modules/@filen/sdk/dist/browser/api/index.js
var API = class {
  /**
   * Creates an instance of API.
   * @date 2/1/2024 - 4:46:38 PM
   *
   * @constructor
   * @public
   * @param {APIConfig} params
   */
  constructor(params) {
    __publicField(this, "config");
    __publicField(this, "apiClient");
    __publicField(this, "_v3");
    this.config = params;
    if (this.config.apiKey.length === 0) {
      throw new Error("Invalid apiKey");
    }
    this.apiClient = new client_default({
      apiKey: this.config.apiKey,
      sdk: this.config.sdk
    });
    this._v3 = {
      health: new health_default({ apiClient: this.apiClient }),
      dir: {
        content: new content_default({ apiClient: this.apiClient }),
        download: new download_default({ apiClient: this.apiClient }),
        shared: new shared_default({ apiClient: this.apiClient }),
        linked: new linked_default({ apiClient: this.apiClient }),
        link: {
          add: new add_default({ apiClient: this.apiClient }),
          status: new status_default({ apiClient: this.apiClient }),
          remove: new remove_default3({ apiClient: this.apiClient }),
          edit: new edit_default2({ apiClient: this.apiClient }),
          info: new info_default4({ apiClient: this.apiClient }),
          content: new content_default2({ apiClient: this.apiClient })
        },
        exists: new exists_default({ apiClient: this.apiClient }),
        create: new create_default({ apiClient: this.apiClient }),
        present: new present_default({ apiClient: this.apiClient }),
        trash: new trash_default({ apiClient: this.apiClient }),
        move: new move_default2({ apiClient: this.apiClient }),
        rename: new rename_default4({ apiClient: this.apiClient }),
        size: new size_default({ apiClient: this.apiClient }),
        sizeLink: new sizeLink_default({ apiClient: this.apiClient }),
        delete: {
          permanent: new permanent_default2({ apiClient: this.apiClient })
        },
        restore: new restore_default2({ apiClient: this.apiClient }),
        color: new color_default({ apiClient: this.apiClient }),
        tree: new tree_default({ apiClient: this.apiClient }),
        get: new get_default({ apiClient: this.apiClient })
      },
      auth: {
        info: new info_default({ apiClient: this.apiClient })
      },
      login: new login_default({ apiClient: this.apiClient }),
      register: new register_default({ apiClient: this.apiClient }),
      confirmationSend: new confirmationSend_default({ apiClient: this.apiClient }),
      user: {
        info: new info_default2({ apiClient: this.apiClient }),
        baseFolder: new baseFolder_default({ apiClient: this.apiClient }),
        publicKey: new publicKey_default({ apiClient: this.apiClient }),
        settings: new settings_default({ apiClient: this.apiClient }),
        account: new account_default({ apiClient: this.apiClient }),
        gdpr: new gdpr_default({ apiClient: this.apiClient }),
        avatar: new avatar_default({ apiClient: this.apiClient }),
        settingsEmail: {
          change: new change_default({ apiClient: this.apiClient })
        },
        personal: {
          update: new update_default({ apiClient: this.apiClient })
        },
        delete: new delete_default({ apiClient: this.apiClient }),
        deleteVersions: new versions_default2({ apiClient: this.apiClient }),
        deleteAll: new all_default({ apiClient: this.apiClient }),
        settingsPassword: {
          change: new change_default2({ apiClient: this.apiClient })
        },
        twoFactorAuthentication: {
          enable: new enable_default({ apiClient: this.apiClient }),
          disable: new disable_default({ apiClient: this.apiClient })
        },
        events: new events_default({ apiClient: this.apiClient }),
        event: new event_default({ apiClient: this.apiClient }),
        sub: {
          cancel: new cancel_default({ apiClient: this.apiClient }),
          create: new create_default2({ apiClient: this.apiClient })
        },
        invoice: new invoice_default({ apiClient: this.apiClient }),
        affiliate: {
          payout: new payout_default({ apiClient: this.apiClient })
        },
        versioning: new versioning_default({ apiClient: this.apiClient }),
        loginAlerts: new loginAlerts_default({ apiClient: this.apiClient }),
        nickname: new nickname_default({ apiClient: this.apiClient }),
        appearOffline: new appearOffline_default({ apiClient: this.apiClient }),
        profile: new profile_default({ apiClient: this.apiClient }),
        lastActive: {
          desktop: new desktop_default({ apiClient: this.apiClient })
        },
        keyPair: {
          update: new update_default2({ apiClient: this.apiClient }),
          set: new set_default({ apiClient: this.apiClient }),
          info: new info_default5({ apiClient: this.apiClient })
        },
        masterKeys: new masterKeys_default({ apiClient: this.apiClient }),
        password: {
          forgot: new forgot_default({ apiClient: this.apiClient }),
          forgotReset: new forgotReset_default({ apiClient: this.apiClient })
        },
        didExportMasterKeys: new didExportMasterKeys_default({ apiClient: this.apiClient }),
        lock: new lock_default({ apiClient: this.apiClient })
      },
      shared: {
        in: new in_default({ apiClient: this.apiClient }),
        out: new out_default({ apiClient: this.apiClient })
      },
      upload: {
        done: new done_default({ apiClient: this.apiClient })
      },
      item: {
        share: new share_default({ apiClient: this.apiClient }),
        shared: new shared_default2({ apiClient: this.apiClient }),
        linked: new linked_default2({ apiClient: this.apiClient }),
        linkedRename: new rename_default({ apiClient: this.apiClient }),
        sharedRename: new rename_default2({ apiClient: this.apiClient }),
        favorite: new favorite_default({ apiClient: this.apiClient }),
        sharedOut: {
          remove: new remove_default({ apiClient: this.apiClient })
        },
        sharedIn: {
          remove: new remove_default2({ apiClient: this.apiClient })
        }
      },
      file: {
        exists: new exists_default2({ apiClient: this.apiClient }),
        trash: new trash_default2({ apiClient: this.apiClient }),
        move: new move_default({ apiClient: this.apiClient }),
        rename: new rename_default3({ apiClient: this.apiClient }),
        delete: {
          permanent: new permanent_default({ apiClient: this.apiClient })
        },
        restore: new restore_default({ apiClient: this.apiClient }),
        version: {
          restore: new restore_default3({ apiClient: this.apiClient })
        },
        link: {
          status: new status_default2({ apiClient: this.apiClient }),
          edit: new edit_default({ apiClient: this.apiClient }),
          info: new info_default3({ apiClient: this.apiClient }),
          password: new password_default({ apiClient: this.apiClient })
        },
        versions: new versions_default({ apiClient: this.apiClient }),
        download: {
          chunk: {
            buffer: new buffer_default({ apiClient: this.apiClient }),
            stream: new stream_default({ apiClient: this.apiClient }),
            local: new local_default({ apiClient: this.apiClient })
          }
        },
        upload: {
          chunk: {
            buffer: new buffer_default2({ apiClient: this.apiClient })
          }
        },
        get: new get_default2({ apiClient: this.apiClient }),
        present: new present_default2({ apiClient: this.apiClient })
      },
      trash: {
        empty: new empty_default({ apiClient: this.apiClient })
      },
      chat: {
        conversations: new conversations_default({ apiClient: this.apiClient }),
        messages: new messages_default({ apiClient: this.apiClient }),
        conversationsName: {
          edit: new edit_default3({ apiClient: this.apiClient })
        },
        send: new send_default({ apiClient: this.apiClient }),
        edit: new edit_default4({ apiClient: this.apiClient }),
        conversationsCreate: new create_default3({ apiClient: this.apiClient }),
        conversationsParticipants: {
          add: new add_default2({ apiClient: this.apiClient }),
          remove: new remove_default5({ apiClient: this.apiClient })
        },
        typing: new typing_default({ apiClient: this.apiClient }),
        conversationsRead: new read_default({ apiClient: this.apiClient }),
        conversationsUnread: new unread_default({ apiClient: this.apiClient }),
        unread: new unread_default2({ apiClient: this.apiClient }),
        conversationsOnline: new online_default({ apiClient: this.apiClient }),
        delete: new delete_default2({ apiClient: this.apiClient }),
        message: {
          embed: {
            disable: new disable_default2({ apiClient: this.apiClient })
          }
        },
        conversationsLeave: new leave_default({ apiClient: this.apiClient }),
        conversationsDelete: new delete_default8({ apiClient: this.apiClient }),
        lastFocusUpdate: new lastFocusUpdate_default({ apiClient: this.apiClient }),
        lastFocus: new lastFocus_default({ apiClient: this.apiClient })
      },
      notes: {
        all: new notes_default({ apiClient: this.apiClient }),
        content: new content_default3({ apiClient: this.apiClient }),
        create: new create_default4({ apiClient: this.apiClient }),
        contentEdit: new edit_default5({ apiClient: this.apiClient }),
        titleEdit: new edit_default6({ apiClient: this.apiClient }),
        delete: new delete_default3({ apiClient: this.apiClient }),
        trash: new trash_default3({ apiClient: this.apiClient }),
        archive: new archive_default({ apiClient: this.apiClient }),
        restore: new restore_default4({ apiClient: this.apiClient }),
        typeChange: new change_default3({ apiClient: this.apiClient }),
        pinned: new pinned_default({ apiClient: this.apiClient }),
        favorite: new favorite_default2({ apiClient: this.apiClient }),
        history: new history_default({ apiClient: this.apiClient }),
        historyRestore: new restore_default5({ apiClient: this.apiClient }),
        participantsRemove: new remove_default4({ apiClient: this.apiClient }),
        participantsPermissions: new permissions_default({ apiClient: this.apiClient }),
        participantsAdd: new add_default4({ apiClient: this.apiClient }),
        tags: new tags_default({ apiClient: this.apiClient }),
        tagsCreate: new create_default5({ apiClient: this.apiClient }),
        tagsRename: new rename_default5({ apiClient: this.apiClient }),
        tagsDelete: new delete_default7({ apiClient: this.apiClient }),
        tagsFavorite: new favorite_default3({ apiClient: this.apiClient }),
        tag: new tag_default({ apiClient: this.apiClient }),
        untag: new untag_default({ apiClient: this.apiClient })
      },
      contacts: {
        all: new contacts_default({ apiClient: this.apiClient }),
        requestsIn: new in_default2({ apiClient: this.apiClient }),
        requestsInCount: new count_default({ apiClient: this.apiClient }),
        requestsOut: new out_default2({ apiClient: this.apiClient }),
        requestsOutDelete: new delete_default4({ apiClient: this.apiClient }),
        requestsSend: new send_default2({ apiClient: this.apiClient }),
        requestsAccept: new accept_default({ apiClient: this.apiClient }),
        requestsDeny: new deny_default({ apiClient: this.apiClient }),
        delete: new delete_default5({ apiClient: this.apiClient }),
        blocked: new blocked_default({ apiClient: this.apiClient }),
        blockedAdd: new add_default3({ apiClient: this.apiClient }),
        blockedDelete: new delete_default6({ apiClient: this.apiClient })
      }
    };
  }
  v3() {
    return {
      health: () => this._v3.health.fetch(),
      dir: () => {
        return {
          content: (...params) => this._v3.dir.content.fetch(...params),
          download: (...params) => this._v3.dir.download.fetch(...params),
          shared: (...params) => this._v3.dir.shared.fetch(...params),
          linked: (...params) => this._v3.dir.linked.fetch(...params),
          link: () => {
            return {
              add: (...params) => this._v3.dir.link.add.fetch(...params),
              status: (...params) => this._v3.dir.link.status.fetch(...params),
              remove: (...params) => this._v3.dir.link.remove.fetch(...params),
              edit: (...params) => this._v3.dir.link.edit.fetch(...params),
              info: (...params) => this._v3.dir.link.info.fetch(...params),
              content: (...params) => this._v3.dir.link.content.fetch(...params)
            };
          },
          exists: (...params) => this._v3.dir.exists.fetch(...params),
          create: (...params) => this._v3.dir.create.fetch(...params),
          present: (...params) => this._v3.dir.present.fetch(...params),
          trash: (...params) => this._v3.dir.trash.fetch(...params),
          move: (...params) => this._v3.dir.move.fetch(...params),
          rename: (...params) => this._v3.dir.rename.fetch(...params),
          size: (...params) => this._v3.dir.size.fetch(...params),
          sizeLink: (...params) => this._v3.dir.sizeLink.fetch(...params),
          delete: () => {
            return {
              permanent: (...params) => this._v3.dir.delete.permanent.fetch(...params)
            };
          },
          restore: (...params) => this._v3.dir.restore.fetch(...params),
          color: (...params) => this._v3.dir.color.fetch(...params),
          tree: (...params) => this._v3.dir.tree.fetch(...params),
          get: (...params) => this._v3.dir.get.fetch(...params)
        };
      },
      auth: () => {
        return {
          info: (...params) => this._v3.auth.info.fetch(...params)
        };
      },
      login: (...params) => this._v3.login.fetch(...params),
      register: (...params) => this._v3.register.fetch(...params),
      confirmationSend: (...params) => this._v3.confirmationSend.fetch(...params),
      user: () => {
        return {
          info: (...params) => this._v3.user.info.fetch(...params),
          baseFolder: (...params) => this._v3.user.baseFolder.fetch(...params),
          publicKey: (...params) => this._v3.user.publicKey.fetch(...params),
          settings: (...params) => this._v3.user.settings.fetch(...params),
          account: (...params) => this._v3.user.account.fetch(...params),
          gdpr: (...params) => this._v3.user.gdpr.fetch(...params),
          avatar: (...params) => this._v3.user.avatar.fetch(...params),
          settingsEmail: () => {
            return {
              change: (...params) => this._v3.user.settingsEmail.change.fetch(...params)
            };
          },
          personal: () => {
            return {
              change: (...params) => this._v3.user.personal.update.fetch(...params)
            };
          },
          delete: (...params) => this._v3.user.delete.fetch(...params),
          deleteVersions: (...params) => this._v3.user.deleteVersions.fetch(...params),
          deleteAll: (...params) => this._v3.user.deleteAll.fetch(...params),
          settingsPassword: () => {
            return {
              change: (...params) => this._v3.user.settingsPassword.change.fetch(...params)
            };
          },
          twoFactorAuthentication: () => {
            return {
              enable: (...params) => this._v3.user.twoFactorAuthentication.enable.fetch(...params),
              disable: (...params) => this._v3.user.twoFactorAuthentication.disable.fetch(...params)
            };
          },
          events: (...params) => this._v3.user.events.fetch(...params),
          event: (...params) => this._v3.user.event.fetch(...params),
          sub: () => {
            return {
              cancel: (...params) => this._v3.user.sub.cancel.fetch(...params),
              create: (...params) => this._v3.user.sub.create.fetch(...params)
            };
          },
          invoice: (...params) => this._v3.user.invoice.fetch(...params),
          affiliate: () => {
            return {
              payout: (...params) => this._v3.user.affiliate.payout.fetch(...params)
            };
          },
          versioning: (...params) => this._v3.user.versioning.fetch(...params),
          loginAlerts: (...params) => this._v3.user.loginAlerts.fetch(...params),
          nickname: (...params) => this._v3.user.nickname.fetch(...params),
          appearOffline: (...params) => this._v3.user.appearOffline.fetch(...params),
          profile: (...params) => this._v3.user.profile.fetch(...params),
          lastActive: () => {
            return {
              desktop: (...params) => this._v3.user.lastActive.desktop.fetch(...params)
            };
          },
          keyPair: () => {
            return {
              update: (...params) => this._v3.user.keyPair.update.fetch(...params),
              set: (...params) => this._v3.user.keyPair.set.fetch(...params),
              info: (...params) => this._v3.user.keyPair.info.fetch(...params)
            };
          },
          masterKeys: (...params) => this._v3.user.masterKeys.fetch(...params),
          password: () => {
            return {
              forgot: (...params) => this._v3.user.password.forgot.fetch(...params),
              forgotReset: (...params) => this._v3.user.password.forgotReset.fetch(...params)
            };
          },
          didExportMasterKeys: (...params) => this._v3.user.didExportMasterKeys.fetch(...params),
          lock: (...params) => this._v3.user.lock.fetch(...params)
        };
      },
      shared: () => {
        return {
          in: (...params) => this._v3.shared.in.fetch(...params),
          out: (...params) => this._v3.shared.out.fetch(...params)
        };
      },
      upload: () => {
        return {
          done: (...params) => this._v3.upload.done.fetch(...params)
        };
      },
      item: () => {
        return {
          share: (...params) => this._v3.item.share.fetch(...params),
          shared: (...params) => this._v3.item.shared.fetch(...params),
          linked: (...params) => this._v3.item.linked.fetch(...params),
          linkedRename: (...params) => this._v3.item.linkedRename.fetch(...params),
          sharedRename: (...params) => this._v3.item.sharedRename.fetch(...params),
          favorite: (...params) => this._v3.item.favorite.fetch(...params),
          sharedOut: () => {
            return {
              remove: (...params) => this._v3.item.sharedOut.remove.fetch(...params)
            };
          },
          sharedIn: () => {
            return {
              remove: (...params) => this._v3.item.sharedIn.remove.fetch(...params)
            };
          }
        };
      },
      file: () => {
        return {
          exists: (...params) => this._v3.file.exists.fetch(...params),
          trash: (...params) => this._v3.file.trash.fetch(...params),
          move: (...params) => this._v3.file.move.fetch(...params),
          rename: (...params) => this._v3.file.rename.fetch(...params),
          delete: () => {
            return {
              permanent: (...params) => this._v3.file.delete.permanent.fetch(...params)
            };
          },
          restore: (...params) => this._v3.file.restore.fetch(...params),
          version: () => {
            return {
              restore: (...params) => this._v3.file.version.restore.fetch(...params)
            };
          },
          link: () => {
            return {
              status: (...params) => this._v3.file.link.status.fetch(...params),
              edit: (...params) => this._v3.file.link.edit.fetch(...params),
              info: (...params) => this._v3.file.link.info.fetch(...params),
              password: (...params) => this._v3.file.link.password.fetch(...params)
            };
          },
          versions: (...params) => this._v3.file.versions.fetch(...params),
          download: () => {
            return {
              chunk: () => {
                return {
                  buffer: (...params) => this._v3.file.download.chunk.buffer.fetch(...params),
                  stream: (...params) => this._v3.file.download.chunk.stream.fetch(...params),
                  local: (...params) => this._v3.file.download.chunk.local.fetch(...params)
                };
              }
            };
          },
          upload: () => {
            return {
              chunk: () => {
                return {
                  buffer: (...params) => this._v3.file.upload.chunk.buffer.fetch(...params)
                };
              }
            };
          },
          get: (...params) => this._v3.file.get.fetch(...params),
          present: (...params) => this._v3.file.present.fetch(...params)
        };
      },
      trash: () => {
        return {
          empty: (...params) => this._v3.trash.empty.fetch(...params)
        };
      },
      chat: () => {
        return {
          conversations: (...params) => this._v3.chat.conversations.fetch(...params),
          messages: (...params) => this._v3.chat.messages.fetch(...params),
          conversationsName: () => {
            return {
              edit: (...params) => this._v3.chat.conversationsName.edit.fetch(...params)
            };
          },
          send: (...params) => this._v3.chat.send.fetch(...params),
          edit: (...params) => this._v3.chat.edit.fetch(...params),
          conversationsCreate: (...params) => this._v3.chat.conversationsCreate.fetch(...params),
          conversationsParticipants: () => {
            return {
              add: (...params) => this._v3.chat.conversationsParticipants.add.fetch(...params),
              remove: (...params) => this._v3.chat.conversationsParticipants.remove.fetch(...params)
            };
          },
          typing: (...params) => this._v3.chat.typing.fetch(...params),
          conversationsRead: (...params) => this._v3.chat.conversationsRead.fetch(...params),
          conversationsUnread: (...params) => this._v3.chat.conversationsUnread.fetch(...params),
          unread: (...params) => this._v3.chat.unread.fetch(...params),
          conversationsOnline: (...params) => this._v3.chat.conversationsOnline.fetch(...params),
          delete: (...params) => this._v3.chat.delete.fetch(...params),
          message: () => {
            return {
              embed: () => {
                return {
                  disable: (...params) => this._v3.chat.message.embed.disable.fetch(...params)
                };
              }
            };
          },
          conversationsLeave: (...params) => this._v3.chat.conversationsLeave.fetch(...params),
          conversationsDelete: (...params) => this._v3.chat.conversationsDelete.fetch(...params),
          lastFocusUpdate: (...params) => this._v3.chat.lastFocusUpdate.fetch(...params),
          lastFocus: (...params) => this._v3.chat.lastFocus.fetch(...params)
        };
      },
      notes: () => {
        return {
          all: (...params) => this._v3.notes.all.fetch(...params),
          content: (...params) => this._v3.notes.content.fetch(...params),
          create: (...params) => this._v3.notes.create.fetch(...params),
          contentEdit: (...params) => this._v3.notes.contentEdit.fetch(...params),
          titleEdit: (...params) => this._v3.notes.titleEdit.fetch(...params),
          delete: (...params) => this._v3.notes.delete.fetch(...params),
          trash: (...params) => this._v3.notes.trash.fetch(...params),
          archive: (...params) => this._v3.notes.archive.fetch(...params),
          restore: (...params) => this._v3.notes.restore.fetch(...params),
          typeChange: (...params) => this._v3.notes.typeChange.fetch(...params),
          pinned: (...params) => this._v3.notes.pinned.fetch(...params),
          favorite: (...params) => this._v3.notes.favorite.fetch(...params),
          history: (...params) => this._v3.notes.history.fetch(...params),
          historyRestore: (...params) => this._v3.notes.historyRestore.fetch(...params),
          participantsRemove: (...params) => this._v3.notes.participantsRemove.fetch(...params),
          participantsAdd: (...params) => this._v3.notes.participantsAdd.fetch(...params),
          participantsPermissions: (...params) => this._v3.notes.participantsPermissions.fetch(...params),
          tags: (...params) => this._v3.notes.tags.fetch(...params),
          tagsCreate: (...params) => this._v3.notes.tagsCreate.fetch(...params),
          tagsRename: (...params) => this._v3.notes.tagsRename.fetch(...params),
          tagsDelete: (...params) => this._v3.notes.tagsDelete.fetch(...params),
          tagsFavorite: (...params) => this._v3.notes.tagsFavorite.fetch(...params),
          tag: (...params) => this._v3.notes.tag.fetch(...params),
          untag: (...params) => this._v3.notes.untag.fetch(...params)
        };
      },
      contacts: () => {
        return {
          all: (...params) => this._v3.contacts.all.fetch(...params),
          requestsIn: (...params) => this._v3.contacts.requestsIn.fetch(...params),
          requestsInCount: (...params) => this._v3.contacts.requestsInCount.fetch(...params),
          requestsOut: (...params) => this._v3.contacts.requestsOut.fetch(...params),
          requestsOutDelete: (...params) => this._v3.contacts.requestsOutDelete.fetch(...params),
          requestsSend: (...params) => this._v3.contacts.requestsSend.fetch(...params),
          requestsAccept: (...params) => this._v3.contacts.requestsAccept.fetch(...params),
          requestsDeny: (...params) => this._v3.contacts.requestsDeny.fetch(...params),
          delete: (...params) => this._v3.contacts.delete.fetch(...params),
          blocked: (...params) => this._v3.contacts.blocked.fetch(...params),
          blockedAdd: (...params) => this._v3.contacts.blockedAdd.fetch(...params),
          blockedDelete: (...params) => this._v3.contacts.blockedDelete.fetch(...params)
        };
      }
    };
  }
};
var api_default = API;

// node_modules/@filen/sdk/dist/browser/crypto/encrypt.js
var import_crypto3 = __toESM(require_crypto());

// node_modules/@filen/sdk/dist/browser/crypto/utils.js
var import_crypto2 = __toESM(require_crypto());
var import_crypto_api_v1 = __toESM(require_crypto_api_v1());
var import_js_crypto_key_utils = __toESM(require_dist7());

// node_modules/@filen/sdk/dist/browser/cache.js
var cache = {
  fileMetadata: /* @__PURE__ */ new Map(),
  folderMetadata: /* @__PURE__ */ new Map(),
  importPublicKey: /* @__PURE__ */ new Map(),
  importPrivateKey: /* @__PURE__ */ new Map(),
  chatKeyParticipant: /* @__PURE__ */ new Map(),
  chatKeyOwner: /* @__PURE__ */ new Map(),
  noteKeyOwner: /* @__PURE__ */ new Map(),
  noteKeyParticipant: /* @__PURE__ */ new Map(),
  noteTitle: /* @__PURE__ */ new Map(),
  notePreview: /* @__PURE__ */ new Map(),
  noteTagName: /* @__PURE__ */ new Map(),
  chatConversationName: /* @__PURE__ */ new Map(),
  folderLinkKey: /* @__PURE__ */ new Map(),
  importRawKey: /* @__PURE__ */ new Map(),
  importPBKDF2Key: /* @__PURE__ */ new Map()
};
var cache_default = cache;

// node_modules/@filen/sdk/dist/browser/crypto/utils.js
var textEncoder = new TextEncoder();
async function generateRandomString({ length }) {
  const chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
  if (environment === "node") {
    const randomBytes = import_crypto2.default.randomBytes(length + 2);
    const result = new Array(length);
    let cursor = 0;
    for (let i = 0; i < length; i++) {
      cursor += randomBytes[i];
      result[i] = chars[cursor % chars.length];
    }
    return result.join("");
  } else if (environment === "browser") {
    const array = new Uint8Array(length);
    globalThis.crypto.getRandomValues(array);
    const randomNumbers = Array.from(array).map((x) => x % chars.length);
    return randomNumbers.map((x) => chars[x]).join("");
  }
  throw new Error(`crypto.utils.generateRandomString not implemented for ${environment} environment`);
}
async function deriveKeyFromPassword({ password, salt, iterations, hash, bitLength, returnHex }) {
  if (environment === "node") {
    return await new Promise((resolve, reject) => {
      import_crypto2.default.pbkdf2(password, salt, iterations, bitLength / 8, hash, (err, result) => {
        if (err) {
          reject(err);
          return;
        }
        if (returnHex) {
          resolve(Buffer.from(result).toString("hex"));
          return;
        }
        resolve(result);
      });
    });
  } else if (environment === "browser") {
    const bits = await globalThis.crypto.subtle.deriveBits({
      name: "PBKDF2",
      salt: textEncoder.encode(salt),
      iterations,
      hash: {
        name: hash === "sha512" ? "SHA-512" : hash
      }
    }, await importPBKDF2Key({ key: password, mode: ["deriveBits"] }), bitLength);
    const key = returnHex ? Buffer.from(bits).toString("hex") : Buffer.from(bits);
    return key;
  }
  throw new Error(`crypto.utils.deriveKeyFromPassword not implemented for ${environment} environment`);
}
async function hashFn({ input }) {
  if (environment === "node") {
    return import_crypto2.default.createHash("sha1").update(import_crypto2.default.createHash("sha512").update(textEncoder.encode(input)).digest("hex")).digest("hex");
  } else if (environment === "browser") {
    return import_crypto_api_v1.default.hash("sha1", import_crypto_api_v1.default.hash("sha512", input));
  }
  throw new Error(`crypto.utils.hashFn not implemented for ${environment} environment`);
}
async function hashPassword({ password }) {
  if (environment === "browser" || environment === "node") {
    return import_crypto_api_v1.default.hash("sha512", import_crypto_api_v1.default.hash("sha384", import_crypto_api_v1.default.hash("sha256", import_crypto_api_v1.default.hash("sha1", password)))) + import_crypto_api_v1.default.hash("sha512", import_crypto_api_v1.default.hash("md5", import_crypto_api_v1.default.hash("md4", import_crypto_api_v1.default.hash("md2", password))));
  }
  throw new Error(`crypto.utils.hashPassword not implemented for ${environment} environment`);
}
async function generatePasswordAndMasterKeyBasedOnAuthVersion({ rawPassword, authVersion, salt }) {
  if (authVersion === 1) {
    const derivedPassword = await hashPassword({ password: rawPassword });
    const derivedMasterKeys = await hashFn({ input: rawPassword });
    return { derivedMasterKeys, derivedPassword };
  } else if (authVersion === 2) {
    const derivedKey = await deriveKeyFromPassword({
      password: rawPassword,
      salt,
      iterations: 2e5,
      hash: "sha512",
      bitLength: 512,
      returnHex: true
    });
    let derivedPassword = derivedKey.substring(derivedKey.length / 2, derivedKey.length);
    const derivedMasterKeys = derivedKey.substring(0, derivedKey.length / 2);
    if (environment === "node") {
      derivedPassword = import_crypto2.default.createHash("sha512").update(textEncoder.encode(derivedPassword)).digest("hex");
    } else if (environment === "browser") {
      derivedPassword = Buffer.from(await globalThis.crypto.subtle.digest("SHA-512", textEncoder.encode(derivedPassword))).toString("hex");
    } else {
      throw new Error(`crypto.utils.generatePasswordAndMasterKeysBasedOnAuthVersion not implemented for ${environment} environment`);
    }
    return { derivedMasterKeys, derivedPassword };
  } else {
    throw new Error(`Invalid authVersion: ${authVersion}`);
  }
}
async function derKeyToPem({ key }) {
  const importedKey = new import_js_crypto_key_utils.default.Key("der", Buffer.from(key, "base64"));
  return (await importedKey.export("pem")).toString();
}
async function importPublicKey({ publicKey, mode = ["encrypt"], keyCache = true }) {
  if (environment !== "browser") {
    throw new Error(`crypto.utils.importPublicKey not implemented for ${environment} environment`);
  }
  const cacheKey = fastStringHash(`${publicKey}:${mode.join(":")}`);
  if (cache_default.importPublicKey.has(cacheKey)) {
    return cache_default.importPublicKey.get(cacheKey);
  }
  const importedPublicKey = await globalThis.crypto.subtle.importKey("spki", Buffer.from(publicKey, "base64"), {
    name: "RSA-OAEP",
    hash: "SHA-512"
  }, true, mode);
  if (keyCache) {
    cache_default.importPublicKey.set(cacheKey, importedPublicKey);
  }
  return importedPublicKey;
}
async function importPrivateKey({ privateKey, mode = ["encrypt"], keyCache = true }) {
  if (environment !== "browser") {
    throw new Error(`crypto.utils.importPrivateKey not implemented for ${environment} environment`);
  }
  const cacheKey = fastStringHash(`${privateKey}:${mode.join(":")}`);
  if (cache_default.importPrivateKey.has(cacheKey)) {
    return cache_default.importPrivateKey.get(cacheKey);
  }
  const importedPrivateKey = await globalThis.crypto.subtle.importKey("pkcs8", Buffer.from(privateKey, "base64"), {
    name: "RSA-OAEP",
    hash: "SHA-512"
  }, true, mode);
  if (keyCache) {
    cache_default.importPrivateKey.set(cacheKey, importedPrivateKey);
  }
  return importedPrivateKey;
}
async function importRawKey({ key, algorithm, mode = ["encrypt"], keyCache = true }) {
  if (environment !== "browser") {
    throw new Error(`crypto.utils.importRawKey not implemented for ${environment} environment`);
  }
  const cacheKey = fastStringHash(`${key}:${algorithm}:${mode.join(":")}`);
  if (cache_default.importRawKey.has(cacheKey)) {
    return cache_default.importRawKey.get(cacheKey);
  }
  const importedRawKey = await globalThis.crypto.subtle.importKey("raw", key, algorithm, false, mode);
  if (keyCache) {
    cache_default.importRawKey.set(cacheKey, importedRawKey);
  }
  return importedRawKey;
}
async function importPBKDF2Key({ key, mode = ["encrypt"], keyCache = true }) {
  if (environment !== "browser") {
    throw new Error(`crypto.utils.importPBKDF2Key not implemented for ${environment} environment`);
  }
  const cacheKey = fastStringHash(`${key}:${mode.join(":")}`);
  if (cache_default.importPBKDF2Key.has(cacheKey)) {
    return cache_default.importPBKDF2Key.get(cacheKey);
  }
  const importedPBKF2Key = await globalThis.crypto.subtle.importKey("raw", textEncoder.encode(key), {
    name: "PBKDF2"
  }, false, mode);
  if (keyCache) {
    cache_default.importPBKDF2Key.set(cacheKey, importedPBKF2Key);
  }
  return importedPBKF2Key;
}
async function bufferToHash({ buffer, algorithm }) {
  if (environment === "node") {
    return import_crypto2.default.createHash(algorithm).update(buffer).digest("hex");
  } else if (environment === "browser") {
    const webcryptoAlgorithm = algorithm === "sha512" ? "SHA-512" : algorithm === "sha256" ? "SHA-256" : "MD-5";
    const digest = await globalThis.crypto.subtle.digest(webcryptoAlgorithm, buffer);
    return Buffer.from(digest).toString("hex");
  }
  throw new Error(`crypto.utils.bufferToHash not implemented for ${environment} environment`);
}
async function generateKeyPair() {
  if (environment === "node") {
    return await new Promise((resolve, reject) => {
      import_crypto2.default.generateKeyPair("rsa", {
        modulusLength: 4096,
        publicKeyEncoding: {
          type: "spki",
          format: "der"
        },
        privateKeyEncoding: {
          type: "pkcs8",
          format: "der"
        },
        publicExponent: 65537
      }, (err, publicKey, privateKey) => {
        if (err) {
          reject(err);
          return;
        }
        resolve({
          publicKey: publicKey.toString("base64"),
          privateKey: privateKey.toString("base64")
        });
      });
    });
  } else if (environment === "browser") {
    const keyPair = await globalThis.crypto.subtle.generateKey({
      name: "RSA-OAEP",
      modulusLength: 4096,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: "SHA-512"
    }, true, ["encrypt", "decrypt"]);
    const publicKey = await globalThis.crypto.subtle.exportKey("spki", keyPair.publicKey);
    const privateKey = await globalThis.crypto.subtle.exportKey("pkcs8", keyPair.privateKey);
    return {
      publicKey: Buffer.from(publicKey).toString("base64"),
      privateKey: Buffer.from(privateKey).toString("base64")
    };
  }
  throw new Error(`crypto.utils.generateKeyPair not implemented for ${environment} environment`);
}
function EVP_BytesToKey({ password, salt, keyBits, ivLength }) {
  let keyLen = keyBits / 8;
  const key = Buffer.alloc(keyLen);
  const iv = Buffer.alloc(ivLength || 0);
  let tmp = Buffer.alloc(0);
  while (keyLen > 0 || ivLength > 0) {
    const hash = import_crypto2.default.createHash("md5");
    hash.update(tmp);
    hash.update(password);
    if (salt) {
      hash.update(salt);
    }
    tmp = hash.digest();
    let used = 0;
    if (keyLen > 0) {
      const keyStart = key.length - keyLen;
      used = Math.min(keyLen, tmp.length);
      tmp.copy(key, keyStart, 0, used);
      keyLen -= used;
    }
    if (used < tmp.length && ivLength > 0) {
      const ivStart = iv.length - ivLength;
      const length = Math.min(ivLength, tmp.length - used);
      tmp.copy(iv, ivStart, used, used + length);
      ivLength -= length;
    }
  }
  tmp.fill(0);
  return {
    key,
    iv
  };
}
var utils2 = {
  generateRandomString,
  deriveKeyFromPassword,
  hashFn,
  generatePasswordAndMasterKeyBasedOnAuthVersion,
  hashPassword,
  derKeyToPem,
  importPublicKey,
  importPrivateKey,
  bufferToHash,
  generateKeyPair,
  importRawKey,
  importPBKDF2Key
};
var utils_default2 = utils2;

// node_modules/@filen/sdk/dist/browser/crypto/encrypt.js
var import_path2 = __toESM(require_path());
var import_fs_extra3 = __toESM(require_lib());
var import_stream3 = __toESM(require_stream());
var import_util2 = __toESM(require_util());
var pipelineAsync2 = (0, import_util2.promisify)(import_stream3.pipeline);
var Encrypt = class {
  /**
   * Creates an instance of Encrypt.
   * @date 1/31/2024 - 3:59:21 PM
   *
   * @constructor
   * @public
   * @param {CryptoConfig} params
   */
  constructor(params) {
    __publicField(this, "config");
    __publicField(this, "textEncoder", new TextEncoder());
    this.config = params;
  }
  /**
   * Encrypt a string using the user's last master key.
   * @date 1/31/2024 - 3:59:29 PM
   *
   * @public
   * @async
   * @param {{ data: string }} param0
   * @param {string} param0.data
   * @returns {Promise<string>}
   */
  async metadata({ metadata, key, derive = true }) {
    const keyToUse = key ? key : this.config.masterKeys[this.config.masterKeys.length - 1];
    if (!keyToUse) {
      throw new Error("No key to use.");
    }
    const iv = await generateRandomString({ length: 12 });
    const ivBuffer = this.textEncoder.encode(iv);
    if (environment === "node") {
      const derivedKey = derive ? await deriveKeyFromPassword({
        password: keyToUse,
        salt: keyToUse,
        iterations: 1,
        hash: "sha512",
        bitLength: 256,
        returnHex: false
      }) : this.textEncoder.encode(keyToUse);
      const dataBuffer = this.textEncoder.encode(metadata);
      const cipher = import_crypto3.default.createCipheriv("aes-256-gcm", derivedKey, ivBuffer);
      const encrypted = Buffer.concat([cipher.update(dataBuffer), cipher.final()]);
      const authTag = cipher.getAuthTag();
      return `002${iv}${Buffer.concat([encrypted, authTag]).toString("base64")}`;
    } else if (environment === "browser") {
      const derivedKey = derive ? await deriveKeyFromPassword({
        password: keyToUse,
        salt: keyToUse,
        iterations: 1,
        hash: "sha512",
        bitLength: 256,
        returnHex: false
      }) : Buffer.from(keyToUse, "utf-8");
      const dataBuffer = this.textEncoder.encode(metadata);
      const encrypted = await globalThis.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: ivBuffer
      }, await importRawKey({ key: derivedKey, algorithm: "AES-GCM", mode: ["encrypt"], keyCache: false }), dataBuffer);
      return `002${iv}${Buffer.from(encrypted).toString("base64")}`;
    }
    throw new Error(`crypto.encrypt.metadata not implemented for ${environment} environment`);
  }
  /**
   * Encrypts metadata using a public key.
   * @date 2/2/2024 - 6:49:12 PM
   *
   * @public
   * @async
   * @param {{ metadata: string; publicKey: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.publicKey
   * @returns {Promise<string>}
   */
  async metadataPublic({ metadata, publicKey }) {
    if (environment === "node") {
      const pemKey = await derKeyToPem({ key: publicKey });
      const encrypted = import_crypto3.default.publicEncrypt({
        key: pemKey,
        padding: import_crypto3.default.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: "sha512"
      }, this.textEncoder.encode(metadata));
      return Buffer.from(encrypted).toString("base64");
    } else if (environment === "browser") {
      const importedPublicKey = await importPublicKey({ publicKey, mode: ["encrypt"] });
      const encrypted = await globalThis.crypto.subtle.encrypt({
        name: "RSA-OAEP"
      }, importedPublicKey, this.textEncoder.encode(metadata));
      return Buffer.from(encrypted).toString("base64");
    }
    throw new Error(`crypto.encrypt.metadataPublic not implemented for ${environment} environment`);
  }
  /**
   * Encrypt a chat message using the conversation encryption key.
   * @date 2/6/2024 - 3:01:09 AM
   *
   * @public
   * @async
   * @param {{ message: string; key: string }} param0
   * @param {string} param0.message
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async chatMessage({ message, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    return await this.metadata({ metadata: JSON.stringify({ message }), key });
  }
  /**
   * Encrypt note content using the note's encryption key.
   * @date 2/6/2024 - 3:02:23 AM
   *
   * @public
   * @async
   * @param {{ content: string; key: string }} param0
   * @param {string} param0.content
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteContent({ content, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    return await this.metadata({ metadata: JSON.stringify({ content }), key });
  }
  /**
   * Encrypt the note's title using the note's encryption key.
   * @date 2/6/2024 - 3:02:44 AM
   *
   * @public
   * @async
   * @param {{ title: string; key: string }} param0
   * @param {string} param0.title
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteTitle({ title, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    return await this.metadata({ metadata: JSON.stringify({ title }), key });
  }
  /**
   * Encrypt the note's preview using the note's encryption key.
   * @date 2/6/2024 - 3:02:56 AM
   *
   * @public
   * @async
   * @param {{ preview: string; key: string }} param0
   * @param {string} param0.preview
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async notePreview({ preview, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    return await this.metadata({ metadata: JSON.stringify({ preview }), key });
  }
  /**
   * Encrypt a tag's name using the given key.
   * @date 2/20/2024 - 3:21:12 AM
   *
   * @public
   * @async
   * @param {{ name: string; key?: string }} param0
   * @param {string} param0.name
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteTagName({ name, key }) {
    const keyToUse = key ? key : this.config.masterKeys[this.config.masterKeys.length - 1];
    if (keyToUse.length === 0) {
      throw new Error("Invalid key.");
    }
    return await this.metadata({ metadata: JSON.stringify({ name }), key: keyToUse });
  }
  /**
   * Encrypt the conversation name using the conversation encryption key.
   * @date 2/6/2024 - 3:03:45 AM
   *
   * @public
   * @async
   * @param {{ name: string; key: string }} param0
   * @param {string} param0.name
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async chatConversationName({ name, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    return await this.metadata({ metadata: JSON.stringify({ name }), key });
  }
  /**
   * Encrypt data.
   * @date 2/7/2024 - 1:50:47 AM
   *
   * @public
   * @async
   * @param {{ data: Buffer; key: string }} param0
   * @param {Buffer} param0.data
   * @param {string} param0.key
   * @returns {Promise<Buffer>}
   */
  async data({ data, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const iv = await generateRandomString({ length: 12 });
    if (environment === "node") {
      const ivBuffer = Buffer.from(iv, "utf-8");
      const cipher = import_crypto3.default.createCipheriv("aes-256-gcm", Buffer.from(key, "utf-8"), ivBuffer);
      const encrypted = Buffer.concat([cipher.update(data), cipher.final()]);
      const authTag = cipher.getAuthTag();
      const ciphertext = Buffer.concat([encrypted, authTag]);
      return Buffer.concat([ivBuffer, ciphertext]);
    } else if (environment === "browser") {
      const encrypted = await globalThis.crypto.subtle.encrypt({
        name: "AES-GCM",
        iv: this.textEncoder.encode(iv)
      }, await importRawKey({
        key: Buffer.from(key, "utf-8"),
        algorithm: "AES-GCM",
        mode: ["encrypt"],
        keyCache: false
      }), data);
      return Buffer.concat([this.textEncoder.encode(iv), new Uint8Array(encrypted)]);
    }
    throw new Error(`crypto.decrypt.data not implemented for ${environment} environment`);
  }
  /**
   * Encrypt a file/chunk using streams. Only available in a Node.JS environment.
   * @date 2/7/2024 - 1:51:28 AM
   *
   * @public
   * @async
   * @param {{ inputFile: string; key: string; outputFile?: string }} param0
   * @param {string} param0.inputFile
   * @param {string} param0.key
   * @param {string} param0.outputFile
   * @returns {Promise<string>}
   */
  async dataStream({ inputFile, key, outputFile }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    if (environment !== "node") {
      throw new Error(`crypto.encrypt.dataStream not implemented for ${environment} environment`);
    }
    const input = normalizePath(inputFile);
    const output = normalizePath(outputFile ? outputFile : import_path2.default.join(this.config.tmpPath, await uuidv4()));
    if (!await import_fs_extra3.default.exists(input)) {
      throw new Error("Input file does not exist.");
    }
    await import_fs_extra3.default.rm(output, {
      force: true,
      maxRetries: 60 * 10,
      recursive: true,
      retryDelay: 100
    });
    const iv = await generateRandomString({ length: 12 });
    const ivBuffer = Buffer.from(iv, "utf-8");
    const cipher = import_crypto3.default.createCipheriv("aes-256-gcm", Buffer.from(key, "utf-8"), ivBuffer);
    const readStream = import_fs_extra3.default.createReadStream(normalizePath(input), {
      highWaterMark: BUFFER_SIZE
    });
    const writeStream = import_fs_extra3.default.createWriteStream(normalizePath(output));
    await new Promise((resolve, reject) => {
      writeStream.write(ivBuffer, (err) => {
        if (err) {
          reject(err);
          return;
        }
        resolve();
      });
    });
    await pipelineAsync2(readStream, cipher, writeStream);
    const authTag = cipher.getAuthTag();
    await import_fs_extra3.default.appendFile(output, authTag);
    return output;
  }
};
var encrypt_default = Encrypt;

// node_modules/@filen/sdk/dist/browser/crypto/decrypt.js
var import_crypto4 = __toESM(require_crypto());
var import_path3 = __toESM(require_path());
var import_fs_extra5 = __toESM(require_lib());

// node_modules/@filen/sdk/dist/browser/streams/base64.js
var import_fs_extra4 = __toESM(require_lib());
var import_stream4 = __toESM(require_stream());
var import_util3 = __toESM(require_util());
var pipelineAsync3 = (0, import_util3.promisify)(import_stream4.pipeline);
var Base64DecodeStream = class extends import_stream4.Transform {
  /**
   * Creates an instance of Base64DecodeStream.
   * @date 2/7/2024 - 12:48:10 AM
   *
   * @constructor
   * @public
   */
  constructor() {
    super();
  }
  /**
   * Custom transform function, decodes each chunk from base64 to a buffer.
   * @date 2/7/2024 - 12:48:02 AM
   *
   * @public
   * @param {Buffer} chunk
   * @param {BufferEncoding} encoding
   * @param {(error?: Error | null, data?: Buffer) => void} callback
   */
  _transform(chunk, encoding, callback) {
    try {
      this.push(Buffer.from(chunk.toString("utf-8"), "base64"));
      callback();
    } catch (e) {
      callback(e);
    }
  }
};
var Base64EncodeStream = class extends import_stream4.Transform {
  constructor() {
    super();
  }
  /**
   * Custom transform function, encodes each chunk from a buffer to base64.
   * @date 2/7/2024 - 12:48:02 AM
   *
   * @public
   * @param {Buffer} chunk
   * @param {BufferEncoding} encoding
   * @param {(error?: Error | null, data?: Buffer) => void} callback
   */
  _transform(chunk, encoding, callback) {
    try {
      this.push(chunk.toString("base64"));
      callback();
    } catch (e) {
      callback(e);
    }
  }
};
async function streamDecodeBase64({ inputFile, outputFile }) {
  const input = normalizePath(inputFile);
  const output = normalizePath(outputFile);
  if (!await import_fs_extra4.default.exists(input)) {
    throw new Error("Input file does not exist.");
  }
  await import_fs_extra4.default.rm(output, {
    force: true,
    maxRetries: 60 * 10,
    recursive: true,
    retryDelay: 100
  });
  const readStream = import_fs_extra4.default.createReadStream(input, {
    highWaterMark: BASE64_BUFFER_SIZE
  });
  const writeStream = import_fs_extra4.default.createWriteStream(output);
  await pipelineAsync3(readStream, new Base64DecodeStream(), writeStream);
  return output;
}
async function streamEncodeBase64({ inputFile, outputFile }) {
  const input = normalizePath(inputFile);
  const output = normalizePath(outputFile);
  if (!await import_fs_extra4.default.exists(input)) {
    throw new Error("Input file does not exist.");
  }
  await import_fs_extra4.default.rm(output, {
    force: true,
    maxRetries: 60 * 10,
    recursive: true,
    retryDelay: 100
  });
  const readStream = import_fs_extra4.default.createReadStream(input, {
    highWaterMark: BASE64_BUFFER_SIZE
  });
  const writeStream = import_fs_extra4.default.createWriteStream(output);
  await pipelineAsync3(readStream, new Base64EncodeStream(), writeStream);
  return output;
}

// node_modules/@filen/sdk/dist/browser/crypto/decrypt.js
var import_stream5 = __toESM(require_stream());
var import_util4 = __toESM(require_util());
var import_crypto_js = __toESM(require_crypto_js());
var pipelineAsync4 = (0, import_util4.promisify)(import_stream5.pipeline);
var Decrypt = class {
  /**
   * Creates an instance of Decrypt.
   * @date 1/31/2024 - 3:59:10 PM
   *
   * @constructor
   * @public
   * @param {CryptoConfig} params
   */
  constructor(params) {
    __publicField(this, "config");
    __publicField(this, "textDecoder", new TextDecoder());
    this.config = params;
  }
  /**
   * Decrypt a string with the given key.
   * @date 1/31/2024 - 3:58:27 PM
   *
   * @public
   * @async
   * @param {{ data: string; key: string }} param0
   * @param {string} param0.data
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async metadata({ metadata, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const sliced = metadata.slice(0, 8);
    if (sliced === "U2FsdGVk") {
      return import_crypto_js.default.AES.decrypt(metadata, key).toString(import_crypto_js.default.enc.Utf8);
    } else {
      const version = metadata.slice(0, 3);
      if (version === "002") {
        const keyBuffer = await deriveKeyFromPassword({
          password: key,
          salt: key,
          iterations: 1,
          hash: "sha512",
          bitLength: 256,
          returnHex: false
        });
        const ivBuffer = Buffer.from(metadata.slice(3, 15), "utf-8");
        const encrypted = Buffer.from(metadata.slice(15), "base64");
        if (environment === "node") {
          const authTag = encrypted.subarray(-16);
          const cipherText = encrypted.subarray(0, encrypted.byteLength - 16);
          const decipher = import_crypto4.default.createDecipheriv("aes-256-gcm", keyBuffer, ivBuffer);
          decipher.setAuthTag(authTag);
          return Buffer.concat([decipher.update(cipherText), decipher.final()]).toString("utf-8");
        } else if (environment === "browser") {
          const decrypted = await globalThis.crypto.subtle.decrypt({
            name: "AES-GCM",
            iv: ivBuffer
          }, await importRawKey({ key: keyBuffer, algorithm: "AES-GCM", mode: ["decrypt"] }), encrypted);
          return Buffer.from(decrypted).toString("utf-8");
        }
        throw new Error(`crypto.decrypt.metadata is not implemented for ${environment} environment`);
      }
      throw new Error(`[crypto.decrypt.metadata] Invalid metadata version ${version}`);
    }
  }
  /**
   * Decrypt metadata using the given private key.
   * @date 2/3/2024 - 1:50:10 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; privateKey: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.privateKey
   * @returns {Promise<string>}
   */
  async metadataPrivate({ metadata, privateKey }) {
    if (privateKey.length === 0) {
      throw new Error("Invalid privateKey.");
    }
    if (environment === "node") {
      const pemKey = await derKeyToPem({ key: privateKey });
      const decrypted = import_crypto4.default.privateDecrypt({
        key: pemKey,
        padding: import_crypto4.default.constants.RSA_PKCS1_OAEP_PADDING,
        oaepHash: "sha512"
      }, Buffer.from(metadata, "base64"));
      return decrypted.toString("utf-8");
    } else if (environment === "browser") {
      const importedPrivateKey = await importPrivateKey({ privateKey, mode: ["decrypt"] });
      const decrypted = await globalThis.crypto.subtle.decrypt({
        name: "RSA-OAEP"
      }, importedPrivateKey, Buffer.from(metadata, "base64"));
      return this.textDecoder.decode(decrypted);
    }
    throw new Error(`crypto.encrypt.metadataPrivate not implemented for ${environment} environment`);
  }
  /**
   * Decrypt file metadata.
   * @date 2/3/2024 - 1:54:51 AM
   *
   * @public
   * @async
   * @param {{ metadata: string, key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<FileMetadata>}
   */
  async fileMetadata({ metadata, key }) {
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.fileMetadata.has(cacheKey)) {
      return cache_default.fileMetadata.get(cacheKey);
    }
    let fileMetadata = {
      name: "",
      size: 1,
      mime: "application/octet-stream",
      key: "",
      lastModified: Date.now(),
      creation: void 0,
      hash: void 0
    };
    const keysToUse = key ? [key] : this.config.masterKeys;
    for (const masterKey of keysToUse) {
      try {
        const decrypted = JSON.parse(await this.metadata({ metadata, key: masterKey }));
        if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
          const lastModifiedParsed = parseInt(decrypted.lastModified ?? Date.now());
          fileMetadata = {
            size: parseInt(decrypted.size ?? 0),
            lastModified: lastModifiedParsed > 0 ? convertTimestampToMs(lastModifiedParsed) : Date.now(),
            creation: typeof decrypted.creation === "number" ? convertTimestampToMs(parseInt(decrypted.creation)) : void 0,
            name: decrypted.name,
            key: decrypted.key,
            mime: decrypted.mime,
            hash: decrypted.hash
          };
          if (this.config.metadataCache) {
            cache_default.fileMetadata.set(cacheKey, fileMetadata);
          }
          break;
        }
      } catch {
        continue;
      }
    }
    return fileMetadata;
  }
  /**
   * Decrypt folder metadata.
   * @date 2/3/2024 - 1:55:17 AM
   *
   * @public
   * @async
   * @param {{ metadata: string, key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<FolderMetadata>}
   */
  async folderMetadata({ metadata, key }) {
    if (metadata === "default") {
      return {
        name: "Default"
      };
    }
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.folderMetadata.has(cacheKey)) {
      return cache_default.folderMetadata.get(cacheKey);
    }
    let folderMetadata = {
      name: ""
    };
    const keysToUse = key ? [key] : this.config.masterKeys;
    for (const masterKey of keysToUse) {
      try {
        const decrypted = JSON.parse(await this.metadata({ metadata, key: masterKey }));
        if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
          folderMetadata = {
            name: decrypted.name
          };
          if (this.config.metadataCache) {
            cache_default.folderMetadata.set(cacheKey, folderMetadata);
          }
          break;
        }
      } catch {
        continue;
      }
    }
    return folderMetadata;
  }
  /**
   * Decrypt file metadata using a private key.
   * @date 2/3/2024 - 1:58:12 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<FileMetadata>}
   */
  async fileMetadataPrivate({ metadata, key }) {
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.fileMetadata.has(cacheKey)) {
      return cache_default.fileMetadata.get(cacheKey);
    }
    let fileMetadata = {
      name: "",
      size: 1,
      mime: "application/octet-stream",
      key: "",
      lastModified: Date.now(),
      creation: void 0,
      hash: void 0
    };
    const privateKey = key ? key : this.config.privateKey;
    if (privateKey.length === 0) {
      throw new Error("Invalid privateKey.");
    }
    const decrypted = JSON.parse(await this.metadataPrivate({ metadata, privateKey }));
    if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
      const lastModifiedParsed = parseInt(decrypted.lastModified ?? Date.now());
      fileMetadata = {
        size: parseInt(decrypted.size ?? 0),
        lastModified: lastModifiedParsed > 0 ? convertTimestampToMs(lastModifiedParsed) : Date.now(),
        creation: typeof decrypted.creation === "number" ? convertTimestampToMs(parseInt(decrypted.creation)) : void 0,
        name: decrypted.name,
        key: decrypted.key,
        mime: decrypted.mime,
        hash: decrypted.hash
      };
      if (this.config.metadataCache) {
        cache_default.fileMetadata.set(cacheKey, fileMetadata);
      }
    }
    return fileMetadata;
  }
  /**
   * Decrypt folder metadata using a private key.
   * @date 2/3/2024 - 1:58:05 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<FolderMetadata>}
   */
  async folderMetadataPrivate({ metadata, key }) {
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.folderMetadata.has(cacheKey)) {
      return cache_default.folderMetadata.get(cacheKey);
    }
    let folderMetadata = {
      name: ""
    };
    const privateKey = key ? key : this.config.privateKey;
    if (privateKey.length === 0) {
      throw new Error("Invalid privateKey.");
    }
    const decrypted = JSON.parse(await this.metadataPrivate({ metadata, privateKey }));
    if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
      folderMetadata = {
        name: decrypted.name
      };
      if (this.config.metadataCache) {
        cache_default.folderMetadata.set(cacheKey, folderMetadata);
      }
    }
    return folderMetadata;
  }
  /**
   * Decrypt file metadata inside a public link.
   * @date 2/6/2024 - 3:05:42 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; linkKey: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.linkKey
   * @returns {Promise<FileMetadata>}
   */
  async fileMetadataLink({ metadata, linkKey }) {
    if (linkKey.length === 0) {
      throw new Error("Invalid linkKey.");
    }
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.fileMetadata.has(cacheKey)) {
      return cache_default.fileMetadata.get(cacheKey);
    }
    let fileMetadata = {
      name: "",
      size: 1,
      mime: "application/octet-stream",
      key: "",
      lastModified: Date.now(),
      creation: void 0,
      hash: void 0
    };
    const decrypted = JSON.parse(await this.metadata({ metadata, key: linkKey }));
    if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
      const lastModifiedParsed = parseInt(decrypted.lastModified ?? Date.now());
      fileMetadata = {
        size: parseInt(decrypted.size ?? 0),
        lastModified: lastModifiedParsed > 0 ? convertTimestampToMs(lastModifiedParsed) : Date.now(),
        creation: typeof decrypted.creation === "number" ? convertTimestampToMs(parseInt(decrypted.creation)) : void 0,
        name: decrypted.name,
        key: decrypted.key,
        mime: decrypted.mime,
        hash: decrypted.hash
      };
      if (this.config.metadataCache) {
        cache_default.fileMetadata.set(cacheKey, fileMetadata);
      }
    }
    return fileMetadata;
  }
  /**
   * Decrypt folder metadata inside a public link.
   * @date 2/6/2024 - 3:07:06 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; linkKey: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.linkKey
   * @returns {Promise<FolderMetadata>}
   */
  async folderMetadataLink({ metadata, linkKey }) {
    if (linkKey.length === 0) {
      throw new Error("Invalid linkKey.");
    }
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.folderMetadata.has(cacheKey)) {
      return cache_default.folderMetadata.get(cacheKey);
    }
    let folderMetadata = {
      name: ""
    };
    const decrypted = JSON.parse(await this.metadata({ metadata, key: linkKey }));
    if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
      folderMetadata = {
        name: decrypted.name
      };
      if (this.config.metadataCache) {
        cache_default.folderMetadata.set(cacheKey, folderMetadata);
      }
    }
    return folderMetadata;
  }
  /**
   * Decrypt a public link folder encryption key (using given key or master keys).
   * @date 2/6/2024 - 3:09:37 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async folderLinkKey({ metadata, key }) {
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.folderLinkKey.has(cacheKey)) {
      return cache_default.folderLinkKey.get(cacheKey);
    }
    const keysToUse = key ? [key] : this.config.masterKeys;
    for (const masterKey of keysToUse) {
      try {
        const decrypted = await this.metadata({ metadata, key: masterKey });
        if (typeof decrypted === "string" && decrypted.length > 16) {
          if (this.config.metadataCache) {
            cache_default.folderLinkKey.set(cacheKey, decrypted);
          }
          return decrypted;
        }
      } catch {
        continue;
      }
    }
    throw new Error("Could not decrypt folder link key using given keys.");
  }
  /**
   * Decrypts a chat encryption (symmetric) key.
   * @date 2/6/2024 - 12:54:25 AM
   *
   * @public
   * @async
   * @param {{metadata: string, privateKey: string}} param0
   * @param {string} param0.metadata
   * @param {string} param0.privateKey
   * @returns {Promise<string>}
   */
  async chatKeyParticipant({ metadata, privateKey }) {
    if (privateKey.length === 0) {
      throw new Error("Invalid privateKey.");
    }
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.chatKeyParticipant.has(cacheKey)) {
      return cache_default.chatKeyParticipant.get(cacheKey);
    }
    const decrypted = await this.metadataPrivate({ metadata, privateKey });
    const parsed = JSON.parse(decrypted);
    if (typeof parsed.key !== "string") {
      throw new Error("Could not decrypt chat key, malformed decrypted metadata");
    }
    if (this.config.metadataCache) {
      cache_default.chatKeyParticipant.set(cacheKey, parsed.key);
    }
    return parsed.key;
  }
  /**
   * Decrypts a chat encryption (symmetric) key.
   *
   * @public
   * @async
   * @param {{ metadata: string; key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async chatKeyOwner({ metadata, key }) {
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.chatKeyOwner.has(cacheKey)) {
      return cache_default.chatKeyOwner.get(cacheKey);
    }
    const keysToUse = key ? [key] : this.config.masterKeys;
    for (const masterKey of keysToUse) {
      try {
        const decrypted = await this.metadata({
          metadata,
          key: masterKey
        });
        if (typeof decrypted !== "string") {
          continue;
        }
        const parsed = JSON.parse(decrypted);
        if (typeof parsed.key !== "string") {
          continue;
        }
        if (this.config.metadataCache) {
          cache_default.chatKeyOwner.set(cacheKey, parsed.key);
        }
        return parsed.key;
      } catch {
        continue;
      }
    }
    throw new Error("Could not decrypt chat key using master keys.");
  }
  /**
   * Decrypt a chat message
   * @date 2/20/2024 - 5:34:42 AM
   *
   * @public
   * @async
   * @param {{
   * 		message: string
   * 		key: string
   * 	}} param0
   * @param {string} param0.message
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async chatMessage({ message, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const messageDecrypted = await this.metadata({ metadata: message, key });
    const parsedMessage = JSON.parse(messageDecrypted);
    if (typeof parsedMessage.message !== "string") {
      return "";
    }
    return parsedMessage.message;
  }
  /**
   * Decrypts the symmetric note encryption key with the given owner metadata.
   * @date 2/6/2024 - 1:01:59 AM
   *
   * @public
   * @async
   * @param {{ metadata: string; key?: string }} param0
   * @param {string} param0.metadata
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteKeyOwner({ metadata, key }) {
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.noteKeyOwner.has(cacheKey)) {
      return cache_default.noteKeyOwner.get(cacheKey);
    }
    const keysToUse = key ? [key] : this.config.masterKeys;
    for (const masterKey of keysToUse) {
      try {
        const decrypted = JSON.parse(await this.metadata({ metadata, key: masterKey }));
        if (decrypted && typeof decrypted.key === "string" && decrypted.key.length > 16) {
          if (this.config.metadataCache) {
            cache_default.noteKeyOwner.set(cacheKey, decrypted.key);
          }
          return decrypted.key;
        }
      } catch {
        continue;
      }
    }
    throw new Error("Could not decrypt note key (owner) using given metadata and keys");
  }
  /**
   * Decrypt a symmetric note encryption key using participant metadata and their private key.
   * @date 2/6/2024 - 2:47:34 AM
   *
   * @public
   * @async
   * @param {{metadata: string, privateKey: string}} param0
   * @param {string} param0.metadata
   * @param {string} param0.privateKey
   * @returns {Promise<string>}
   */
  async noteKeyParticipant({ metadata, privateKey }) {
    if (privateKey.length === 0) {
      throw new Error("Invalid privateKey.");
    }
    const cacheKey = fastStringHash(metadata);
    if (this.config.metadataCache && cache_default.noteKeyParticipant.has(cacheKey)) {
      return cache_default.noteKeyParticipant.get(cacheKey);
    }
    const decrypted = await this.metadataPrivate({ metadata, privateKey });
    const parsed = JSON.parse(decrypted);
    if (typeof parsed.key !== "string") {
      throw new Error("Could not decrypt note key of participant, malformed decrypted metadata");
    }
    if (this.config.metadataCache) {
      cache_default.noteKeyParticipant.set(cacheKey, parsed.key);
    }
    return parsed.key;
  }
  /**
   * Decrypt note content using the note's symmetric encryption key.
   * @date 2/6/2024 - 2:50:15 AM
   *
   * @public
   * @async
   * @param {{content: string, key: string}} param0
   * @param {string} param0.content
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteContent({ content, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const decrypted = await this.metadata({ metadata: content, key });
    const parsed = JSON.parse(decrypted);
    if (typeof parsed.content !== "string") {
      return "";
    }
    return parsed.content;
  }
  /**
   * Decrypt a note's title using the note's symmetric encryption key.
   * @date 2/6/2024 - 2:52:02 AM
   *
   * @public
   * @async
   * @param {{title: string, key: string}} param0
   * @param {string} param0.title
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteTitle({ title, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const cacheKey = fastStringHash(title);
    if (this.config.metadataCache && cache_default.noteTitle.has(cacheKey)) {
      return cache_default.noteTitle.get(cacheKey);
    }
    const decrypted = await this.metadata({ metadata: title, key });
    const parsed = JSON.parse(decrypted);
    if (typeof parsed.title !== "string") {
      return "";
    }
    if (this.config.metadataCache) {
      cache_default.noteTitle.set(cacheKey, parsed.title);
    }
    return parsed.title;
  }
  /**
   * Decrypt a note's preview using the note's symmetric encryption key.
   * @date 2/6/2024 - 2:53:35 AM
   *
   * @public
   * @async
   * @param {{ preview: string; key: string }} param0
   * @param {string} param0.preview
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async notePreview({ preview, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const cacheKey = fastStringHash(preview);
    if (this.config.metadataCache && cache_default.notePreview.has(cacheKey)) {
      return cache_default.notePreview.get(cacheKey);
    }
    const decrypted = await this.metadata({ metadata: preview, key });
    const parsed = JSON.parse(decrypted);
    if (typeof parsed.preview !== "string") {
      return "";
    }
    if (this.config.metadataCache) {
      cache_default.notePreview.set(cacheKey, parsed.preview);
    }
    return parsed.preview;
  }
  /**
   * Decrypt a note tag name using the master keys or a given key.
   * @date 2/6/2024 - 2:56:38 AM
   *
   * @public
   * @async
   * @param {{name: string, key?: string}} param0
   * @param {string} param0.name
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async noteTagName({ name, key }) {
    const cacheKey = fastStringHash(name);
    if (this.config.metadataCache && cache_default.noteTagName.has(cacheKey)) {
      return cache_default.noteTagName.get(cacheKey);
    }
    const keysToUse = key ? [key] : this.config.masterKeys;
    for (const masterKey of keysToUse) {
      try {
        const decrypted = JSON.parse(await this.metadata({ metadata: name, key: masterKey }));
        if (decrypted && typeof decrypted.name === "string" && decrypted.name.length > 0) {
          if (this.config.metadataCache) {
            cache_default.noteTagName.set(cacheKey, decrypted.name);
          }
          return decrypted.name;
        }
      } catch {
        continue;
      }
    }
    return "";
  }
  /**
   * Decrypt a chat conversation name.
   * @date 2/20/2024 - 5:31:41 AM
   *
   * @public
   * @async
   * @param {{
   * 		name: string
   * 		key: string
   * 	}} param0
   * @param {string} param0.name
   * @param {string} param0.key
   * @returns {Promise<string>}
   */
  async chatConversationName({ name, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const cacheKey = fastStringHash(name);
    if (this.config.metadataCache && cache_default.chatConversationName.has(cacheKey)) {
      return cache_default.chatConversationName.get(cacheKey);
    }
    const nameDecrypted = await this.metadata({ metadata: name, key });
    const parsed = JSON.parse(nameDecrypted);
    if (typeof parsed.name !== "string") {
      return "";
    }
    if (this.config.metadataCache) {
      cache_default.chatConversationName.set(cacheKey, parsed.name);
    }
    return parsed.name;
  }
  /**
   * Decrypt data.
   * @date 2/7/2024 - 1:50:58 AM
   *
   * @public
   * @async
   * @param {{ data: Buffer; key: string; version: FileEncryptionVersion }} param0
   * @param {Buffer} param0.data
   * @param {string} param0.key
   * @param {FileEncryptionVersion} param0.version
   * @returns {Promise<Buffer>}
   */
  async data({ data, key, version }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    if (environment === "node") {
      if (version === 1) {
        const firstBytes = Buffer.from(data.subarray(0, 16));
        const asciiString = firstBytes.toString("ascii");
        const base64String = firstBytes.toString("base64");
        const utf8String = firstBytes.toString("utf-8");
        let needsConvert = true;
        let isCBC = true;
        if (asciiString.startsWith("Salted_") || base64String.startsWith("Salted_") || utf8String.startsWith("Salted_")) {
          needsConvert = false;
        }
        if (asciiString.startsWith("Salted_") || base64String.startsWith("Salted_") || utf8String.startsWith("U2FsdGVk") || asciiString.startsWith("U2FsdGVk") || utf8String.startsWith("Salted_") || base64String.startsWith("U2FsdGVk")) {
          isCBC = false;
        }
        if (needsConvert && !isCBC) {
          data = Buffer.from(this.textDecoder.decode(data), "base64");
        }
        if (!isCBC) {
          const saltBytes = Buffer.from(data.subarray(8, 16));
          const { key: keyBytes, iv: ivBytes } = EVP_BytesToKey({
            password: Buffer.from(key, "utf-8"),
            salt: saltBytes,
            keyBits: 256,
            ivLength: 16
          });
          const decipher = import_crypto4.default.createDecipheriv("aes-256-cbc", keyBytes, ivBytes);
          const ciphertext = data.subarray(16);
          return Buffer.concat([decipher.update(ciphertext), decipher.final()]);
        } else {
          const keyBytes = Buffer.from(key, "utf-8");
          const ivBytes = keyBytes.subarray(0, 16);
          const decipher = import_crypto4.default.createDecipheriv("aes-256-cbc", keyBytes, ivBytes);
          return Buffer.concat([decipher.update(data), decipher.final()]);
        }
      } else if (version === 2) {
        const iv = data.subarray(0, 12);
        const encData = data.subarray(12);
        const authTag = encData.subarray(-16);
        const ciphertext = encData.subarray(0, encData.byteLength - 16);
        const decipher = import_crypto4.default.createDecipheriv("aes-256-gcm", Buffer.from(key, "utf-8"), iv);
        decipher.setAuthTag(authTag);
        return Buffer.concat([decipher.update(ciphertext), decipher.final()]);
      }
    } else if (environment === "browser") {
      if (version === 1) {
        const firstBytes = Buffer.from(data.subarray(0, 16));
        const asciiString = firstBytes.toString("ascii");
        const base64String = firstBytes.toString("base64");
        const utf8String = firstBytes.toString("utf-8");
        let needsConvert = true;
        let isCBC = true;
        if (asciiString.startsWith("Salted_") || base64String.startsWith("Salted_") || utf8String.startsWith("Salted_")) {
          needsConvert = false;
        }
        if (asciiString.startsWith("Salted_") || base64String.startsWith("Salted_") || utf8String.startsWith("U2FsdGVk") || asciiString.startsWith("U2FsdGVk") || utf8String.startsWith("Salted_") || base64String.startsWith("U2FsdGVk")) {
          isCBC = false;
        }
        if (needsConvert && !isCBC) {
          data = Buffer.from(this.textDecoder.decode(data), "base64");
        }
        if (!isCBC) {
          const saltBytes = Buffer.from(data.subarray(8, 16));
          const { key: keyBytes, iv: ivBytes } = EVP_BytesToKey({
            password: Buffer.from(key, "utf-8"),
            salt: saltBytes,
            keyBits: 256,
            ivLength: 16
          });
          const decrypted = await globalThis.crypto.subtle.decrypt({
            name: "AES-CBC",
            iv: ivBytes
          }, await importRawKey({
            key: keyBytes,
            algorithm: "AES-CBC",
            mode: ["decrypt"]
          }), data.subarray(16));
          return Buffer.from(decrypted);
        } else {
          const keyBytes = Buffer.from(key, "utf-8");
          const ivBytes = keyBytes.subarray(0, 16);
          const decrypted = await globalThis.crypto.subtle.decrypt({
            name: "AES-CBC",
            iv: ivBytes
          }, await importRawKey({
            key: keyBytes,
            algorithm: "AES-CBC",
            mode: ["decrypt"]
          }), data);
          return Buffer.from(decrypted);
        }
      } else if (version === 2) {
        const iv = data.subarray(0, 12);
        const encData = data.subarray(12);
        const keyBytes = Buffer.from(key, "utf-8");
        const decrypted = await globalThis.crypto.subtle.decrypt({
          name: "AES-GCM",
          iv
        }, await importRawKey({
          key: keyBytes,
          algorithm: "AES-GCM",
          mode: ["decrypt"]
        }), encData);
        return Buffer.from(decrypted);
      }
    }
    throw new Error(`crypto.decrypt.data not implemented for ${environment} environment`);
  }
  /**
   * Decrypt a file/chunk using streams. Only available in a Node.JS environment.
   * @date 2/7/2024 - 1:38:12 AM
   *
   * @public
   * @async
   * @param {{
   * 		inputFile: string
   * 		key: string
   * 		version: FileEncryptionVersion
   * 		outputFile?: string
   * 	}} param0
   * @param {string} param0.inputFile
   * @param {string} param0.key
   * @param {FileEncryptionVersion} param0.version
   * @param {string} param0.outputFile
   * @returns {Promise<string>}
   */
  async dataStream({ inputFile, key, version, outputFile }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    if (environment !== "node") {
      throw new Error(`crypto.decrypt.dataStream not implemented for ${environment} environment`);
    }
    let input = normalizePath(inputFile);
    const output = normalizePath(outputFile ? outputFile : import_path3.default.join(this.config.tmpPath, await uuidv4()));
    if (!await import_fs_extra5.default.exists(input)) {
      throw new Error("Input file does not exist.");
    }
    await import_fs_extra5.default.rm(output, {
      force: true,
      maxRetries: 60 * 10,
      recursive: true,
      retryDelay: 100
    });
    const inputStat = await import_fs_extra5.default.stat(input);
    if (inputStat.size < (version === 1 ? 17 : 13)) {
      throw new Error(`Input file size too small: ${inputStat.size}.`);
    }
    let inputHandle = await import_fs_extra5.default.open(input, import_fs_extra5.default.constants.R_OK);
    let decipher;
    let bytesToSkipAtStartOfInputStream = 0;
    let bytesToSkipAtEndOfInputStream = 0;
    let inputFileSize = 0;
    try {
      if (version === 1) {
        const firstBytes = Buffer.alloc(16);
        await import_fs_extra5.default.read(inputHandle, firstBytes, 0, 16, 0);
        if (firstBytes.byteLength === 0) {
          throw new Error("Could not read input file.");
        }
        const asciiString = firstBytes.toString("ascii");
        const base64String = firstBytes.toString("base64");
        const utf8String = firstBytes.toString("utf-8");
        let needsConvert = true;
        let isCBC = true;
        if (asciiString.startsWith("Salted_") || base64String.startsWith("Salted_") || utf8String.startsWith("Salted_")) {
          needsConvert = false;
        }
        if (asciiString.startsWith("Salted_") || base64String.startsWith("Salted_") || utf8String.startsWith("U2FsdGVk") || asciiString.startsWith("U2FsdGVk") || utf8String.startsWith("Salted_") || base64String.startsWith("U2FsdGVk")) {
          isCBC = false;
        }
        if (needsConvert && !isCBC) {
          const inputConverted = import_path3.default.join(import_path3.default.dirname(output), await uuidv4());
          await import_fs_extra5.default.rm(inputConverted, {
            force: true,
            maxRetries: 60 * 10,
            recursive: true,
            retryDelay: 100
          });
          await import_fs_extra5.default.close(inputHandle);
          const oldInput = `${input}`;
          input = await streamDecodeBase64({ inputFile: input, outputFile: inputConverted });
          inputHandle = await import_fs_extra5.default.open(input, import_fs_extra5.default.constants.R_OK);
          await import_fs_extra5.default.rm(oldInput, {
            force: true,
            maxRetries: 60 * 10,
            recursive: true,
            retryDelay: 100
          });
        }
        if (!isCBC) {
          const saltBytes = Buffer.alloc(8);
          await import_fs_extra5.default.read(inputHandle, saltBytes, 0, 8, 8);
          const { key: keyBytes, iv: ivBytes } = EVP_BytesToKey({
            password: Buffer.from(key, "utf-8"),
            salt: saltBytes,
            keyBits: 256,
            ivLength: 16
          });
          decipher = import_crypto4.default.createDecipheriv("aes-256-cbc", keyBytes, ivBytes);
          bytesToSkipAtStartOfInputStream = 16;
          bytesToSkipAtEndOfInputStream = 0;
        } else {
          const keyBytes = Buffer.from(key, "utf-8");
          const ivBytes = keyBytes.subarray(0, 16);
          decipher = import_crypto4.default.createDecipheriv("aes-256-cbc", keyBytes, ivBytes);
          bytesToSkipAtStartOfInputStream = 0;
          bytesToSkipAtEndOfInputStream = 0;
        }
      } else if (version === 2) {
        const keyBytes = Buffer.from(key, "utf-8");
        const ivBytes = Buffer.alloc(12);
        const authTagBytes = Buffer.alloc(16);
        const stat = await import_fs_extra5.default.stat(input);
        await Promise.all([import_fs_extra5.default.read(inputHandle, ivBytes, 0, 12, 0), import_fs_extra5.default.read(inputHandle, authTagBytes, 0, 16, stat.size - 16)]);
        if (ivBytes.byteLength === 0 || authTagBytes.byteLength === 0) {
          throw new Error("Could not read input file.");
        }
        decipher = import_crypto4.default.createDecipheriv("aes-256-gcm", keyBytes, ivBytes).setAuthTag(authTagBytes);
        bytesToSkipAtStartOfInputStream = 12;
        bytesToSkipAtEndOfInputStream = 16;
        inputFileSize = stat.size;
      } else {
        throw new Error(`Invalid FileEncryptionVersion: ${version}`);
      }
    } finally {
      await import_fs_extra5.default.close(inputHandle);
    }
    const readStream = import_fs_extra5.default.createReadStream(normalizePath(input), {
      highWaterMark: BUFFER_SIZE,
      end: inputFileSize > 0 && bytesToSkipAtEndOfInputStream > 0 ? inputFileSize - bytesToSkipAtEndOfInputStream - 1 : Infinity,
      start: bytesToSkipAtStartOfInputStream
    });
    const writeStream = import_fs_extra5.default.createWriteStream(normalizePath(output));
    await pipelineAsync4(readStream, decipher, writeStream);
    return output;
  }
  /**
   * Decrypt a user event.
   *
   * @public
   * @async
   * @param {{ event: UserEvent }} param0
   * @param {UserEvent} param0.event
   * @returns {Promise<UserEvent>}
   */
  async event({ event }) {
    if (event.type === "fileUploaded" || event.type === "versionedFileRestored" || event.type === "fileMoved" || event.type === "fileTrash" || event.type === "fileRm" || event.type === "fileRestored" || event.type === "fileLinkEdited" || event.type === "fileVersioned" || event.type === "deleteFilePermanently") {
      const metadataDecrypted = await this.fileMetadata({ metadata: event.info.metadata });
      return {
        ...event,
        info: {
          ...event.info,
          metadataDecrypted: metadataDecrypted.name.length > 0 ? metadataDecrypted : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`,
            size: 1,
            lastModified: Date.now(),
            key: "",
            creation: void 0,
            hash: void 0,
            mime: "application/octet-stream"
          }
        }
      };
    } else if (event.type === "fileRenamed") {
      const [decryptedMetadata, oldDecryptedMetadata] = await Promise.all([
        this.fileMetadata({ metadata: event.info.metadata }),
        this.fileMetadata({ metadata: event.info.oldMetadata })
      ]);
      return {
        ...event,
        info: {
          ...event.info,
          metadataDecrypted: decryptedMetadata.name.length > 0 ? decryptedMetadata : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`,
            size: 1,
            lastModified: Date.now(),
            key: "",
            creation: void 0,
            hash: void 0,
            mime: "application/octet-stream"
          },
          oldMetadataDecrypted: oldDecryptedMetadata.name.length > 0 ? oldDecryptedMetadata : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`,
            size: 1,
            lastModified: Date.now(),
            key: "",
            creation: void 0,
            hash: void 0,
            mime: "application/octet-stream"
          }
        }
      };
    } else if (event.type === "fileShared") {
      const metadataDecrypted = await this.fileMetadata({ metadata: event.info.metadata });
      return {
        ...event,
        info: {
          ...event.info,
          metadataDecrypted: metadataDecrypted.name.length > 0 ? metadataDecrypted : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`,
            size: 1,
            lastModified: Date.now(),
            key: "",
            creation: void 0,
            hash: void 0,
            mime: "application/octet-stream"
          }
        }
      };
    } else if (event.type === "subFolderCreated" || event.type === "folderTrash" || event.type === "folderMoved" || event.type === "baseFolderCreated" || event.type === "folderRestored" || event.type === "folderColorChanged" || event.type === "deleteFolderPermanently") {
      const nameDecrypted = await this.folderMetadata({ metadata: event.info.name });
      return {
        ...event,
        info: {
          ...event.info,
          nameDecrypted: nameDecrypted.name.length > 0 ? nameDecrypted : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`
          }
        }
      };
    } else if (event.type === "folderShared") {
      const nameDecrypted = await this.folderMetadata({ metadata: event.info.name });
      return {
        ...event,
        info: {
          ...event.info,
          nameDecrypted: nameDecrypted.name.length > 0 ? nameDecrypted : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`
          }
        }
      };
    } else if (event.type === "itemFavorite") {
      const [folderDecrypted, fileDecrypted] = await Promise.all([
        this.folderMetadata({ metadata: event.info.metadata }),
        this.fileMetadata({ metadata: event.info.metadata })
      ]);
      return {
        ...event,
        info: {
          ...event.info,
          metadataDecrypted: fileDecrypted.name.length > 0 ? fileDecrypted : null,
          nameDecrypted: folderDecrypted.name.length > 0 ? folderDecrypted : null
        }
      };
    } else if (event.type === "folderRenamed") {
      const [decryptedMetadata, oldDecryptedMetadata] = await Promise.all([
        this.folderMetadata({ metadata: event.info.name }),
        this.folderMetadata({ metadata: event.info.oldName })
      ]);
      return {
        ...event,
        info: {
          ...event.info,
          nameDecrypted: decryptedMetadata.name.length > 0 ? decryptedMetadata : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`
          },
          oldNameDecrypted: oldDecryptedMetadata.name.length > 0 ? oldDecryptedMetadata : {
            name: `CANNOT_DECRYPT_NAME_${event.uuid}`
          }
        }
      };
    }
    return event;
  }
};
var decrypt_default = Decrypt;

// node_modules/@filen/sdk/dist/browser/crypto/index.js
var Crypto = class {
  /**
   * Creates an instance of Crypto.
   * @date 1/31/2024 - 4:30:23 PM
   *
   * @constructor
   * @public
   * @param {CryptoConfig} params
   */
  constructor(params) {
    __publicField(this, "config");
    __publicField(this, "_encrypt");
    __publicField(this, "_decrypt");
    __publicField(this, "utils", utils_default2);
    this.config = params;
    this._encrypt = new encrypt_default(this.config);
    this._decrypt = new decrypt_default(this.config);
  }
  /**
   * Returns an Encrypt instance.
   * @date 1/31/2024 - 4:30:26 PM
   *
   * @public
   * @returns {Encrypt}
   */
  encrypt() {
    return this._encrypt;
  }
  /**
   * Returns a Decrypt instance.
   * @date 1/31/2024 - 4:30:44 PM
   *
   * @public
   * @returns {Decrypt}
   */
  decrypt() {
    return this._decrypt;
  }
};
var crypto_default = Crypto;

// node_modules/@filen/sdk/dist/browser/index.js
var import_os4 = __toESM(require_os());

// node_modules/@filen/sdk/dist/browser/fs/index.js
var import_path4 = __toESM(require_path());

// node_modules/@filen/sdk/dist/browser/fs/errors.js
var ENOENT = class _ENOENT extends Error {
  /**
   * Creates an instance of ENOENT.
   * @date 2/9/2024 - 6:51:15 AM
   *
   * @constructor
   * @public
   * @param {{path: string}} param0
   * @param {string} param0.path
   */
  constructor({ path }) {
    super(`ENOENT: no such file or directory, open '${path}'`);
    __publicField(this, "errno");
    __publicField(this, "syscall");
    __publicField(this, "path");
    __publicField(this, "code");
    this.name = "FileNotFoundError";
    this.code = "ENOENT";
    this.errno = -2;
    this.syscall = "open";
    this.path = path;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _ENOENT);
    }
  }
};

// node_modules/@filen/sdk/dist/browser/fs/index.js
var import_fs_extra6 = __toESM(require_lib());
var import_os2 = __toESM(require_os());

// node_modules/@filen/sdk/dist/browser/socket/index.js
var import_socket = __toESM(require_lib3());
var import_events2 = __toESM(require_events());
var SOCKET_DEFAULTS = {
  url: "https://socket.filen.io"
};
var Socket = class extends import_events2.EventEmitter {
  /**
   * Creates an instance of Socket.
   * @date 3/1/2024 - 6:53:53 PM
   *
   * @constructor
   * @public
   */
  constructor() {
    super();
    __publicField(this, "socket", null);
    __publicField(this, "pingInterval", 0);
    __publicField(this, "apiKey", "");
    __publicField(this, "emitSocketAuthed", false);
  }
  /**
   * Connect to the realtime socket gateway.
   * @date 3/1/2024 - 6:53:57 PM
   *
   * @public
   * @param {{ apiKey: string }} param0
   * @param {string} param0.apiKey
   */
  connect({ apiKey }) {
    if (this.socket || this.isConnected() || apiKey.length < 32 || apiKey === "anonymous") {
      return;
    }
    this.apiKey = apiKey;
    this.socket = null;
    this.socket = (0, import_socket.default)(SOCKET_DEFAULTS.url, {
      path: "",
      reconnect: true,
      reconnection: true,
      transports: ["websocket"],
      upgrade: false
    });
    this.socket.on("connect", async () => {
      var _a, _b;
      this.emit("connected");
      (_a = this.socket) == null ? void 0 : _a.emit("auth", {
        apiKey: this.apiKey
      });
      this.emitSocketAuthed = true;
      (_b = this.socket) == null ? void 0 : _b.emit("authed", Date.now());
      this.pingInterval = setInterval(() => {
        var _a2;
        (_a2 = this.socket) == null ? void 0 : _a2.emit("authed", Date.now());
      }, 15e3);
    });
    this.socket.on("authFailed", () => {
      this.emit("autFailed");
    });
    this.socket.on("authed", async (authed) => {
      var _a;
      if (!authed) {
        (_a = this.socket) == null ? void 0 : _a.emit("auth", {
          apiKey: this.apiKey
        });
        this.emitSocketAuthed = true;
      } else {
        if (this.emitSocketAuthed) {
          this.emitSocketAuthed = false;
          this.emit("socketAuthed");
        }
      }
    });
    this.socket.on("disconnect", () => {
      this.emit("disconnected");
      clearInterval(this.pingInterval);
    });
    this.socket.on("new-event", (data) => {
      this.emit("socketEvent", {
        type: "newEvent",
        data
      });
    });
    this.socket.on("newEvent", (data) => {
      this.emit("socketEvent", {
        type: "newEvent",
        data
      });
    });
    this.socket.on("file-rename", (data) => {
      this.emit("socketEvent", {
        type: "fileRename",
        data
      });
    });
    this.socket.on("fileRename", (data) => {
      this.emit("socketEvent", {
        type: "fileRename",
        data
      });
    });
    this.socket.on("file-archive-restored", (data) => {
      this.emit("socketEvent", {
        type: "fileArchiveRestored",
        data
      });
    });
    this.socket.on("fileArchiveRestored", (data) => {
      this.emit("socketEvent", {
        type: "fileArchiveRestored",
        data
      });
    });
    this.socket.on("file-new", (data) => {
      this.emit("socketEvent", {
        type: "fileNew",
        data
      });
    });
    this.socket.on("fileNew", (data) => {
      this.emit("socketEvent", {
        type: "fileNew",
        data
      });
    });
    this.socket.on("file-move", (data) => {
      this.emit("socketEvent", {
        type: "fileMove",
        data
      });
    });
    this.socket.on("fileMove", (data) => {
      this.emit("socketEvent", {
        type: "fileMove",
        data
      });
    });
    this.socket.on("file-trash", (data) => {
      this.emit("socketEvent", {
        type: "fileTrash",
        data
      });
    });
    this.socket.on("fileTrash", (data) => {
      this.emit("socketEvent", {
        type: "fileTrash",
        data
      });
    });
    this.socket.on("file-archived", (data) => {
      this.emit("socketEvent", {
        type: "fileArchived",
        data
      });
    });
    this.socket.on("fileArchived", (data) => {
      this.emit("socketEvent", {
        type: "fileArchived",
        data
      });
    });
    this.socket.on("folder-rename", (data) => {
      this.emit("socketEvent", {
        type: "folderRename",
        data
      });
    });
    this.socket.on("folderRename", (data) => {
      this.emit("socketEvent", {
        type: "folderRename",
        data
      });
    });
    this.socket.on("folder-trash", (data) => {
      this.emit("socketEvent", {
        type: "folderTrash",
        data
      });
    });
    this.socket.on("folderTrash", (data) => {
      this.emit("socketEvent", {
        type: "folderTrash",
        data
      });
    });
    this.socket.on("folder-move", (data) => {
      this.emit("socketEvent", {
        type: "folderMove",
        data
      });
    });
    this.socket.on("folderMove", (data) => {
      this.emit("socketEvent", {
        type: "folderMove",
        data
      });
    });
    this.socket.on("folder-sub-created", (data) => {
      this.emit("socketEvent", {
        type: "folderSubCreated",
        data
      });
    });
    this.socket.on("folderSubCreated", (data) => {
      this.emit("socketEvent", {
        type: "folderSubCreated",
        data
      });
    });
    this.socket.on("folder-restore", (data) => {
      this.emit("socketEvent", {
        type: "folderRestore",
        data
      });
    });
    this.socket.on("folderRestore", (data) => {
      this.emit("socketEvent", {
        type: "folderRestore",
        data
      });
    });
    this.socket.on("folder-color-changed", (data) => {
      this.emit("socketEvent", {
        type: "folderColorChanged",
        data
      });
    });
    this.socket.on("folderColorChanged", (data) => {
      this.emit("socketEvent", {
        type: "folderColorChanged",
        data
      });
    });
    this.socket.on("trash-empty", () => {
      this.emit("socketEvent", {
        type: "trashEmpty"
      });
    });
    this.socket.on("trashEmpty", () => {
      this.emit("socketEvent", {
        type: "trashEmpty"
      });
    });
    this.socket.on("passwordChanged", () => {
      this.emit("socketEvent", {
        type: "passwordChanged"
      });
    });
    this.socket.on("chatMessageNew", (data) => {
      this.emit("socketEvent", {
        type: "chatMessageNew",
        data
      });
    });
    this.socket.on("chatTyping", (data) => {
      this.emit("socketEvent", {
        type: "chatTyping",
        data
      });
    });
    this.socket.on("chatMessageDelete", (data) => {
      this.emit("socketEvent", {
        type: "chatMessageDelete",
        data
      });
    });
    this.socket.on("chatMessageEmbedDisabled", (data) => {
      this.emit("socketEvent", {
        type: "chatMessageEmbedDisabled",
        data
      });
    });
    this.socket.on("noteContentEdited", (data) => {
      this.emit("socketEvent", {
        type: "noteContentEdited",
        data
      });
    });
    this.socket.on("noteArchived", (data) => {
      this.emit("socketEvent", {
        type: "noteArchived",
        data
      });
    });
    this.socket.on("noteDeleted", (data) => {
      this.emit("socketEvent", {
        type: "noteDeleted",
        data
      });
    });
    this.socket.on("noteTitleEdited", (data) => {
      this.emit("socketEvent", {
        type: "noteTitleEdited",
        data
      });
    });
    this.socket.on("noteParticipantPermissions", (data) => {
      this.emit("socketEvent", {
        type: "noteParticipantPermissions",
        data
      });
    });
    this.socket.on("noteRestored", (data) => {
      this.emit("socketEvent", {
        type: "noteRestored",
        data
      });
    });
    this.socket.on("noteParticipantRemoved", (data) => {
      this.emit("socketEvent", {
        type: "noteParticipantRemoved",
        data
      });
    });
    this.socket.on("noteParticipantNew", (data) => {
      this.emit("socketEvent", {
        type: "noteParticipantNew",
        data
      });
    });
    this.socket.on("noteNew", (data) => {
      this.emit("socketEvent", {
        type: "noteNew",
        data
      });
    });
    this.socket.on("chatMessageEdited", (data) => {
      this.emit("socketEvent", {
        type: "chatMessageEdited",
        data
      });
    });
    this.socket.on("chatConversationNameEdited", (data) => {
      this.emit("socketEvent", {
        type: "chatConversationNameEdited",
        data
      });
    });
    this.socket.on("chatConversationDeleted", (data) => {
      this.emit("socketEvent", {
        type: "chatConversationDeleted",
        data
      });
    });
    this.socket.on("chatConversationParticipantLeft", (data) => {
      this.emit("socketEvent", {
        type: "chatConversationParticipantLeft",
        data
      });
    });
    this.socket.on("chatConversationsNew", (data) => {
      this.emit("socketEvent", {
        type: "chatConversationsNew",
        data
      });
    });
    this.socket.on("file-restore", (data) => {
      this.emit("socketEvent", {
        type: "fileRestore",
        data
      });
    });
    this.socket.on("fileRestore", (data) => {
      this.emit("socketEvent", {
        type: "fileRestore",
        data
      });
    });
    this.socket.on("contactRequestReceived", (data) => {
      this.emit("socketEvent", {
        type: "contactRequestReceived",
        data
      });
    });
    this.socket.on("item-favorite", (data) => {
      this.emit("socketEvent", {
        type: "itemFavorite",
        data
      });
    });
    this.socket.on("chatConversationParticipantNew", (data) => {
      this.emit("socketEvent", {
        type: "chatConversationParticipantNew",
        data
      });
    });
    this.socket.on("file-deleted-permanent", (data) => {
      this.emit("socketEvent", {
        type: "fileDeletedPermanent",
        data
      });
    });
  }
  /**
   * Disconnect from the realtime socket gateway.
   * @date 3/1/2024 - 6:54:17 PM
   *
   * @public
   */
  disconnect() {
    if (!this.socket) {
      return;
    }
    this.socket.disconnect();
  }
  /**
   * Check connection status.
   * @date 3/1/2024 - 6:54:29 PM
   *
   * @public
   * @returns {boolean}
   */
  isConnected() {
    if (!this.socket) {
      return false;
    }
    return this.socket.connected;
  }
};
var socket_default = Socket;

// node_modules/@filen/sdk/dist/browser/semaphore.js
var Semaphore = function(max) {
  let counter = 0;
  let waiting = [];
  let maxCount = max || 1;
  const take = function() {
    if (waiting.length > 0 && counter < maxCount) {
      counter++;
      const promise = waiting.shift();
      if (!promise) {
        return;
      }
      promise.resolve();
    }
  };
  this.acquire = function() {
    if (counter < maxCount) {
      counter++;
      return new Promise((resolve) => {
        resolve();
      });
    } else {
      return new Promise((resolve, err) => {
        waiting.push({
          resolve,
          err
        });
      });
    }
  };
  this.release = function() {
    if (counter <= 0) {
      return;
    }
    counter--;
    take();
  };
  this.count = function() {
    return counter;
  };
  this.setMax = function(newMax) {
    maxCount = newMax;
  };
  this.purge = function() {
    const unresolved = waiting.length;
    for (let i = 0; i < unresolved; i++) {
      const w = waiting[i];
      if (w) {
        w.err("Task has been purged");
      }
    }
    counter = 0;
    waiting = [];
    return unresolved;
  };
};

// node_modules/@filen/sdk/dist/browser/fs/index.js
var import_write_file_atomic = __toESM(require_lib4());
var FS = class {
  /**
   * Creates an instance of FS.
   * @date 2/9/2024 - 5:54:11 AM
   *
   * @constructor
   * @public
   * @param {FSConfig} params
   */
  constructor(params) {
    __publicField(this, "api");
    __publicField(this, "sdkConfig");
    __publicField(this, "cloud");
    __publicField(this, "_items");
    __publicField(this, "_uuidToItem");
    __publicField(this, "socket", new Socket());
    __publicField(this, "mutex", new Semaphore(1));
    __publicField(this, "mkdirMutex", new Semaphore(1));
    __publicField(this, "itemsMutex", new Semaphore(1));
    this.api = params.api;
    this.sdkConfig = params.sdkConfig;
    this.cloud = params.cloud;
    this._items = {
      "/": {
        uuid: this.sdkConfig.baseFolderUUID,
        type: "directory",
        metadata: {
          name: "Cloud Drive",
          timestamp: Date.now()
        }
      }
    };
    this._uuidToItem = {
      [this.sdkConfig.baseFolderUUID]: {
        uuid: this.sdkConfig.baseFolderUUID,
        type: "directory",
        path: "/",
        metadata: {
          name: "Cloud Drive",
          timestamp: Date.now()
        }
      }
    };
    this._initSocketEvents(params.connectToSocket).catch(() => {
    });
  }
  /**
   * Wait for an API key (login) to become available
   *
   * @private
   * @async
   * @returns {Promise<string>}
   */
  async waitForValidAPIKey() {
    if (this.sdkConfig.apiKey && this.sdkConfig.apiKey.length >= 16) {
      return this.sdkConfig.apiKey;
    }
    return await new Promise((resolve) => {
      const interval = setInterval(() => {
        if (this.sdkConfig.apiKey && this.sdkConfig.apiKey.length >= 16) {
          clearInterval(interval);
          resolve(this.sdkConfig.apiKey);
        }
      }, 250);
    });
  }
  /**
   * Attach listeners for relevant realtime events.
   *
   * @private
   * @async
   * @param {?boolean} [connect]
   * @returns {Promise<void>}
   */
  async _initSocketEvents(connect) {
    if (!connect) {
      return;
    }
    const apiKey = await this.waitForValidAPIKey();
    this.socket.connect({ apiKey });
    this.socket.addListener("socketEvent", async (event) => {
      await this.itemsMutex.acquire();
      try {
        if (event.type === "fileArchiveRestored") {
          const currentItem = this._uuidToItem[event.data.currentUUID];
          const item = this._uuidToItem[event.data.uuid];
          if (currentItem) {
            delete this._items[currentItem.path];
            delete this._uuidToItem[event.data.currentUUID];
          }
          if (item) {
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "fileRename") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "fileMove") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "fileTrash") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "fileArchived") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "folderTrash") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            for (const path in this._items) {
              if (path.startsWith(item.path + "/") || item.path === path) {
                const oldItem = this._items[path];
                if (oldItem) {
                  delete this._uuidToItem[oldItem.uuid];
                }
                delete this._items[path];
              }
            }
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "fileDeletedPermanent") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "folderMove") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            for (const path in this._items) {
              if (path.startsWith(item.path + "/") || item.path === path) {
                const oldItem = this._items[path];
                if (oldItem) {
                  delete this._uuidToItem[oldItem.uuid];
                }
                delete this._items[path];
              }
            }
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "folderRename") {
          const item = this._uuidToItem[event.data.uuid];
          if (item) {
            for (const path in this._items) {
              if (path.startsWith(item.path + "/") || item.path === path) {
                const oldItem = this._items[path];
                if (oldItem) {
                  delete this._uuidToItem[oldItem.uuid];
                }
                delete this._items[path];
              }
            }
            delete this._items[item.path];
            delete this._uuidToItem[event.data.uuid];
          }
        } else if (event.type === "passwordChanged") {
          this._items = {};
          this._uuidToItem = {};
        }
      } catch {
      } finally {
        this.itemsMutex.release();
      }
    });
  }
  /**
   * Add an item to the internal item tree.
   *
   * @public
   * @async
   * @param {{ path: string; item: FSItem }} param0
   * @param {string} param0.path
   * @param {(Prettify<(FSItemBase & { type: "directory"; metadata: FolderMetadata; }) | (FSItemBase & { type: "file"; metadata: Prettify<any>; })>)} param0.item
   * @returns {Promise<void>}
   */
  async _addItem({ path, item }) {
    await this.itemsMutex.acquire();
    this._items[path] = item;
    this._uuidToItem[item.uuid] = {
      ...item,
      path
    };
    this.itemsMutex.release();
  }
  /**
   * Remove an item from the internal item tree.
   *
   * @public
   * @async
   * @param {{ path: string }} param0
   * @param {string} param0.path
   * @returns {Promise<void>}
   */
  async _removeItem({ path }) {
    await this.itemsMutex.acquire();
    for (const entry in this._items) {
      if (entry.startsWith(path + "/") || entry === path) {
        const item = this._items[entry];
        if (item) {
          delete this._uuidToItem[item.uuid];
        }
        delete this._items[entry];
      }
    }
    this.itemsMutex.release();
  }
  /**
   * Normalizes a path to be used with FS.
   * @date 2/14/2024 - 12:50:52 AM
   *
   * @private
   * @param {{ path: string }} param0
   * @param {string} param0.path
   * @returns {string}
   */
  normalizePath({ path }) {
    path = import_path4.default.posix.normalize(path);
    if (path.endsWith("/")) {
      path = path.substring(0, path.length - 1);
    }
    if (!path.startsWith("/")) {
      path = "/" + path;
    }
    return path;
  }
  async pathToItemUUID({ path, type }) {
    path = this.normalizePath({ path });
    const acceptedTypes = !type ? ["directory", "file"] : type === "directory" ? ["directory"] : ["file"];
    if (path === "/") {
      return this.sdkConfig.baseFolderUUID;
    }
    const item = this._items[path];
    if (item && acceptedTypes.includes(item.type)) {
      return item.uuid;
    }
    const pathEx = path.split("/");
    let builtPath = "/";
    for (const part of pathEx) {
      if (pathEx.length <= 0) {
        continue;
      }
      builtPath = import_path4.default.posix.join(builtPath, part);
      const parentDirname = import_path4.default.posix.dirname(builtPath);
      const parentItem = this._items[parentDirname];
      if (!parentItem) {
        return null;
      }
      const content = await this.cloud.listDirectory({ uuid: parentItem.uuid });
      let foundUUID = "";
      let foundType = null;
      for (const item2 of content) {
        const itemPath = import_path4.default.posix.join(parentDirname, item2.name);
        if (itemPath === path) {
          foundUUID = item2.uuid;
          foundType = item2.type;
        }
        await this.itemsMutex.acquire();
        if (item2.type === "directory") {
          this._items[itemPath] = {
            uuid: item2.uuid,
            type: "directory",
            metadata: {
              name: item2.name,
              timestamp: item2.timestamp
            }
          };
          this._uuidToItem[item2.uuid] = {
            uuid: item2.uuid,
            type: "directory",
            path: itemPath,
            metadata: {
              name: item2.name,
              timestamp: item2.timestamp
            }
          };
        } else {
          this._items[itemPath] = {
            uuid: item2.uuid,
            type: "file",
            metadata: {
              name: item2.name,
              size: item2.size,
              mime: item2.mime,
              key: item2.key,
              lastModified: item2.lastModified,
              chunks: item2.chunks,
              region: item2.region,
              bucket: item2.bucket,
              version: item2.version
            }
          };
          this._uuidToItem[item2.uuid] = {
            uuid: item2.uuid,
            type: "file",
            path: itemPath,
            metadata: {
              name: item2.name,
              size: item2.size,
              mime: item2.mime,
              key: item2.key,
              lastModified: item2.lastModified,
              chunks: item2.chunks,
              region: item2.region,
              bucket: item2.bucket,
              version: item2.version
            }
          };
        }
        this.itemsMutex.release();
      }
      if (foundType && foundUUID.length > 0 && acceptedTypes.includes(foundType)) {
        return foundUUID;
      }
    }
    const foundItem = this._items[path];
    if (foundItem && acceptedTypes.includes(foundItem.type)) {
      return foundItem.uuid;
    }
    return null;
  }
  /**
   * List files and directories at path.
   * @date 2/20/2024 - 2:40:03 AM
   *
   * @public
   * @async
   * @param {{ path: string, recursive?: boolean }} param0
   * @param {string} param0.path
   * @param {boolean} [param0.recursive=false]
   * @returns {Promise<string[]>}
   */
  async readdir({ path, recursive = false }) {
    path = this.normalizePath({ path });
    const uuid = await this.pathToItemUUID({
      path,
      type: "directory"
    });
    if (!uuid) {
      throw new ENOENT({ path });
    }
    const names = [];
    const existingPaths = {};
    if (recursive) {
      const tree = await this.cloud.getDirectoryTree({ uuid });
      for (const entry in tree) {
        const item = tree[entry];
        const entryPath = entry.startsWith("/") ? entry.substring(1) : entry;
        const lowercasePath = entryPath.toLowerCase();
        if (!item || item.parent === "base" || existingPaths[lowercasePath]) {
          continue;
        }
        existingPaths[lowercasePath] = true;
        const itemPath = import_path4.default.posix.join(path, entryPath);
        names.push(entryPath);
        await this.itemsMutex.acquire();
        if (item.type === "directory") {
          this._items[itemPath] = {
            uuid: item.uuid,
            type: "directory",
            metadata: {
              name: item.name,
              timestamp: item.timestamp
            }
          };
          this._uuidToItem[item.uuid] = {
            uuid: item.uuid,
            type: "directory",
            path: itemPath,
            metadata: {
              name: item.name,
              timestamp: item.timestamp
            }
          };
        } else {
          this._items[itemPath] = {
            uuid: item.uuid,
            type: "file",
            metadata: {
              name: item.name,
              size: item.size,
              mime: item.mime,
              key: item.key,
              lastModified: item.lastModified,
              chunks: item.chunks,
              region: item.region,
              bucket: item.bucket,
              version: item.version
            }
          };
          this._uuidToItem[item.uuid] = {
            uuid: item.uuid,
            type: "file",
            path: itemPath,
            metadata: {
              name: item.name,
              size: item.size,
              mime: item.mime,
              key: item.key,
              lastModified: item.lastModified,
              chunks: item.chunks,
              region: item.region,
              bucket: item.bucket,
              version: item.version
            }
          };
        }
        this.itemsMutex.release();
      }
      return names.sort((a, b) => a.localeCompare(b, "en", { numeric: true }));
    }
    const items = (await this.cloud.listDirectory({ uuid })).sort((a, b) => a.name.localeCompare(b.name, "en", { numeric: true }));
    for (const item of items) {
      const itemPath = import_path4.default.posix.join(path, item.name);
      const lowercasePath = itemPath.toLowerCase();
      if (existingPaths[lowercasePath]) {
        continue;
      }
      existingPaths[lowercasePath] = true;
      names.push(item.name);
      await this.itemsMutex.acquire();
      if (item.type === "directory") {
        this._items[itemPath] = {
          uuid: item.uuid,
          type: "directory",
          metadata: {
            name: item.name,
            timestamp: item.timestamp
          }
        };
        this._uuidToItem[item.uuid] = {
          uuid: item.uuid,
          type: "directory",
          path: itemPath,
          metadata: {
            name: item.name,
            timestamp: item.timestamp
          }
        };
      } else {
        this._items[itemPath] = {
          uuid: item.uuid,
          type: "file",
          metadata: {
            name: item.name,
            size: item.size,
            mime: item.mime,
            key: item.key,
            lastModified: item.lastModified,
            chunks: item.chunks,
            region: item.region,
            bucket: item.bucket,
            version: item.version
          }
        };
        this._uuidToItem[item.uuid] = {
          uuid: item.uuid,
          type: "file",
          path: itemPath,
          metadata: {
            name: item.name,
            size: item.size,
            mime: item.mime,
            key: item.key,
            lastModified: item.lastModified,
            chunks: item.chunks,
            region: item.region,
            bucket: item.bucket,
            version: item.version
          }
        };
      }
      this.itemsMutex.release();
    }
    return names;
  }
  /**
   * Alias of readdir.
   * @date 2/13/2024 - 8:48:40 PM
   *
   * @public
   * @async
   * @param {...Parameters<typeof this.readdir>} params
   * @returns {Promise<string[]>}
   */
  async ls(...params) {
    return await this.readdir(...params);
  }
  async stat({ path }) {
    path = this.normalizePath({ path });
    const uuid = await this.pathToItemUUID({ path });
    const item = this._items[path];
    if (!uuid || !item) {
      throw new ENOENT({ path });
    }
    const now = Date.now();
    if (item.type === "file") {
      return {
        ...item.metadata,
        uuid,
        size: item.metadata.size,
        mtimeMs: item.metadata.lastModified,
        birthtimeMs: item.metadata.creation ?? now,
        type: "file",
        isDirectory() {
          return false;
        },
        isFile() {
          return true;
        }
      };
    }
    return {
      name: item.metadata.name,
      uuid,
      size: 0,
      mtimeMs: item.metadata.timestamp ?? now,
      birthtimeMs: item.metadata.timestamp ?? now,
      type: "directory",
      isDirectory() {
        return true;
      },
      isFile() {
        return false;
      }
    };
  }
  /**
   * Alias of stat.
   * @date 2/13/2024 - 8:49:18 PM
   *
   * @public
   * @async
   * @param {...Parameters<typeof this.stat>} params
   * @returns {Promise<FSStats>}
   */
  async lstat(...params) {
    return await this.stat(...params);
  }
  /**
   * Creates a directory at path. Recursively creates intermediate directories if they don't exist.
   * @date 2/14/2024 - 1:34:11 AM
   *
   * @public
   * @async
   * @param {{ path: string }} param0
   * @param {string} param0.path
   * @returns {Promise<string>}
   */
  async mkdir({ path }) {
    await this.mkdirMutex.acquire();
    try {
      path = this.normalizePath({ path });
      if (path === "/") {
        return this.sdkConfig.baseFolderUUID;
      }
      const exists = await this.pathToItemUUID({ path });
      if (exists) {
        return exists;
      }
      const parentPath = import_path4.default.posix.dirname(path);
      const basename = import_path4.default.posix.basename(path);
      if (parentPath === "/" || parentPath === "." || parentPath === "") {
        const uuid = await this.cloud.createDirectory({ name: basename, parent: this.sdkConfig.baseFolderUUID });
        await this.itemsMutex.acquire();
        this._items[path] = {
          uuid,
          type: "directory",
          metadata: {
            name: basename,
            timestamp: Date.now()
          }
        };
        this._uuidToItem[uuid] = {
          uuid,
          type: "directory",
          path,
          metadata: {
            name: basename,
            timestamp: Date.now()
          }
        };
        this.itemsMutex.release();
        return uuid;
      }
      const pathEx = path.split("/");
      let builtPath = "/";
      for (const part of pathEx) {
        if (pathEx.length <= 0) {
          continue;
        }
        builtPath = import_path4.default.posix.join(builtPath, part);
        if (!this._items[builtPath]) {
          const partBasename = import_path4.default.posix.basename(builtPath);
          const partParentPath = import_path4.default.posix.dirname(builtPath);
          const parentItem = this._items[partParentPath];
          if (!parentItem) {
            continue;
          }
          const parentIsBase = partParentPath === "/" || partParentPath === "." || partParentPath === "";
          const parentUUID = parentIsBase ? this.sdkConfig.baseFolderUUID : parentItem.uuid;
          const uuid = await this.cloud.createDirectory({
            name: partBasename,
            parent: parentUUID
          });
          await this.itemsMutex.acquire();
          this._items[builtPath] = {
            uuid,
            type: "directory",
            metadata: {
              name: partBasename,
              timestamp: Date.now()
            }
          };
          this._uuidToItem[uuid] = {
            uuid,
            type: "directory",
            path: builtPath,
            metadata: {
              name: partBasename,
              timestamp: Date.now()
            }
          };
          this.itemsMutex.release();
        }
      }
      const item = this._items[path];
      if (!item || !this._items[path]) {
        throw new ENOENT({ path });
      }
      return item.uuid;
    } finally {
      this.mkdirMutex.release();
    }
  }
  /**
   * Rename or move a file/directory. Recursively creates intermediate directories if needed.
   * @date 2/14/2024 - 1:39:32 AM
   *
   * @public
   * @async
   * @param {{ from: string; to: string }} param0
   * @param {string} param0.from
   * @param {string} param0.to
   * @returns {Promise<void>}
   */
  async rename({ from, to }) {
    await this.mutex.acquire();
    try {
      from = this.normalizePath({ path: from });
      to = this.normalizePath({ path: to });
      if (from === "/" || from === to) {
        return;
      }
      const uuid = await this.pathToItemUUID({ path: from });
      const item = this._items[from];
      if (!uuid || !item || item.type === "file" && item.metadata.key.length === 0) {
        throw new ENOENT({ path: from });
      }
      const currentParentPath = import_path4.default.posix.dirname(from);
      const newParentPath = import_path4.default.posix.dirname(to);
      const newBasename = import_path4.default.posix.basename(to);
      const oldBasename = import_path4.default.posix.basename(from);
      const itemMetadata = item.type === "file" ? {
        name: newBasename,
        size: item.metadata.size,
        mime: item.metadata.mime,
        lastModified: item.metadata.lastModified,
        creation: item.metadata.creation,
        hash: item.metadata.hash,
        key: item.metadata.key,
        chunks: item.metadata.chunks,
        region: item.metadata.region,
        bucket: item.metadata.bucket,
        version: item.metadata.version
      } : {
        name: newBasename
      };
      if (newParentPath === currentParentPath) {
        if (to === "/" || newBasename.length <= 0) {
          return;
        }
        if (item.type === "directory") {
          await this.cloud.renameDirectory({
            uuid,
            name: newBasename
          });
        } else {
          await this.cloud.renameFile({
            uuid,
            metadata: itemMetadata,
            name: newBasename
          });
        }
      } else {
        if (to.startsWith(from + "/")) {
          return;
        }
        if (oldBasename !== newBasename) {
          if (item.type === "directory") {
            await this.cloud.renameDirectory({
              uuid,
              name: newBasename
            });
          } else {
            await this.cloud.renameFile({
              uuid,
              metadata: itemMetadata,
              name: newBasename
            });
          }
        }
        if (newParentPath === "/" || newParentPath === "." || newParentPath === "") {
          if (item.type === "directory") {
            await this.cloud.moveDirectory({
              uuid,
              to: this.sdkConfig.baseFolderUUID,
              metadata: itemMetadata
            });
          } else {
            await this.cloud.moveFile({
              uuid,
              to: this.sdkConfig.baseFolderUUID,
              metadata: itemMetadata
            });
          }
        } else {
          await this.mkdir({ path: newParentPath });
          const newParentItem = this._items[newParentPath];
          if (!newParentItem) {
            throw new ENOENT({ path: newParentPath });
          }
          if (item.type === "directory") {
            await this.cloud.moveDirectory({
              uuid,
              to: newParentItem.uuid,
              metadata: itemMetadata
            });
          } else {
            await this.cloud.moveFile({
              uuid,
              to: newParentItem.uuid,
              metadata: itemMetadata
            });
          }
        }
      }
      await this.itemsMutex.acquire();
      this._items[to] = {
        ...this._items[from],
        metadata: itemMetadata
      };
      this._uuidToItem[item.uuid] = {
        ...this._uuidToItem[item.uuid],
        path: to,
        metadata: itemMetadata
      };
      delete this._items[from];
      if (item.type === "directory") {
        for (const oldPath in this._items) {
          if (oldPath.startsWith(from + "/") && oldPath !== from) {
            const newPath = replacePathStartWithFromAndTo(oldPath, from, to);
            const oldItem = this._items[oldPath];
            if (oldItem) {
              this._items[newPath] = oldItem;
              delete this._items[oldPath];
              const oldItemUUID = this._uuidToItem[oldItem.uuid];
              if (oldItemUUID) {
                this._uuidToItem[oldItem.uuid] = {
                  ...oldItemUUID,
                  path: newPath
                };
              }
            }
          }
        }
      }
      this.itemsMutex.release();
    } finally {
      this.mutex.release();
    }
  }
  /**
   * Returns filesystem information.
   * @date 2/14/2024 - 2:13:19 AM
   *
   * @public
   * @async
   * @returns {Promise<StatFS>}
   */
  async statfs() {
    const account = await this.api.v3().user().account();
    return {
      type: -1,
      bsize: BUFFER_SIZE,
      blocks: Infinity,
      bfree: Infinity,
      bavail: Infinity,
      files: -1,
      used: account.storage,
      max: account.maxStorage,
      ffree: Infinity
    };
  }
  /**
   * Deletes file/directoy at path.
   * @date 2/28/2024 - 4:57:19 PM
   *
   * @private
   * @async
   * @param {{ path: string; type?: FSItemType, permanent?: boolean }} param0
   * @param {string} param0.path
   * @param {FSItemType} param0.type
   * @param {boolean} [param0.permanent=false]
   * @returns {Promise<void>}
   */
  async _unlink({ path, type, permanent = false }) {
    await this.mutex.acquire();
    try {
      path = this.normalizePath({ path });
      const uuid = await this.pathToItemUUID({ path });
      const item = this._items[path];
      if (!uuid || !item) {
        return;
      }
      const acceptedTypes = !type ? ["directory", "file"] : type === "directory" ? ["directory"] : ["file"];
      if (!acceptedTypes.includes(item.type)) {
        return;
      }
      if (item.type === "directory") {
        if (permanent) {
          await this.cloud.deleteDirectory({ uuid });
        } else {
          await this.cloud.trashDirectory({ uuid });
        }
      } else {
        if (permanent) {
          await this.cloud.deleteFile({ uuid });
        } else {
          await this.cloud.trashFile({ uuid });
        }
      }
      await this.itemsMutex.acquire();
      delete this._uuidToItem[item.uuid];
      delete this._items[path];
      for (const entry in this._items) {
        if (entry.startsWith(path + "/") || entry === path) {
          const entryItem = this._items[entry];
          if (entryItem) {
            delete this._uuidToItem[entryItem.uuid];
          }
          delete this._items[entry];
        }
      }
      this.itemsMutex.release();
    } finally {
      this.mutex.release();
    }
  }
  /**
   * Deletes file/directory at path.
   * @date 2/28/2024 - 4:58:37 PM
   *
   * @public
   * @async
   * @param {{ path: string, permanent?: boolean }} param0
   * @param {string} param0.path
   * @param {boolean} [param0.permanent=false]
   * @returns {Promise<void>}
   */
  async unlink({ path, permanent = false }) {
    return await this._unlink({
      path,
      permanent
    });
  }
  /**
   * Alias of unlink.
   * @date 2/28/2024 - 4:58:30 PM
   *
   * @public
   * @async
   * @param {{ path: string, permanent?: boolean }} param0
   * @param {string} param0.path
   * @param {boolean} [param0.permanent=false]
   * @returns {Promise<void>}
   */
  async rm({ path, permanent = false }) {
    return await this._unlink({
      path,
      permanent
    });
  }
  /**
   * Deletes directory at path.
   * @date 2/14/2024 - 2:53:48 AM
   *
   * @public
   * @async
   * @param {...Parameters<typeof this.unlink>} params
   * @returns {Promise<void>}
   */
  async rmdir(...params) {
    return await this._unlink({
      path: params[0].path,
      type: "directory",
      permanent: params[0].permanent
    });
  }
  /**
   * Deletes a file at path.
   *
   * @public
   * @async
   * @param {...Parameters<typeof this.unlink>} params
   * @returns {Promise<void>}
   */
  async rmfile(...params) {
    return await this._unlink({
      path: params[0].path,
      type: "file",
      permanent: params[0].permanent
    });
  }
  /**
   * Read a file. Returns buffer of given length, at position and offset. Memory efficient to read only a small part of a file.
   *
   * @public
   * @async
   * @param {{
   * 		path: string
   * 		offset?: number
   * 		length?: number
   * 		position?: number
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.path
   * @param {number} param0.offset
   * @param {number} param0.length
   * @param {number} param0.position
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<Buffer>}
   */
  async read({ path, offset, length, position, abortSignal, pauseSignal, onProgress, onProgressId }) {
    path = this.normalizePath({ path });
    const uuid = await this.pathToItemUUID({ path });
    const item = this._items[path];
    if (!uuid || !item || item.type === "directory" || item.type === "file" && item.metadata.key.length === 0) {
      throw new ENOENT({ path });
    }
    if (!position) {
      position = 0;
    }
    if (!length) {
      length = item.metadata.size - 1;
    }
    const stream = this.cloud.downloadFileToReadableStream({
      uuid,
      bucket: item.metadata.bucket,
      region: item.metadata.region,
      size: item.metadata.size,
      chunks: item.metadata.chunks,
      version: item.metadata.version,
      key: item.metadata.key,
      abortSignal,
      pauseSignal,
      onProgress,
      onProgressId,
      start: position,
      end: position + length
    });
    let buffer = Buffer.from([]);
    const reader = stream.getReader();
    let doneReading = false;
    while (!doneReading) {
      const { done, value } = await reader.read();
      if (done) {
        doneReading = true;
        break;
      }
      if (value instanceof Uint8Array && value.byteLength > 0) {
        buffer = Buffer.concat([buffer, value]);
      }
    }
    if (offset) {
      return buffer.subarray(offset, offset + Math.min(buffer.byteLength, length));
    }
    return buffer;
  }
  /**
   * Alias of writeFile.
   * @date 2/20/2024 - 9:45:40 PM
   *
   * @public
   * @async
   * @param {...Parameters<typeof this.writeFile>} params
   * @returns {Promise<CloudItem>}
   */
  async write(...params) {
    return await this.writeFile(...params);
  }
  /**
   * Read a file at path. Warning: This reads the whole file into memory and can be pretty inefficient.
   *
   * @public
   * @async
   * @param {{
   * 		path: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.path
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<Buffer>}
   */
  async readFile({ path, abortSignal, pauseSignal, onProgress, onProgressId }) {
    return await this.read({
      path,
      abortSignal,
      pauseSignal,
      onProgress,
      onProgressId
    });
  }
  /**
   * Write to a file. Warning: This reads the whole file into memory and can be very inefficient. Only available in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		path: string
   * 		content: Buffer
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback,
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.path
   * @param {Buffer} param0.content
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<CloudItem>}
   */
  async writeFile({ path, content, abortSignal, pauseSignal, onProgress, onProgressId }) {
    if (environment !== "node") {
      throw new Error(`fs.writeFile is not implemented for a ${environment} environment`);
    }
    path = this.normalizePath({ path });
    const parentPath = import_path4.default.posix.dirname(path);
    let parentUUID = "";
    const fileName = import_path4.default.posix.basename(path);
    if (fileName.length === 0 || fileName === "." || fileName === "/") {
      throw new Error("Could not parse file name.");
    }
    if (parentPath === "/" || parentPath === "." || parentPath === "") {
      parentUUID = this.sdkConfig.baseFolderUUID;
    } else {
      await this.mkdir({ path: parentPath });
      const parentItemUUID = await this.pathToItemUUID({ path: parentPath, type: "directory" });
      const parentItem = this._items[parentPath];
      if (!parentItemUUID || !parentItem) {
        throw new Error(`Could not find parent for path ${path}`);
      }
      parentUUID = parentItem.uuid;
    }
    const tmpDir = this.sdkConfig.tmpPath ? this.sdkConfig.tmpPath : import_os2.default.tmpdir();
    const tmpFilePath = import_path4.default.join(tmpDir, "filen-sdk", await uuidv4());
    await import_fs_extra6.default.rm(tmpFilePath, {
      force: true,
      maxRetries: 60 * 10,
      recursive: true,
      retryDelay: 100
    });
    await import_fs_extra6.default.mkdir(import_path4.default.join(tmpFilePath, ".."), {
      recursive: true
    });
    await (0, import_write_file_atomic.default)(tmpFilePath, content);
    try {
      const item = await this.cloud.uploadLocalFile({
        source: tmpFilePath,
        parent: parentUUID,
        name: fileName,
        abortSignal,
        pauseSignal,
        onProgress,
        onProgressId
      });
      if (item.type === "file") {
        await this.itemsMutex.acquire();
        this._items[path] = {
          uuid: item.uuid,
          type: "file",
          metadata: {
            name: item.name,
            size: item.size,
            mime: item.mime,
            key: item.key,
            lastModified: item.lastModified,
            chunks: item.chunks,
            region: item.region,
            bucket: item.bucket,
            version: item.version
          }
        };
        this.itemsMutex.release();
      }
      return item;
    } finally {
      await import_fs_extra6.default.rm(tmpFilePath, {
        force: true,
        maxRetries: 60 * 10,
        recursive: true,
        retryDelay: 100
      });
    }
  }
  /**
   * Download a file or directory from path to a local destination path. Only available in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		path: string
   * 		destination: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.path
   * @param {string} param0.destination
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<void>}
   */
  async download({ path, destination, abortSignal, pauseSignal, onProgress, onProgressId }) {
    if (environment !== "node") {
      throw new Error(`fs.download is not implemented for a ${environment} environment`);
    }
    path = this.normalizePath({ path });
    destination = normalizePath(destination);
    const uuid = await this.pathToItemUUID({ path });
    const item = this._items[path];
    if (!uuid || !item || item.type === "file" && item.metadata.key.length === 0) {
      throw new ENOENT({ path });
    }
    if (item.type === "directory") {
      await this.cloud.downloadDirectoryToLocal({
        uuid,
        to: destination,
        abortSignal,
        pauseSignal,
        onProgress,
        onProgressId
      });
      return;
    }
    await this.cloud.downloadFileToLocal({
      uuid,
      bucket: item.metadata.bucket,
      region: item.metadata.region,
      chunks: item.metadata.chunks,
      version: item.metadata.version,
      key: item.metadata.key,
      to: destination,
      abortSignal,
      pauseSignal,
      onProgress,
      onProgressId,
      size: item.metadata.size
    });
  }
  /**
   * Upload file or directory to path from a local source path. Recursively creates intermediate directories if needed. Only available in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		path: string
   * 		source: string
   * 		overwriteDirectory?: boolean
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.path
   * @param {string} param0.source
   * @param {boolean} [param0.overwriteDirectory=false]
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<CloudItem>}
   */
  async upload({ path, source, overwriteDirectory = false, abortSignal, pauseSignal, onProgress, onProgressId }) {
    if (environment !== "node") {
      throw new Error(`fs.upload is not implemented for a ${environment} environment`);
    }
    path = this.normalizePath({ path });
    source = normalizePath(source);
    const sourceStat = await import_fs_extra6.default.stat(source);
    const parentPath = import_path4.default.posix.dirname(path);
    let parentUUID = "";
    const name = import_path4.default.posix.basename(path);
    if (name.length === 0 || name === "." || name === "/") {
      throw new Error("Could not parse name.");
    }
    if (parentPath === "/" || parentPath === "." || parentPath === "") {
      parentUUID = this.sdkConfig.baseFolderUUID;
    } else {
      await this.mkdir({ path: parentPath });
      const parentItemUUID = await this.pathToItemUUID({ path: parentPath, type: "directory" });
      const parentItem = this._items[parentPath];
      if (!parentItemUUID || !parentItem) {
        throw new Error(`Could not find parent for path ${path}.`);
      }
      parentUUID = parentItem.uuid;
    }
    if (sourceStat.isDirectory()) {
      if (overwriteDirectory) {
        await this._unlink({
          path,
          permanent: true,
          type: "directory"
        });
      }
      await this.cloud.uploadLocalDirectory({
        source,
        parent: parentUUID,
        name,
        abortSignal,
        pauseSignal,
        onProgress,
        onProgressId
      });
      const dir = await this.readdir({
        path: parentPath
      });
      const foundUploadedDir = dir.filter((entry) => entry === name && !entry.includes("/"));
      if (!foundUploadedDir[0]) {
        throw new Error("Could not find uploaded directory.");
      }
      const foundUploadedDirStat = await this.stat({ path: import_path4.default.posix.join(parentPath, foundUploadedDir[0]) });
      return {
        type: "directory",
        uuid: foundUploadedDirStat.uuid,
        name,
        size: foundUploadedDirStat.size,
        lastModified: foundUploadedDirStat.mtimeMs,
        timestamp: Date.now(),
        parent: parentUUID,
        favorited: false,
        color: null
      };
    } else {
      const item = await this.cloud.uploadLocalFile({
        source,
        parent: parentUUID,
        name,
        abortSignal,
        pauseSignal,
        onProgress,
        onProgressId
      });
      if (item.type === "file") {
        await this.itemsMutex.acquire();
        this._items[path] = {
          uuid: item.uuid,
          type: "file",
          metadata: {
            name: item.name,
            size: item.size,
            mime: item.mime,
            key: item.key,
            lastModified: item.lastModified,
            chunks: item.chunks,
            region: item.region,
            bucket: item.bucket,
            version: item.version
          }
        };
        this._uuidToItem[item.uuid] = {
          uuid: item.uuid,
          type: "file",
          path,
          metadata: {
            name: item.name,
            size: item.size,
            mime: item.mime,
            key: item.key,
            lastModified: item.lastModified,
            chunks: item.chunks,
            region: item.region,
            bucket: item.bucket,
            version: item.version
          }
        };
        this.itemsMutex.release();
      }
      return item;
    }
  }
  /**
   * Copy a file or directory structure. Recursively creates intermediate directories if needed.
   * Warning: Can be really inefficient when copying large directory structures.
   * All files need to be downloaded first and then reuploaded due to our end to end encryption.
   * Plain copying unfortunately does not work. Only available in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		from: string
   * 		to: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 	}} param0
   * @param {string} param0.from
   * @param {string} param0.to
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @returns {Promise<void>}
   */
  async cp({ from, to, abortSignal, pauseSignal, onProgress, onProgressId }) {
    if (environment !== "node") {
      throw new Error(`fs.cp is not implemented for a ${environment} environment`);
    }
    from = this.normalizePath({ path: from });
    to = this.normalizePath({ path: to });
    if (from === "/" || from === to || to.startsWith(from + "/")) {
      return;
    }
    const uuid = await this.pathToItemUUID({ path: from });
    const item = this._items[from];
    if (!uuid || !item || item.type === "file" && item.metadata.key.length === 0) {
      throw new ENOENT({ path: from });
    }
    const parentPath = import_path4.default.posix.dirname(to);
    let parentUUID = "";
    if (parentPath === "/" || parentPath === "." || parentPath === "") {
      parentUUID = this.sdkConfig.baseFolderUUID;
    } else {
      await this.mkdir({ path: parentPath });
      const parentItemUUID = await this.pathToItemUUID({
        path: parentPath,
        type: "directory"
      });
      const parentItem = this._items[parentPath];
      if (!parentItemUUID || !parentItem) {
        throw new Error(`Could not find parent for path ${to}`);
      }
      parentUUID = parentItem.uuid;
    }
    if (item.type === "directory") {
      const tmpDir = this.sdkConfig.tmpPath ? this.sdkConfig.tmpPath : import_os2.default.tmpdir();
      const baseDirectoryName = import_path4.default.posix.basename(from);
      if (!baseDirectoryName || baseDirectoryName.length === 0 || baseDirectoryName === ".") {
        throw new Error("Could not parse baseDirectoryName.");
      }
      const newDirectoryName = import_path4.default.posix.basename(to);
      if (!newDirectoryName || newDirectoryName.length === 0 || newDirectoryName === ".") {
        throw new Error("Could not parse newDirectoryName.");
      }
      const tmpDirectoryPath = normalizePath(import_path4.default.join(tmpDir, "filen-sdk", await uuidv4(), newDirectoryName));
      await this.cloud.downloadDirectoryToLocal({
        uuid,
        to: tmpDirectoryPath
      });
      try {
        await this.cloud.uploadLocalDirectory({
          source: tmpDirectoryPath,
          parent: parentUUID,
          abortSignal,
          pauseSignal,
          onProgress,
          onProgressId,
          name: newDirectoryName
        });
        await this.readdir({ path: to, recursive: true });
      } finally {
        await import_fs_extra6.default.rm(import_path4.default.join(tmpDirectoryPath, ".."), {
          force: true,
          maxRetries: 60 * 10,
          recursive: true,
          retryDelay: 100
        });
      }
    } else {
      const newFileName = import_path4.default.posix.basename(to);
      if (!newFileName || newFileName.length === 0 || newFileName === ".") {
        throw new Error("Could not parse newFileName.");
      }
      const tmpFilePath = await this.cloud.downloadFileToLocal({
        uuid,
        bucket: item.metadata.bucket,
        region: item.metadata.region,
        chunks: item.metadata.chunks,
        version: item.metadata.version,
        key: item.metadata.key,
        abortSignal,
        pauseSignal,
        onProgress,
        onProgressId,
        size: item.metadata.size
      });
      try {
        const uploadedItem = await this.cloud.uploadLocalFile({
          source: tmpFilePath,
          parent: parentUUID,
          abortSignal,
          pauseSignal,
          onProgress,
          onProgressId,
          name: newFileName
        });
        if (uploadedItem.type === "file") {
          await this.itemsMutex.acquire();
          this._items[to] = {
            uuid: item.uuid,
            type: "file",
            metadata: {
              name: uploadedItem.name,
              size: uploadedItem.size,
              mime: uploadedItem.mime,
              key: uploadedItem.key,
              lastModified: uploadedItem.lastModified,
              chunks: uploadedItem.chunks,
              region: uploadedItem.region,
              bucket: uploadedItem.bucket,
              version: uploadedItem.version
            }
          };
          this._uuidToItem[item.uuid] = {
            uuid: item.uuid,
            type: "file",
            path: to,
            metadata: {
              name: uploadedItem.name,
              size: uploadedItem.size,
              mime: uploadedItem.mime,
              key: uploadedItem.key,
              lastModified: uploadedItem.lastModified,
              chunks: uploadedItem.chunks,
              region: uploadedItem.region,
              bucket: uploadedItem.bucket,
              version: uploadedItem.version
            }
          };
          this.itemsMutex.release();
        }
      } finally {
        await import_fs_extra6.default.rm(tmpFilePath, {
          force: true,
          maxRetries: 60 * 10,
          recursive: true,
          retryDelay: 100
        });
      }
    }
  }
  /**
   * Alias of cp.
   * @date 2/14/2024 - 5:07:27 AM
   *
   * @public
   * @async
   * @param {...Parameters<typeof this.cp>} params
   * @returns {Promise<void>}
   */
  async copy(...params) {
    return await this.cp(...params);
  }
};
var fs_default = FS;

// node_modules/@filen/sdk/dist/browser/streams/append.js
var import_fs_extra7 = __toESM(require_lib());
var import_stream6 = __toESM(require_stream());
var import_util5 = __toESM(require_util());
var pipelineAsync5 = (0, import_util5.promisify)(import_stream6.pipeline);
async function append({ inputFile, baseFile }) {
  const input = normalizePath(inputFile);
  const output = normalizePath(baseFile);
  const [inputExists, outputExists, inputStats] = await Promise.all([import_fs_extra7.default.exists(input), import_fs_extra7.default.exists(output), import_fs_extra7.default.stat(input)]);
  if (!inputExists) {
    throw new Error("Input file does not exist.");
  }
  if (!outputExists) {
    throw new Error("Output file does not exist.");
  }
  await pipelineAsync5(import_fs_extra7.default.createReadStream(input, {
    highWaterMark: BUFFER_SIZE
  }), import_fs_extra7.default.createWriteStream(output, { flags: "a" }));
  return inputStats.size;
}
var append_default = append;

// node_modules/@filen/sdk/dist/browser/cloud/signals.js
var PauseSignal = class {
  /**
   * Creates an instance of PauseSignal.
   * @date 2/15/2024 - 2:44:55 AM
   *
   * @constructor
   * @public
   */
  constructor() {
    __publicField(this, "paused");
    __publicField(this, "listeners");
    this.paused = false;
    this.listeners = [];
  }
  /**
   * Emit pause.
   * @date 2/15/2024 - 2:44:58 AM
   *
   * @public
   */
  pause() {
    this.paused = true;
    this.listeners.forEach((listener) => listener());
  }
  /**
   * Emit resume.
   * @date 2/15/2024 - 2:45:07 AM
   *
   * @public
   */
  resume() {
    this.paused = false;
  }
  /**
   * onPaused listener.
   * @date 2/15/2024 - 2:45:20 AM
   *
   * @public
   * @param {() => void} listener
   */
  onPaused(listener) {
    this.listeners.push(listener);
  }
  /**
   * isPaused check.
   * @date 2/15/2024 - 2:45:27 AM
   *
   * @public
   * @returns {boolean}
   */
  isPaused() {
    return this.paused;
  }
};

// node_modules/@filen/sdk/dist/browser/cloud/index.js
var import_path5 = __toESM(require_path());
var import_os3 = __toESM(require_os());
var import_fs_extra9 = __toESM(require_lib());
var import_mime_types2 = __toESM(require_mime_types());

// node_modules/@filen/sdk/dist/browser/cloud/utils.js
var import_fs_extra8 = __toESM(require_lib());
function readLocalFileChunk({ path, offset, length }) {
  return new Promise((resolve, reject) => {
    path = normalizePath(path);
    import_fs_extra8.default.open(path, "r", (err, fd) => {
      if (err) {
        reject(err);
        return;
      }
      const buffer = Buffer.alloc(length);
      import_fs_extra8.default.read(fd, buffer, 0, length, offset, (err2, read) => {
        if (err2) {
          import_fs_extra8.default.close(fd, (e) => {
            if (err2) {
              reject(e);
              return;
            }
            reject(err2);
          });
        } else {
          let data;
          if (read < length) {
            data = buffer.subarray(0, read);
          } else {
            data = buffer;
          }
          import_fs_extra8.default.close(fd, (err3) => {
            if (err3) {
              reject(err3);
              return;
            }
            resolve(data);
          });
        }
      });
    });
  });
}
function readWebFileChunk({ file, index, length }) {
  return new Promise((resolve, reject) => {
    const fileReader = new FileReader();
    fileReader.onloadend = () => {
      if (typeof fileReader.result === "string" || fileReader.result === null) {
        resolve(Buffer.from([]));
        return;
      }
      resolve(Buffer.from(fileReader.result));
    };
    fileReader.onerror = reject;
    const offset = length * index;
    fileReader.readAsArrayBuffer(file.slice(offset, offset + length));
  });
}
function calculateChunkIndices({ start, end, chunks }) {
  let firstChunkIndex = Math.floor(start / UPLOAD_CHUNK_SIZE);
  let lastChunkIndex = Math.floor(end / UPLOAD_CHUNK_SIZE) + 1;
  if (firstChunkIndex <= 0) {
    firstChunkIndex = 0;
  }
  if (firstChunkIndex >= chunks) {
    firstChunkIndex = chunks;
  }
  if (firstChunkIndex >= lastChunkIndex) {
    firstChunkIndex = lastChunkIndex;
  }
  if (lastChunkIndex >= chunks) {
    lastChunkIndex = chunks;
  }
  return [firstChunkIndex, lastChunkIndex];
}
var utils3 = {
  readLocalFileChunk,
  readWebFileChunk,
  calculateChunkIndices
};
var utils_default3 = utils3;

// node_modules/@filen/sdk/dist/browser/cloud/index.js
var import_util6 = __toESM(require_util());
var import_stream8 = __toESM(require_stream());

// node_modules/@filen/sdk/dist/browser/cloud/streams.js
var import_stream7 = __toESM(require_stream());
var import_mime_types = __toESM(require_mime_types());
var import_crypto5 = __toESM(require_crypto());
var ChunkedUploadWriter = class extends import_stream7.Writable {
  /**
   * Creates an instance of ChunkedUploadWriter.
   *
   * @constructor
   * @public
   * @param {{
   * 		options?: ConstructorParameters<typeof Writable>[0]
   * 		sdk: FilenSDK
   * 		uuid: string
   * 		key: string
   * 		name: string
   * 		uploadKey: string
   * 		parent: string
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		lastModified?: number
   * 		creation?: number
   * 	}} param0
   * @param {ConstructorParameters<any>} [param0.options=undefined]
   * @param {string} param0.uuid
   * @param {string} param0.key
   * @param {string} param0.name
   * @param {string} param0.uploadKey
   * @param {string} param0.parent
   * @param {FilenSDK} param0.sdk
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {number} param0.lastModified
   * @param {number} param0.creation
   */
  constructor({ options = void 0, uuid, key, name, uploadKey, parent, sdk, onProgress, onProgressId, lastModified, creation }) {
    super(options);
    __publicField(this, "chunkBuffer");
    __publicField(this, "uploadSemaphore", new Semaphore(MAX_UPLOAD_THREADS));
    __publicField(this, "uuid");
    __publicField(this, "version");
    __publicField(this, "key");
    __publicField(this, "bucket");
    __publicField(this, "region");
    __publicField(this, "size");
    __publicField(this, "mime");
    __publicField(this, "lastModified");
    __publicField(this, "name");
    __publicField(this, "index");
    __publicField(this, "uploadKey");
    __publicField(this, "parent");
    __publicField(this, "hasher");
    __publicField(this, "processingMutex", new Semaphore(1));
    __publicField(this, "chunksUploaded", 0);
    __publicField(this, "sdk");
    __publicField(this, "onProgress");
    __publicField(this, "onProgressId");
    __publicField(this, "creation");
    this.onProgress = onProgress;
    this.onProgressId = onProgressId;
    this.sdk = sdk;
    this.chunkBuffer = Buffer.from([]);
    this.uuid = uuid;
    this.key = key;
    this.version = 2;
    this.size = 0;
    this.name = name;
    this.lastModified = lastModified ? lastModified : Date.now();
    this.creation = creation ? creation : Date.now();
    this.mime = import_mime_types.default.lookup(name) || "application/octet-stream";
    this.bucket = "";
    this.region = "";
    this.index = -1;
    this.uploadKey = uploadKey;
    this.parent = parent;
    this.hasher = import_crypto5.default.createHash("sha512");
  }
  /**
   * Write data to the stream.
   * @date 2/29/2024 - 9:58:27 PM
   *
   * @public
   * @param {(Buffer | string)} chunk
   * @param {BufferEncoding} encoding
   * @param {(error?: Error | null | undefined) => void} callback
   */
  _write(chunk, encoding, callback) {
    if (!(chunk instanceof Buffer)) {
      chunk = Buffer.from(chunk, encoding);
    }
    if (chunk.byteLength <= 0) {
      callback();
      return;
    }
    this.uploadSemaphore.acquire().then(() => {
      this.chunkBuffer = Buffer.concat([this.chunkBuffer, chunk]);
      if (this.chunkBuffer.byteLength >= CHUNK_SIZE) {
        const chunkToWrite = this.chunkBuffer.subarray(0, CHUNK_SIZE);
        this.chunkBuffer = this.chunkBuffer.subarray(CHUNK_SIZE);
        this.upload(chunkToWrite).catch((err) => {
          this.destroy(err);
        }).finally(() => {
          this.uploadSemaphore.release();
        });
      } else {
        this.uploadSemaphore.release();
      }
      callback();
    }).catch(callback);
  }
  /**
   * Finalize writing.
   * @date 2/29/2024 - 9:58:39 PM
   *
   * @public
   * @param {(error?: Error | null | undefined) => void} callback
   */
  _final(callback) {
    this.processChunks().then(() => {
      this.finalizeUpload().then(() => callback()).catch(callback);
    }).catch(callback);
  }
  /**
   * Process each chunk.
   * @date 2/29/2024 - 9:58:46 PM
   *
   * @private
   * @async
   * @returns {Promise<void>}
   */
  async processChunks() {
    if (this.chunkBuffer.byteLength <= 0) {
      return;
    }
    while (this.chunkBuffer.byteLength >= CHUNK_SIZE) {
      await this.processingMutex.acquire();
      let chunkToWrite = null;
      try {
        chunkToWrite = this.chunkBuffer.subarray(0, CHUNK_SIZE);
        this.chunkBuffer = this.chunkBuffer.subarray(CHUNK_SIZE);
      } finally {
        this.processingMutex.release();
      }
      if (chunkToWrite instanceof Buffer && chunkToWrite.byteLength > 0) {
        await this.upload(chunkToWrite);
      }
    }
  }
  /**
   * Encrypt, hash and upload a chunk.
   * @date 2/29/2024 - 9:58:54 PM
   *
   * @private
   * @async
   * @param {Buffer} chunk
   * @returns {Promise<void>}
   */
  async upload(chunk) {
    if (chunk.byteLength <= 0) {
      return;
    }
    this.index += 1;
    this.size += chunk.byteLength;
    this.hasher.update(chunk);
    const encryptedChunk = await this.sdk.crypto().encrypt().data({
      data: chunk,
      key: this.key
    });
    const response = await this.sdk.getWorker().api.v3.file.upload.chunk.buffer.fetch({
      uuid: this.uuid,
      index: this.index,
      uploadKey: this.uploadKey,
      parent: this.parent,
      buffer: encryptedChunk
    });
    this.bucket = response.bucket;
    this.region = response.region;
    this.chunksUploaded += 1;
    if (this.onProgress) {
      this.onProgress(chunk.byteLength, this.onProgressId);
    }
  }
  /**
   * Wait for all chunks to be uploaded.
   * @date 3/1/2024 - 5:23:57 AM
   *
   * @private
   * @async
   * @param {number} needed
   * @returns {Promise<void>}
   */
  async waitForAllChunksToBeUploaded(needed) {
    await new Promise((resolve) => {
      if (this.chunksUploaded >= needed) {
        resolve();
        return;
      }
      const wait = setInterval(() => {
        if (this.chunksUploaded >= needed) {
          clearInterval(wait);
          resolve();
        }
      });
    });
  }
  /**
   * Finalize the upload, marking it as done.
   * @date 2/29/2024 - 9:59:20 PM
   *
   * @private
   * @async
   * @returns {Promise<void>}
   */
  async finalizeUpload() {
    await this.processChunks();
    if (this.chunkBuffer.byteLength > 0) {
      await this.upload(this.chunkBuffer);
    }
    if (this.size <= 0) {
      return;
    }
    const fileChunks = Math.ceil(this.size / CHUNK_SIZE);
    await this.waitForAllChunksToBeUploaded(fileChunks);
    const hash = this.hasher.digest("hex");
    await this.sdk.api(3).upload().done({
      uuid: this.uuid,
      name: await this.sdk.crypto().encrypt().metadata({ metadata: this.name, key: this.key }),
      nameHashed: await this.sdk.crypto().utils.hashFn({ input: this.name.toLowerCase() }),
      size: await this.sdk.crypto().encrypt().metadata({ metadata: this.size.toString(), key: this.key }),
      chunks: fileChunks,
      mime: await this.sdk.crypto().encrypt().metadata({ metadata: this.mime, key: this.key }),
      version: this.version,
      uploadKey: this.uploadKey,
      rm: await this.sdk.crypto().utils.generateRandomString({ length: 32 }),
      metadata: await this.sdk.crypto().encrypt().metadata({
        metadata: JSON.stringify({
          name: this.name,
          size: this.size,
          mime: this.mime,
          key: this.key,
          lastModified: this.lastModified,
          creation: this.creation,
          hash
        })
      })
    });
    await this.sdk.cloud().checkIfItemParentIsShared({
      type: "file",
      parent: this.parent,
      uuid: this.uuid,
      itemMetadata: {
        name: this.name,
        size: this.size,
        mime: this.mime,
        lastModified: this.lastModified,
        creation: this.creation,
        key: this.key,
        hash
      }
    });
    this.emit("uploaded", {
      type: "file",
      uuid: this.uuid,
      metadata: {
        name: this.name,
        size: this.size,
        mime: this.mime,
        key: this.key,
        lastModified: this.lastModified,
        creation: this.creation,
        hash,
        version: this.version,
        region: this.region,
        chunks: fileChunks,
        bucket: this.bucket
      }
    });
  }
};

// node_modules/@filen/sdk/dist/browser/cloud/index.js
var pipelineAsync6 = (0, import_util6.promisify)(import_stream8.pipeline);
var Cloud = class {
  /**
   * Creates an instance of Cloud.
   * @date 2/14/2024 - 11:30:03 PM
   *
   * @constructor
   * @public
   * @param {CloudConfig} params
   */
  constructor(params) {
    __publicField(this, "api");
    __publicField(this, "sdkConfig");
    __publicField(this, "sdk");
    __publicField(this, "_semaphores", {
      downloadStream: new Semaphore(MAX_CONCURRENT_DOWNLOADS),
      downloadToLocal: new Semaphore(MAX_CONCURRENT_DOWNLOADS),
      uploads: new Semaphore(MAX_CONCURRENT_UPLOADS),
      directoryDownloads: new Semaphore(MAX_CONCURRENT_DIRECTORY_DOWNLOADS),
      directoryUploads: new Semaphore(MAX_CONCURRENT_DIRECTORY_UPLOADS),
      createDirectory: new Semaphore(1),
      share: new Semaphore(MAX_CONCURRENT_SHARES)
    });
    __publicField(this, "utils", {
      signals: {
        PauseSignal
      },
      utils: utils_default3
    });
    this.api = params.api;
    this.sdkConfig = params.sdkConfig;
    this.sdk = params.sdk;
  }
  /**
   * Lists all files and directories in a directory.
   * @date 3/14/2024 - 5:21:55 AM
   *
   * @public
   * @async
   * @param {{ uuid: string, onlyDirectories?: boolean }} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.onlyDirectories
   * @returns {Promise<CloudItem[]>}
   */
  async listDirectory({ uuid, onlyDirectories }) {
    const content = await this.api.v3().dir().content({ uuid, dirsOnly: onlyDirectories });
    const items = [];
    const promises = [];
    for (const folder of content.folders) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.name }).then((decrypted) => {
        const timestamp = convertTimestampToMs(folder.timestamp);
        items.push({
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          lastModified: timestamp,
          timestamp,
          color: folder.color,
          parent: folder.parent,
          favorited: folder.favorited === 1,
          size: 0
        });
        resolve();
      }).catch(reject)));
    }
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          rm: file.rm,
          version: file.version,
          chunks: file.chunks,
          favorited: file.favorited === 1,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    return items;
  }
  /**
   * List shared in files and directories based on parent.
   * @date 2/15/2024 - 1:16:49 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<CloudItemShared[]>}
   */
  async listDirectorySharedIn({ uuid }) {
    const content = await this.api.v3().shared().in({ uuid });
    const items = [];
    const promises = [];
    for (const folder of content.folders) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.folderMetadataPrivate({ metadata: folder.metadata }).then((decrypted) => {
        const timestamp = convertTimestampToMs(folder.timestamp);
        items.push({
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          lastModified: timestamp,
          timestamp,
          color: folder.color,
          parent: folder.parent ?? "shared-in",
          sharerEmail: folder.sharerEmail ?? "",
          sharerId: folder.sharerId ?? 0,
          receiverEmail: folder.receiverEmail ?? "",
          receiverId: folder.receiverId ?? 0,
          receivers: [],
          size: 0
        });
        resolve();
      }).catch(reject)));
    }
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadataPrivate({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          version: file.version,
          chunks: file.chunks,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0,
          sharerEmail: file.sharerEmail ?? "",
          sharerId: file.sharerId ?? 0,
          receiverEmail: file.receiverEmail ?? "",
          receiverId: file.receiverId ?? 0,
          receivers: []
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    return items;
  }
  /**
   * List shared out files and directories based on parent.
   * @date 2/15/2024 - 1:16:32 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; receiverId?: number }} param0
   * @param {string} param0.uuid
   * @param {number} param0.receiverId
   * @returns {Promise<CloudItemShared[]>}
   */
  async listDirectorySharedOut({ uuid, receiverId }) {
    const content = await this.api.v3().shared().out({ uuid, receiverId });
    const items = [];
    const promises = [];
    for (const folder of content.folders) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.metadata }).then((decrypted) => {
        const timestamp = convertTimestampToMs(folder.timestamp);
        items.push({
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          lastModified: timestamp,
          timestamp,
          color: folder.color,
          parent: folder.parent ?? "shared-in",
          sharerEmail: folder.sharerEmail ?? "",
          sharerId: folder.sharerId ?? 0,
          receiverEmail: folder.receiverEmail ?? "",
          receiverId: folder.receiverId ?? 0,
          receivers: [],
          size: 0
        });
        resolve();
      }).catch(reject)));
    }
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          version: file.version,
          chunks: file.chunks,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0,
          sharerEmail: file.sharerEmail ?? "",
          sharerId: file.sharerId ?? 0,
          receiverEmail: file.receiverEmail ?? "",
          receiverId: file.receiverId ?? 0,
          receivers: []
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    const groups = [];
    const sharedTo = {};
    const added = {};
    for (const item of items) {
      if (sharedTo[item.uuid] && Array.isArray(sharedTo[item.uuid])) {
        sharedTo[item.uuid].push({
          id: item.receiverId,
          email: item.receiverEmail
        });
      } else {
        sharedTo[item.uuid] = [
          {
            id: item.receiverId,
            email: item.receiverEmail
          }
        ];
      }
    }
    for (let i = 0; i < items.length; i++) {
      if (items[i] && Array.isArray(sharedTo[items[i].uuid])) {
        items[i].receivers = sharedTo[items[i].uuid];
      }
      if (items[i] && !added[items[i].uuid]) {
        added[items[i].uuid] = true;
        groups.push(items[i]);
      }
    }
    return groups;
  }
  /**
   * List all recently uploaded files.
   * @date 2/15/2024 - 1:16:20 AM
   *
   * @public
   * @async
   * @returns {Promise<CloudItem[]>}
   */
  async listRecents() {
    const content = await this.api.v3().dir().content({ uuid: "recents" });
    const items = [];
    const promises = [];
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          rm: file.rm,
          version: file.version,
          chunks: file.chunks,
          favorited: file.favorited === 1,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    return items;
  }
  /**
   * List all files and directories inside the trash.
   * @date 2/15/2024 - 8:59:04 PM
   *
   * @public
   * @async
   * @returns {Promise<CloudItem[]>}
   */
  async listTrash() {
    const content = await this.api.v3().dir().content({ uuid: "trash" });
    const items = [];
    const promises = [];
    for (const folder of content.folders) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.name }).then((decrypted) => {
        const timestamp = convertTimestampToMs(folder.timestamp);
        items.push({
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          lastModified: timestamp,
          timestamp,
          color: folder.color,
          parent: folder.parent,
          favorited: folder.favorited === 1,
          size: 0
        });
        resolve();
      }).catch(reject)));
    }
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          rm: file.rm,
          version: file.version,
          chunks: file.chunks,
          favorited: file.favorited === 1,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    return items;
  }
  /**
   * List all favorite files and directories.
   * @date 2/15/2024 - 8:59:52 PM
   *
   * @public
   * @async
   * @returns {Promise<CloudItem[]>}
   */
  async listFavorites() {
    const content = await this.api.v3().dir().content({ uuid: "favorites" });
    const items = [];
    const promises = [];
    for (const folder of content.folders) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.name }).then((decrypted) => {
        const timestamp = convertTimestampToMs(folder.timestamp);
        items.push({
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          lastModified: timestamp,
          timestamp,
          color: folder.color,
          parent: folder.parent,
          favorited: folder.favorited === 1,
          size: 0
        });
        resolve();
      }).catch(reject)));
    }
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          rm: file.rm,
          version: file.version,
          chunks: file.chunks,
          favorited: file.favorited === 1,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    return items;
  }
  /**
   * List all public linked files and directories.
   * @date 2/15/2024 - 9:01:01 PM
   *
   * @public
   * @async
   * @returns {Promise<CloudItem[]>}
   */
  async listPublicLinks() {
    const content = await this.api.v3().dir().content({ uuid: "links" });
    const items = [];
    const promises = [];
    for (const folder of content.folders) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.name }).then((decrypted) => {
        const timestamp = convertTimestampToMs(folder.timestamp);
        items.push({
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          lastModified: timestamp,
          timestamp,
          color: folder.color,
          parent: folder.parent,
          favorited: folder.favorited === 1,
          size: 0
        });
        resolve();
      }).catch(reject)));
    }
    for (const file of content.uploads) {
      promises.push(new Promise((resolve, reject) => this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata }).then((decrypted) => {
        items.push({
          type: "file",
          uuid: file.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
          size: realFileSize({
            chunksSize: file.size,
            metadataDecrypted: decrypted
          }),
          mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
          lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : file.timestamp),
          timestamp: convertTimestampToMs(file.timestamp),
          parent: file.parent,
          rm: file.rm,
          version: file.version,
          chunks: file.chunks,
          favorited: file.favorited === 1,
          key: decrypted.name.length > 0 ? decrypted.key : "",
          bucket: file.bucket,
          region: file.region,
          creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
          hash: decrypted.name.length > 0 ? decrypted.hash : void 0
        });
        resolve();
      }).catch(reject)));
    }
    await promiseAllChunked(promises);
    return items;
  }
  /**
   * Check if a file with <NAME> exists in parent.
   *
   * @public
   * @async
   * @param {{ name: string; parent: string }} param0
   * @param {string} param0.name
   * @param {string} param0.parent
   * @returns {Promise<FileExistsResponse>}
   */
  async fileExists({ name, parent }) {
    const nameHashed = await this.sdk.getWorker().crypto.utils.hashFn({ input: name.toLowerCase() });
    const exists = await this.api.v3().file().exists({
      nameHashed,
      parent
    });
    return exists;
  }
  /**
   * Check if a directory with <NAME> exists in parent.
   *
   * @public
   * @async
   * @param {{ name: string; parent: string }} param0
   * @param {string} param0.name
   * @param {string} param0.parent
   * @returns {Promise<DirExistsResponse>}
   */
  async directoryExists({ name, parent }) {
    const nameHashed = await this.sdk.getWorker().crypto.utils.hashFn({ input: name.toLowerCase() });
    const exists = await this.api.v3().dir().exists({
      nameHashed,
      parent
    });
    return exists;
  }
  /**
   * Edit metadata of a file (currently uses the rename endpoint, might change later).
   *
   * @public
   * @async
   * @param {{ uuid: string; metadata: FileMetadata }} param0
   * @param {string} param0.uuid
   * @param {FileMetadata} param0.metadata
   * @returns {Promise<void>}
   */
  async editFileMetadata({ uuid, metadata }) {
    const [nameHashed, metadataEncrypted, nameEncrypted] = await Promise.all([
      this.sdk.getWorker().crypto.utils.hashFn({ input: metadata.name.toLowerCase() }),
      this.sdk.getWorker().crypto.encrypt.metadata({
        metadata: JSON.stringify(metadata)
      }),
      this.sdk.getWorker().crypto.encrypt.metadata({
        metadata: metadata.name,
        key: metadata.key
      })
    ]);
    try {
      await this.api.v3().file().rename({
        uuid,
        metadataEncrypted,
        nameEncrypted,
        nameHashed
      });
    } catch (e) {
      if (e instanceof APIError) {
        if (e.code === "file_not_found") {
          return;
        }
      }
    }
    await this.checkIfItemIsSharedForRename({
      uuid,
      itemMetadata: metadata
    });
  }
  /**
   * Rename a file.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		metadata: FileMetadata
   * 		name: string
   * 		overwriteIfExists?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {FileMetadata} param0.metadata
   * @param {string} param0.name
   * @param {boolean} [param0.overwriteIfExists=false]
   * @returns {Promise<void>}
   */
  async renameFile({ uuid, metadata, name, overwriteIfExists = false }) {
    if (metadata.key.length === 0) {
      throw new Error("Invalid metadata key.");
    }
    const isPresent = await this.api.v3().file().present({ uuid });
    if (!isPresent.present) {
      return;
    }
    const get = await this.api.v3().file().get({ uuid });
    const exists = await this.fileExists({
      name,
      parent: get.parent
    });
    if (exists.exists && exists.uuid !== uuid) {
      if (overwriteIfExists) {
        await this.trashFile({ uuid: exists.uuid });
      } else {
        throw new Error("A file with the same name already exists in this directory.");
      }
    }
    const [nameHashed, metadataEncrypted, nameEncrypted] = await Promise.all([
      this.sdk.getWorker().crypto.utils.hashFn({ input: name.toLowerCase() }),
      this.sdk.getWorker().crypto.encrypt.metadata({
        metadata: JSON.stringify({
          ...metadata,
          name
        })
      }),
      this.sdk.getWorker().crypto.encrypt.metadata({
        metadata: name,
        key: metadata.key
      })
    ]);
    try {
      await this.api.v3().file().rename({
        uuid,
        metadataEncrypted,
        nameEncrypted,
        nameHashed
      });
    } catch (e) {
      if (e instanceof APIError) {
        if (e.code === "file_not_found") {
          return;
        }
      }
    }
    await this.checkIfItemIsSharedForRename({
      uuid,
      itemMetadata: metadata
    });
  }
  /**
   * Rename a directory.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		name: string
   * 		overwriteIfExists?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.name
   * @param {boolean} [param0.overwriteIfExists=false]
   * @returns {Promise<void>}
   */
  async renameDirectory({ uuid, name, overwriteIfExists = false }) {
    const isPresent = await this.api.v3().dir().present({ uuid });
    if (!isPresent.present) {
      return;
    }
    const get = await this.api.v3().dir().get({ uuid });
    const exists = await this.directoryExists({
      name,
      parent: get.parent
    });
    if (exists.exists && exists.uuid !== uuid) {
      if (overwriteIfExists) {
        await this.trashDirectory({ uuid: exists.uuid });
      } else {
        throw new Error("A directory with the same name already exists in this directory.");
      }
    }
    const [nameHashed, metadataEncrypted] = await Promise.all([
      this.sdk.getWorker().crypto.utils.hashFn({ input: name.toLowerCase() }),
      this.sdk.getWorker().crypto.encrypt.metadata({
        metadata: JSON.stringify({
          name
        })
      })
    ]);
    try {
      await this.api.v3().dir().rename({
        uuid,
        metadataEncrypted,
        nameHashed
      });
    } catch (e) {
      if (e instanceof APIError) {
        if (e.code === "folder_not_found") {
          return;
        }
      }
    }
    await this.checkIfItemIsSharedForRename({
      uuid,
      itemMetadata: {
        name
      }
    });
  }
  /**
   * Move a file.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		to: string
   * 		metadata: FileMetadata
   * 		overwriteIfExists?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.to
   * @param {FileMetadata} param0.metadata
   * @param {boolean} [param0.overwriteIfExists=false]
   * @returns {Promise<void>}
   */
  async moveFile({ uuid, to, metadata, overwriteIfExists = false }) {
    const exists = await this.fileExists({
      name: metadata.name,
      parent: to
    });
    if (exists.exists) {
      if (exists.uuid === uuid) {
        return;
      }
      if (overwriteIfExists) {
        await this.trashFile({ uuid: exists.uuid });
      }
    }
    await this.api.v3().file().move({
      uuid,
      to
    });
    await this.checkIfItemParentIsShared({
      type: "file",
      parent: to,
      uuid,
      itemMetadata: metadata
    });
  }
  /**
   * Move a directory.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		to: string
   * 		metadata: FolderMetadata
   * 		overwriteIfExists?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.to
   * @param {FolderMetadata} param0.metadata
   * @param {boolean} [param0.overwriteIfExists=false]
   * @returns {Promise<void>}
   */
  async moveDirectory({ uuid, to, metadata, overwriteIfExists = false }) {
    const exists = await this.directoryExists({
      name: metadata.name,
      parent: to
    });
    if (exists.exists) {
      if (exists.uuid === uuid) {
        return;
      }
      if (overwriteIfExists) {
        await this.trashDirectory({ uuid: exists.uuid });
      }
    }
    await this.api.v3().dir().move({
      uuid,
      to
    });
    await this.checkIfItemParentIsShared({
      type: "directory",
      parent: to,
      uuid,
      itemMetadata: metadata
    });
  }
  /**
   * Send a file to the trash bin.
   * @date 2/15/2024 - 2:07:13 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async trashFile({ uuid }) {
    await this.api.v3().file().trash({ uuid });
  }
  /**
   * Send a directory to the trash bin.
   * @date 2/15/2024 - 2:07:13 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async trashDirectory({ uuid }) {
    await this.api.v3().dir().trash({ uuid });
  }
  /**
   * Create a directory under parent.
   *
   * @public
   * @async
   * @param {{
   * 		uuid?: string
   * 		name: string
   * 		parent: string
   * 		renameIfExists?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.name
   * @param {string} param0.parent
   * @param {boolean} [param0.renameIfExists=false]
   * @returns {Promise<string>}
   */
  async createDirectory({ uuid, name, parent, renameIfExists = false }) {
    await this._semaphores.createDirectory.acquire();
    try {
      let uuidToUse = uuid ? uuid : await uuidv4();
      const exists = await this.directoryExists({ name, parent });
      if (exists.exists) {
        uuidToUse = exists.uuid;
        if (renameIfExists) {
          await this.renameDirectory({
            uuid: uuidToUse,
            name,
            overwriteIfExists: false
          });
        }
      } else {
        const [metadataEncrypted, nameHashed] = await Promise.all([
          this.sdk.getWorker().crypto.encrypt.metadata({ metadata: JSON.stringify({ name }) }),
          this.sdk.getWorker().crypto.utils.hashFn({ input: name.toLowerCase() })
        ]);
        await this.api.v3().dir().create({ uuid: uuidToUse, metadataEncrypted, nameHashed, parent });
        await this.checkIfItemParentIsShared({
          type: "directory",
          parent,
          uuid: uuidToUse,
          itemMetadata: {
            name
          }
        });
      }
      return uuidToUse;
    } finally {
      this._semaphores.createDirectory.release();
    }
  }
  /**
   * Change the color of a directory.
   * @date 2/15/2024 - 8:52:40 PM
   *
   * @public
   * @async
   * @param {{uuid: string, color: DirColors}} param0
   * @param {string} param0.uuid
   * @param {DirColors} param0.color
   * @returns {Promise<void>}
   */
  async changeDirectoryColor({ uuid, color }) {
    await this.api.v3().dir().color({ uuid, color });
  }
  /**
   * Toggle the favorite status of a directory.
   * @date 2/15/2024 - 8:54:03 PM
   *
   * @public
   * @async
   * @param {{uuid: string, favorite: boolean}} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async favoriteDirectory({ uuid, favorite }) {
    await this.api.v3().item().favorite({ uuid, type: "folder", favorite });
  }
  /**
   * Toggle the favorite status of a file.
   * @date 2/15/2024 - 8:54:23 PM
   *
   * @public
   * @async
   * @param {{uuid: string, favorite: boolean}} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async favoriteFile({ uuid, favorite }) {
    await this.api.v3().item().favorite({ uuid, type: "file", favorite });
  }
  /**
   * Permanently delete a file.
   * @date 2/15/2024 - 11:42:05 PM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async deleteFile({ uuid }) {
    await this.api.v3().file().delete().permanent({ uuid });
  }
  /**
   * Permanently delete a directory.
   * @date 2/15/2024 - 11:42:13 PM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async deleteDirectory({ uuid }) {
    await this.api.v3().dir().delete().permanent({ uuid });
  }
  /**
   * Restore a file from the trash.
   * @date 2/15/2024 - 11:43:21 PM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async restoreFile({ uuid }) {
    await this.api.v3().file().restore({ uuid });
  }
  /**
   * Restore a directory from the trash.
   * @date 2/15/2024 - 11:43:29 PM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async restoreDirectory({ uuid }) {
    await this.api.v3().dir().restore({ uuid });
  }
  /**
   * Restore a file version.
   * @date 2/15/2024 - 11:44:51 PM
   *
   * @public
   * @async
   * @param {{uuid:string, currentUUID:string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.currentUUID
   * @returns {Promise<void>}
   */
  async restoreFileVersion({ uuid, currentUUID }) {
    await this.api.v3().file().version().restore({
      uuid,
      currentUUID
    });
  }
  /**
   * Retrieve all versions of a file.
   * @date 2/15/2024 - 11:46:38 PM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<FileVersionsResponse>}
   */
  async fileVersions({ uuid }) {
    return await this.api.v3().file().versions({ uuid });
  }
  /**
   * Share an item to another Filen user.
   * @date 2/17/2024 - 4:11:05 AM
   *
   * @private
   * @async
   * @param {{
   * 		uuid: string
   * 		parent: string
   * 		email: string
   * 		type: "file" | "folder"
   * 		publicKey: string
   * 		metadata: FileMetadata | FolderMetadata
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.parent
   * @param {string} param0.email
   * @param {("file" | "folder")} param0.type
   * @param {string} param0.publicKey
   * @param {*} param0.metadata
   * @returns {Promise<void>}
   */
  async shareItem({ uuid, parent, email, type, publicKey, metadata }) {
    await this._semaphores.share.acquire();
    try {
      const metadataEncrypted = await this.sdk.getWorker().crypto.encrypt.metadataPublic({
        metadata: JSON.stringify(metadata),
        publicKey
      });
      await this.api.v3().item().share({
        uuid,
        parent,
        email,
        type,
        metadata: metadataEncrypted
      });
    } finally {
      this._semaphores.share.release();
    }
  }
  /**
   * Add an item to a directory public link.
   * @date 2/19/2024 - 5:08:51 AM
   *
   * @private
   * @async
   * @param {{
   * 		uuid: string
   * 		parent: string
   * 		linkUUID: string
   * 		type: "file" | "folder"
   * 		metadata: FileMetadata | FolderMetadata
   * 		linkKeyEncrypted: string
   * 		expiration: PublicLinkExpiration
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.parent
   * @param {string} param0.linkUUID
   * @param {("file" | "folder")} param0.type
   * @param {*} param0.metadata
   * @param {string} param0.linkKeyEncrypted
   * @param {PublicLinkExpiration} param0.expiration
   * @returns {Promise<void>}
   */
  async addItemToDirectoryPublicLink({ uuid, parent, linkUUID, type, metadata, linkKeyEncrypted, expiration }) {
    await this._semaphores.share.acquire();
    try {
      const key = await this.sdk.getWorker().crypto.decrypt.folderLinkKey({ metadata: linkKeyEncrypted });
      if (key.length === 0) {
        throw new Error("Invalid key.");
      }
      const metadataEncrypted = await this.sdk.getWorker().crypto.encrypt.metadata({
        metadata: JSON.stringify(metadata),
        key
      });
      await this.api.v3().dir().link().add({
        uuid,
        parent,
        linkUUID,
        type,
        metadata: metadataEncrypted,
        key: linkKeyEncrypted,
        expiration
      });
    } finally {
      this._semaphores.share.release();
    }
  }
  /**
   * Enable a public link for a file or a directory.
   * @date 2/19/2024 - 5:13:57 AM
   *
   * @public
   * @async
   * @param {{
   * 		type: "file" | "directory"
   * 		uuid: string
   * 		onProgress?: ProgressWithTotalCallback
   * 	}} param0
   * @param {("file" | "directory")} param0.type
   * @param {string} param0.uuid
   * @param {ProgressWithTotalCallback} param0.onProgress
   * @returns {Promise<string>}
   */
  async enablePublicLink({ type, uuid, onProgress }) {
    const linkUUID = await uuidv4();
    if (type === "directory") {
      const [tree, key] = await Promise.all([
        this.getDirectoryTree({ uuid }),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 })
      ]);
      const linkKeyEncrypted = await this.sdk.getWorker().crypto.encrypt.metadata({ metadata: key });
      let done = 0;
      const promises = [];
      const total = Object.keys(tree).length;
      for (const entry in tree) {
        const item = tree[entry];
        if (!item || item.type === "file" && item.key.length === 0) {
          continue;
        }
        promises.push(new Promise((resolve, reject) => {
          this.addItemToDirectoryPublicLink({
            uuid: item.uuid,
            parent: item.parent,
            linkUUID,
            type: item.type === "directory" ? "folder" : "file",
            expiration: "never",
            linkKeyEncrypted,
            metadata: item.type === "directory" ? { name: item.name } : {
              name: item.name,
              size: item.size,
              mime: item.mime,
              lastModified: item.lastModified,
              key: item.key,
              creation: item.creation,
              hash: item.hash
            }
          }).then(() => {
            done += 1;
            if (onProgress) {
              onProgress(done, total);
            }
            resolve();
          }).catch(reject);
        }));
      }
      await promiseAllChunked(promises);
      return linkUUID;
    }
    await this.api.v3().file().link().edit({
      uuid: linkUUID,
      fileUUID: uuid,
      expiration: "never",
      password: "empty",
      passwordHashed: await this.sdk.getWorker().crypto.utils.hashFn({ input: "empty" }),
      downloadBtn: true,
      type: "enable",
      salt: await this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 })
    });
    return linkUUID;
  }
  /**
   * Edit a file/directory public link.
   * @date 2/19/2024 - 4:57:03 AM
   *
   * @public
   * @async
   * @param {{
   * 		type: "file" | "directory"
   * 		itemUUID: string
   * 		linkUUID?: string
   * 		password?: string
   * 		enableDownload?: boolean
   * 		expiration: PublicLinkExpiration
   * 	}} param0
   * @param {("file" | "directory")} param0.type
   * @param {string} param0.itemUUID
   * @param {string} param0.linkUUID
   * @param {string} param0.password
   * @param {boolean} [param0.enableDownload=true]
   * @param {PublicLinkExpiration} [param0.expiration="never"]
   * @returns {Promise<void>}
   */
  async editPublicLink({ type, itemUUID, linkUUID, password, enableDownload = true, expiration = "never" }) {
    const salt = await this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 });
    const pass = password && password.length > 0 ? "notempty" : "empty";
    const passHashed = password && password.length > 0 ? await this.sdk.getWorker().crypto.utils.deriveKeyFromPassword({
      password,
      salt,
      iterations: 2e5,
      hash: "sha512",
      bitLength: 512,
      returnHex: true
    }) : "empty";
    if (type === "directory") {
      await this.api.v3().dir().link().edit({ uuid: itemUUID, expiration, password: pass, passwordHashed: passHashed, salt, downloadBtn: enableDownload });
      return;
    }
    if (!linkUUID) {
      throw new Error("[cloud.disablePublicLink] linkUUID undefined, expected: UUIDv4 string");
    }
    await this.api.v3().file().link().edit({
      uuid: linkUUID,
      fileUUID: itemUUID,
      expiration,
      password: pass,
      passwordHashed: passHashed,
      salt,
      downloadBtn: enableDownload,
      type: "enable"
    });
  }
  /**
   * Disable a file/directory public link.
   * @date 2/19/2024 - 4:47:27 AM
   *
   * @public
   * @async
   * @param {{
   * 		type: "file" | "directory"
   * 		linkUUID?: string
   * 		itemUUID: string
   * 	}} param0
   * @param {("file" | "directory")} param0.type
   * @param {string} param0.linkUUID
   * @param {string} param0.itemUUID
   * @returns {Promise<void>}
   */
  async disablePublicLink({ type, linkUUID, itemUUID }) {
    if (type === "directory") {
      await this.api.v3().dir().link().remove({ uuid: itemUUID });
      return;
    }
    if (!linkUUID) {
      throw new Error("[cloud.disablePublicLink] linkUUID undefined, expected: UUIDv4 string");
    }
    await this.api.v3().file().link().edit({
      uuid: linkUUID,
      fileUUID: itemUUID,
      expiration: "never",
      password: "empty",
      passwordHashed: await this.sdk.getWorker().crypto.utils.hashPassword({ password: "empty" }),
      salt: await this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 }),
      downloadBtn: true,
      type: "disable"
    });
  }
  /**
   * Fetch the status of a public link.
   *
   * @public
   * @async
   * @param {({type: "file" | "directory", uuid: string})} param0
   * @param {("file" | "directory")} param0.type
   * @param {string} param0.uuid
   * @returns {Promise<DirLinkStatusResponse | FileLinkStatusResponse>}
   */
  async publicLinkStatus({ type, uuid }) {
    if (type === "directory") {
      return await this.api.v3().dir().link().status({ uuid });
    }
    return await this.api.v3().file().link().status({ uuid });
  }
  /**
   * Fetch password info of a public link.
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<FileLinkPasswordResponse>}
   */
  async filePublicLinkHasPassword({ uuid }) {
    return await this.api.v3().file().link().password({ uuid });
  }
  /**
   * Fetch info of a file public link.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		password?: string
   * 		salt?: string
   * 		key: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.password
   * @param {string} param0.salt
   * @param {string} param0.key
   * @returns {(Promise<Omit<FileLinkInfoResponse, "size"> & { size: number }>)}
   */
  async filePublicLinkInfo({ uuid, password, salt, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const derivedPassword = password ? salt && salt.length === 32 ? await this.sdk.getWorker().crypto.utils.deriveKeyFromPassword({
      password,
      salt,
      iterations: 2e5,
      hash: "sha512",
      bitLength: 512,
      returnHex: true
    }) : await this.sdk.getWorker().crypto.utils.hashFn({
      input: !password ? "empty" : password
    }) : await this.sdk.getWorker().crypto.utils.hashFn({ input: "empty" });
    const info = await this.api.v3().file().link().info({
      uuid,
      password: derivedPassword
    });
    const [nameDecrypted, mimeDecrypted, sizeDecrypted] = await Promise.all([
      this.sdk.getWorker().crypto.decrypt.metadata({
        metadata: info.name,
        key
      }),
      this.sdk.getWorker().crypto.decrypt.metadata({
        metadata: info.mime,
        key
      }),
      this.sdk.getWorker().crypto.decrypt.metadata({
        metadata: info.size,
        key
      })
    ]);
    return {
      ...info,
      name: nameDecrypted.length > 0 ? nameDecrypted : `CANNOT_DECRYPT_NAME_${uuid}`,
      mime: nameDecrypted.length > 0 ? mimeDecrypted : "application/octet-stream",
      size: nameDecrypted.length > 0 ? parseInt(sizeDecrypted) : 1
    };
  }
  /**
   * Fetch info about a directory public link.
   *
   * @public
   * @async
   * @param {{ uuid: string, key: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.key
   * @returns {Promise<DirLinkInfoDecryptedResponse>}
   */
  async directoryPublicLinkInfo({ uuid, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const info = await this.api.v3().dir().link().info({ uuid });
    const metadataDecrypted = await this.sdk.getWorker().crypto.decrypt.folderMetadata({
      metadata: info.metadata,
      key
    });
    return {
      ...info,
      metadata: {
        name: metadataDecrypted.name.length > 0 ? metadataDecrypted.name : `CANNOT_DECRYPT_NAME_${uuid}`
      }
    };
  }
  /**
   * Fetch contents of a directory public link or it's children.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		parent: string
   * 		password?: string
   * 		salt?: string
   * 		key: string
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.parent
   * @param {string} param0.password
   * @param {string} param0.salt
   * @param {string} param0.key
   * @returns {Promise<DirLinkContentDecryptedResponse>}
   */
  async directoryPublicLinkContent({ uuid, parent, password, salt, key }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const derivedPassword = password ? salt && salt.length === 32 ? await this.sdk.getWorker().crypto.utils.deriveKeyFromPassword({
      password,
      salt,
      iterations: 2e5,
      hash: "sha512",
      bitLength: 512,
      returnHex: true
    }) : await this.sdk.getWorker().crypto.utils.hashFn({
      input: !password ? "empty" : password
    }) : await this.sdk.getWorker().crypto.utils.hashFn({ input: "empty" });
    const content = await this.api.v3().dir().link().content({
      uuid,
      parent,
      password: derivedPassword
    });
    return {
      files: await promiseAllChunked(content.files.map((file) => new Promise((resolve, reject) => {
        this.sdk.getWorker().crypto.decrypt.fileMetadata({
          metadata: file.metadata,
          key
        }).then((decryptedFileMetadata) => {
          resolve({
            ...file,
            metadata: decryptedFileMetadata.name.length > 0 ? decryptedFileMetadata : {
              name: `CANNOT_DECRYPT_NAME_${file.uuid}`,
              mime: "application/octet-stream",
              size: realFileSize({
                chunksSize: file.size,
                metadataDecrypted: decryptedFileMetadata
              }),
              lastModified: convertTimestampToMs(file.timestamp),
              creation: void 0,
              hash: void 0,
              key: ""
            }
          });
        }).catch(reject);
      }))),
      folders: await promiseAllChunked(content.folders.map((folder) => new Promise((resolve, reject) => {
        this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.metadata, key }).then((decryptedFolderMetadata) => {
          resolve({
            ...folder,
            metadata: decryptedFolderMetadata.name.length > 0 ? decryptedFolderMetadata : {
              name: `CANNOT_DECRYPT_NAME_${folder.uuid}`
            }
          });
        }).catch(reject);
      })))
    };
  }
  /**
   * Stop sharing an item with another user.
   * @date 2/19/2024 - 4:38:21 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; receiverId: number }} param0
   * @param {string} param0.uuid
   * @param {number} param0.receiverId
   * @returns {Promise<void>}
   */
  async stopSharingItem({ uuid, receiverId }) {
    await this.api.v3().item().sharedOut().remove({ uuid, receiverId });
  }
  /**
   * Stop receiving a shared item.
   * @date 2/19/2024 - 4:38:36 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async removeSharedItem({ uuid }) {
    await this.api.v3().item().sharedIn().remove({ uuid });
  }
  /**
   * Share a file or a directory (and all it's children) to a user.
   * @date 2/19/2024 - 4:35:03 AM
   *
   * @public
   * @async
   * @param {{
   * 		files: { uuid: string; parent: string; metadata: FileMetadata }[]
   * 		directories: { uuid: string; parent: string; metadata: FolderMetadata }[]
   * 		email: string
   * 		onProgress?: ProgressWithTotalCallback
   * 	}} param0
   * @param {{}} param0.files
   * @param {{}} param0.directories
   * @param {string} param0.email
   * @param {ProgressWithTotalCallback} param0.onProgress
   * @returns {Promise<void>}
   */
  async shareItemsToUser({ files, directories, email, onProgress }) {
    const publicKey = (await this.api.v3().user().publicKey({ email })).publicKey;
    const itemsToShare = [];
    for (const file of files) {
      itemsToShare.push({
        ...file,
        metadata: file.metadata,
        parent: "none",
        type: "file"
      });
    }
    const directoryPromises = [];
    for (const directory of directories) {
      itemsToShare.push({
        ...directory,
        metadata: directory.metadata,
        parent: "none",
        type: "folder"
      });
      directoryPromises.push(new Promise((resolve, reject) => {
        this.getDirectoryTree({ uuid: directory.uuid }).then((tree) => {
          for (const entry in tree) {
            const item = tree[entry];
            if (!item || item.type === "file" && item.key.length === 0) {
              continue;
            }
            if (item.parent === "base" || item.uuid === directory.uuid) {
              continue;
            }
            if (item.type === "directory") {
              itemsToShare.push({
                uuid: item.uuid,
                metadata: {
                  name: item.name
                },
                parent: item.parent,
                type: "folder"
              });
            } else {
              itemsToShare.push({
                uuid: item.uuid,
                metadata: {
                  name: item.name,
                  size: item.size,
                  mime: item.mime,
                  lastModified: item.lastModified,
                  key: item.key,
                  creation: item.creation,
                  hash: item.hash
                },
                parent: item.parent,
                type: "file"
              });
            }
          }
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(directoryPromises);
    const sharePromises = [];
    let done = 0;
    for (const item of itemsToShare) {
      sharePromises.push(new Promise((resolve, reject) => {
        this.shareItem({
          uuid: item.uuid,
          parent: item.parent,
          email,
          type: item.type,
          publicKey,
          metadata: item.metadata
        }).then(() => {
          done += 1;
          if (onProgress) {
            onProgress(done, itemsToShare.length);
          }
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(sharePromises);
  }
  /**
   * Checks if the parent of an item is shared or public linked.
   * If so, it adds the item and all children of the item (in case of a directory) to the share or public link.
   * @date 2/17/2024 - 4:26:44 AM
   *
   * @public
   * @async
   * @param {{
   * 		type: "file" | "directory"
   * 		parent: string
   * 		uuid: string
   * 		itemMetadata: FileMetadata | FolderMetadata
   * 	}} param0
   * @param {("file" | "directory")} param0.type
   * @param {string} param0.parent
   * @param {string} param0.uuid
   * @param {*} param0.itemMetadata
   * @returns {Promise<void>}
   */
  async checkIfItemParentIsShared({ type, parent, uuid, itemMetadata }) {
    const [isSharingParent, isLinkingParent] = await Promise.all([
      this.api.v3().dir().shared({ uuid: parent }),
      this.api.v3().dir().linked({ uuid: parent })
    ]);
    if (!isSharingParent.sharing && !isLinkingParent.link) {
      return;
    }
    const promises = [];
    let tree = null;
    if (isSharingParent.sharing) {
      const filesToShare = [];
      const directoriesToShare = [];
      if (type === "file") {
        filesToShare.push({
          uuid,
          parent,
          metadata: itemMetadata
        });
      } else {
        directoriesToShare.push({
          uuid,
          parent,
          metadata: itemMetadata
        });
        if (!tree) {
          tree = await this.getDirectoryTree({ uuid });
        }
        for (const entry in tree) {
          const item = tree[entry];
          if (!item || item.type === "file" && item.key.length === 0) {
            continue;
          }
          if (item.uuid === uuid || item.parent === "base") {
            continue;
          }
          if (item.type === "file") {
            filesToShare.push({
              uuid: item.uuid,
              parent: item.parent,
              metadata: {
                name: item.name,
                size: item.size,
                mime: item.mime,
                key: item.key,
                lastModified: item.lastModified,
                creation: item.creation,
                hash: item.hash
              }
            });
          } else {
            directoriesToShare.push({
              uuid: item.uuid,
              parent: item.parent,
              metadata: {
                name: item.name
              }
            });
          }
        }
      }
      for (const file of filesToShare) {
        for (const user of isSharingParent.users) {
          promises.push(this.shareItem({
            uuid: file.uuid,
            parent: file.parent,
            email: user.email,
            publicKey: user.publicKey,
            metadata: file.metadata,
            type: "file"
          }));
        }
      }
      for (const directory of directoriesToShare) {
        for (const user of isSharingParent.users) {
          promises.push(this.shareItem({
            uuid: directory.uuid,
            parent: directory.parent,
            email: user.email,
            publicKey: user.publicKey,
            metadata: directory.metadata,
            type: "folder"
          }));
        }
      }
    }
    if (isLinkingParent.link) {
      const filesToLink = [];
      const directoriesToLink = [];
      if (type === "file") {
        filesToLink.push({
          uuid,
          parent,
          metadata: itemMetadata
        });
      } else {
        directoriesToLink.push({
          uuid,
          parent,
          metadata: itemMetadata
        });
        if (!tree) {
          tree = await this.getDirectoryTree({ uuid });
        }
        for (const entry in tree) {
          const item = tree[entry];
          if (!item || item.type === "file" && item.key.length === 0) {
            continue;
          }
          if (item.uuid === uuid || item.parent === "base") {
            continue;
          }
          if (item.type === "file") {
            filesToLink.push({
              uuid: item.uuid,
              parent: item.parent,
              metadata: {
                name: item.name,
                size: item.size,
                mime: item.mime,
                key: item.key,
                lastModified: item.lastModified,
                creation: item.creation,
                hash: item.hash
              }
            });
          } else {
            directoriesToLink.push({
              uuid: item.uuid,
              parent: item.parent,
              metadata: {
                name: item.name
              }
            });
          }
        }
      }
      for (const file of filesToLink) {
        for (const link of isLinkingParent.links) {
          promises.push(this.addItemToDirectoryPublicLink({
            uuid: file.uuid,
            parent: file.parent,
            metadata: file.metadata,
            type: "file",
            linkUUID: link.linkUUID,
            linkKeyEncrypted: link.linkKey,
            expiration: "never"
          }));
        }
      }
      for (const directory of directoriesToLink) {
        for (const link of isLinkingParent.links) {
          promises.push(this.addItemToDirectoryPublicLink({
            uuid: directory.uuid,
            parent: directory.parent,
            metadata: directory.metadata,
            type: "folder",
            linkUUID: link.linkUUID,
            linkKeyEncrypted: link.linkKey,
            expiration: "never"
          }));
        }
      }
    }
    if (promises.length > 0) {
      await promiseAllChunked(promises);
    }
  }
  /**
   * Rename a shared item.
   * @date 2/17/2024 - 4:32:56 AM
   *
   * @private
   * @async
   * @param {({uuid: string, receiverId: number, metadata: FileMetadata | FolderMetadata, publicKey: string})} param0
   * @param {string} param0.uuid
   * @param {number} param0.receiverId
   * @param {*} param0.metadata
   * @param {string} param0.publicKey
   * @returns {Promise<void>}
   */
  async renameSharedItem({ uuid, receiverId, metadata, publicKey }) {
    const metadataEncrypted = await this.sdk.getWorker().crypto.encrypt.metadataPublic({ metadata: JSON.stringify(metadata), publicKey });
    await this.api.v3().item().sharedRename({ uuid, receiverId, metadata: metadataEncrypted });
  }
  /**
   * Rename a publicly linked item.
   * @date 2/17/2024 - 4:35:07 AM
   *
   * @private
   * @async
   * @param {({uuid: string, linkUUID: string, metadata: FileMetadata | FolderMetadata, linkKeyEncrypted: string})} param0
   * @param {string} param0.uuid
   * @param {string} param0.linkUUID
   * @param {*} param0.metadata
   * @param {string} param0.linkKeyEncrypted
   * @returns {Promise<void>}
   */
  async renamePubliclyLinkedItem({ uuid, linkUUID, metadata, linkKeyEncrypted }) {
    const key = await this.sdk.getWorker().crypto.decrypt.folderLinkKey({
      metadata: linkKeyEncrypted
    });
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const metadataEncrypted = await this.sdk.getWorker().crypto.encrypt.metadata({
      metadata: JSON.stringify(metadata),
      key
    });
    await this.api.v3().item().linkedRename({
      uuid,
      linkUUID,
      metadata: metadataEncrypted
    });
  }
  /**
   * Checks if an item is shared or public linked.
   * If so, it renames the item.
   * @date 2/17/2024 - 4:37:30 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		itemMetadata: FileMetadata | FolderMetadata
   * 	}} param0
   * @param {string} param0.uuid
   * @param {*} param0.itemMetadata
   * @returns {Promise<void>}
   */
  async checkIfItemIsSharedForRename({ uuid, itemMetadata }) {
    const [isSharingItem, isLinkingItem] = await Promise.all([
      this.api.v3().item().shared({ uuid }),
      this.api.v3().item().linked({ uuid })
    ]);
    if (!isSharingItem.sharing && !isLinkingItem.link) {
      return;
    }
    const promises = [];
    if (isSharingItem.sharing) {
      for (const user of isSharingItem.users) {
        promises.push(this.renameSharedItem({
          uuid,
          receiverId: user.id,
          metadata: itemMetadata,
          publicKey: user.publicKey
        }));
      }
    }
    if (isLinkingItem.link) {
      for (const link of isLinkingItem.links) {
        promises.push(this.renamePubliclyLinkedItem({
          uuid,
          linkUUID: link.linkUUID,
          metadata: itemMetadata,
          linkKeyEncrypted: link.linkKey
        }));
      }
    }
    if (promises.length > 0) {
      await promiseAllChunked(promises);
    }
  }
  /**
   * Fetch directory size in bytes, including file and folder count.
   * @date 2/20/2024 - 9:21:16 PM
   *
   * @public
   * @async
   * @param {{uuid: string, sharerId?: number, receiverId?: number, trash?: boolean}} param0
   * @param {string} param0.uuid
   * @param {number} param0.sharerId
   * @param {number} param0.receiverId
   * @param {boolean} param0.trash
   * @returns {Promise<{ size: number; folders: number; files: number }>}
   */
  async directorySize({ uuid, sharerId, receiverId, trash }) {
    return await this.api.v3().dir().size({
      uuid,
      sharerId,
      receiverId,
      trash
    });
  }
  /**
   * Fetch size of a directory inside a public link in bytes, including file and folder count.
   * @date 2/20/2024 - 9:21:53 PM
   *
   * @public
   * @async
   * @param {{uuid: string, linkUUID: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.linkUUID
   * @returns {Promise<{ size: number, folders: number, files: number }>}
   */
  async directorySizePublicLink({ uuid, linkUUID }) {
    return await this.api.v3().dir().sizeLink({
      uuid,
      linkUUID
    });
  }
  /**
   * Download a file to a local path. Only works in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		chunks: number
   * 		version: FileEncryptionVersion
   * 		key: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		end?: number
   * 		start?: number
   * 		to?: string
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 		size: number
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {number} param0.chunks
   * @param {FileEncryptionVersion} param0.version
   * @param {string} param0.key
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {number} param0.start
   * @param {number} param0.end
   * @param {string} param0.to
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {number} param0.size
   * @returns {Promise<string>}
   */
  async downloadFileToLocal({ uuid, bucket, region, chunks, version, key, abortSignal, pauseSignal, start, end, to, onProgress, onProgressId, onQueued, onStarted, onError, onFinished, size }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    if (environment !== "node") {
      throw new Error(`cloud.downloadFileToLocal is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.downloadToLocal.acquire();
    try {
      const tmpDir = this.sdkConfig.tmpPath ? this.sdkConfig.tmpPath : import_os3.default.tmpdir();
      const destinationPath = normalizePath(to ? to : import_path5.default.join(tmpDir, "filen-sdk", await uuidv4()));
      await import_fs_extra9.default.ensureDir(destinationPath);
      await import_fs_extra9.default.rm(destinationPath, {
        force: true,
        maxRetries: 60 * 10,
        recursive: true,
        retryDelay: 100
      });
      const readStream = this.downloadFileToReadableStream({
        uuid,
        region,
        bucket,
        version,
        key,
        chunks,
        size,
        abortSignal,
        pauseSignal,
        onProgress,
        onProgressId,
        onError,
        onStarted,
        start,
        end
      });
      const writeStream = import_fs_extra9.default.createWriteStream(destinationPath);
      await pipelineAsync6(import_stream8.Readable.fromWeb(readStream), writeStream);
      if (onFinished) {
        onFinished();
      }
      return destinationPath;
    } finally {
      this._semaphores.downloadToLocal.release();
    }
  }
  /**
   * Download a file to a ReadableStream.
   *
   * @public
   * @param {{
   * 		uuid: string
   * 		bucket: string
   * 		region: string
   * 		version: FileEncryptionVersion
   * 		key: string
   * 		size: number
   * 		chunks: number
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		start?: number
   * 		end?: number
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 	}} param0
   * @param {string} param0.uuid
   * @param {string} param0.bucket
   * @param {string} param0.region
   * @param {FileEncryptionVersion} param0.version
   * @param {string} param0.key
   * @param {number} param0.size
   * @param {number} param0.chunks
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {number} param0.start
   * @param {number} param0.end
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @returns {ReadableStream<Buffer>}
   */
  downloadFileToReadableStream({ uuid, bucket, region, version, key, size, chunks, abortSignal, pauseSignal, start, end, onProgress, onProgressId, onQueued, onStarted, onError, onFinished }) {
    if (key.length === 0) {
      throw new Error("Invalid key.");
    }
    const streamEntireFile = typeof start === "undefined" && typeof end === "undefined";
    if (typeof start === "undefined") {
      start = 0;
    }
    if (typeof end === "undefined") {
      end = size - 1;
    }
    if (start <= 0 && end <= 0) {
      start = 0;
      end = 0;
    }
    if (end > size - 1 || start < 0 || start > end) {
      return new ReadableStream({
        start(controller) {
          controller.close();
        }
      });
    }
    const [firstChunkIndex, lastChunkIndex] = utils_default3.calculateChunkIndices({ start, end, chunks });
    const threadsSemaphore = new Semaphore(MAX_DOWNLOAD_THREADS);
    const writersSemaphore = new Semaphore(MAX_DOWNLOAD_WRITERS);
    const downloadsSemaphore = this._semaphores.downloadStream;
    const api = this.sdk.getWorker().api;
    const crypto2 = this.sdk.getWorker().crypto;
    let currentWriteIndex = firstChunkIndex;
    let writerStopped = false;
    let currentPullIndex = firstChunkIndex;
    const chunksPulled = { [firstChunkIndex]: true };
    const chunksToDownload = lastChunkIndex <= 0 ? 1 : lastChunkIndex >= chunks ? chunks : lastChunkIndex;
    let downloadsSemaphoreAcquired = false;
    let downloadsSemaphoreReleased = false;
    if (chunksToDownload === 0 || firstChunkIndex > lastChunkIndex || firstChunkIndex < 0 || lastChunkIndex < 0 || lastChunkIndex > chunks) {
      return new ReadableStream({
        start(controller) {
          controller.close();
        }
      });
    }
    const waitForPause = async () => {
      if (!pauseSignal || !pauseSignal.isPaused() || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || currentWriteIndex >= chunksToDownload) {
        return;
      }
      await new Promise((resolve) => {
        const wait = setInterval(() => {
          if (!pauseSignal.isPaused() || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || currentWriteIndex >= chunksToDownload) {
            clearInterval(wait);
            resolve();
          }
        }, 10);
      });
    };
    const waitForPull = async (index) => {
      if (chunksPulled[index] || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || currentWriteIndex >= chunksToDownload) {
        return;
      }
      await new Promise((resolve) => {
        const wait = setInterval(() => {
          if (chunksPulled[index] || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || currentWriteIndex >= chunksToDownload) {
            clearInterval(wait);
            resolve();
          }
        }, 10);
      });
    };
    const waitForWritesToBeDone = async () => {
      if (currentWriteIndex >= chunksToDownload || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted)) {
        return;
      }
      await new Promise((resolve) => {
        const wait = setInterval(() => {
          if (currentWriteIndex >= chunksToDownload || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted)) {
            clearInterval(wait);
            resolve();
          }
        }, 10);
      });
    };
    const applyBackpressure = async (controller) => {
      if (writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || currentWriteIndex >= chunksToDownload) {
        return;
      }
      if ((controller.desiredSize ?? 1) <= 0) {
        await new Promise((resolve) => {
          const wait = setInterval(() => {
            if (controller.desiredSize && controller.desiredSize > 0 || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || currentWriteIndex >= chunksToDownload) {
              clearInterval(wait);
              resolve();
            }
          }, 10);
        });
      }
    };
    const waitForWriteSlot = async (index) => {
      if (currentWriteIndex >= chunksToDownload || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || index === currentWriteIndex || index >= chunksToDownload) {
        return;
      }
      await new Promise((resolve) => {
        const wait = setInterval(() => {
          if (currentWriteIndex >= chunksToDownload || writerStopped || (abortSignal == null ? void 0 : abortSignal.aborted) || index === currentWriteIndex || index >= chunksToDownload) {
            clearInterval(wait);
            resolve();
          }
        }, 10);
      });
    };
    return new ReadableStream({
      start(controller) {
        ;
        (async () => {
          const write = async ({ index, buffer }) => {
            try {
              if (abortSignal && abortSignal.aborted || writerStopped) {
                throw new Error("Aborted");
              }
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              await waitForWriteSlot(index);
              if (abortSignal && abortSignal.aborted || writerStopped) {
                throw new Error("Aborted");
              }
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (buffer.byteLength > 0) {
                let bufferToEnqueue = buffer;
                if (!streamEntireFile) {
                  const chunkStartOffset = index * UPLOAD_CHUNK_SIZE;
                  const startInChunk = index === Math.floor(start / UPLOAD_CHUNK_SIZE) ? start % UPLOAD_CHUNK_SIZE : 0;
                  const endInChunk = Math.min(UPLOAD_CHUNK_SIZE, end - chunkStartOffset + 1);
                  bufferToEnqueue = bufferToEnqueue.subarray(startInChunk, endInChunk);
                }
                await applyBackpressure(controller);
                if (!writerStopped) {
                  controller.enqueue(bufferToEnqueue);
                  if (onProgress) {
                    onProgress(bufferToEnqueue.byteLength, onProgressId);
                  }
                }
              }
              currentWriteIndex += 1;
              writersSemaphore.release();
            } catch (e) {
              writersSemaphore.release();
              throw e;
            }
          };
          if (onQueued) {
            onQueued();
          }
          await downloadsSemaphore.acquire();
          downloadsSemaphoreAcquired = true;
          if (onStarted) {
            onStarted();
          }
          try {
            await new Promise((resolve, reject) => {
              let done = firstChunkIndex;
              for (let index = firstChunkIndex; index < chunksToDownload; index++) {
                ;
                (async () => {
                  try {
                    await waitForPull(index);
                    if (abortSignal && abortSignal.aborted || writerStopped) {
                      throw new Error("Aborted");
                    }
                    if (pauseSignal && pauseSignal.isPaused()) {
                      await waitForPause();
                    }
                    await Promise.all([threadsSemaphore.acquire(), writersSemaphore.acquire()]);
                    if (abortSignal && abortSignal.aborted || writerStopped) {
                      throw new Error("Aborted");
                    }
                    if (pauseSignal && pauseSignal.isPaused()) {
                      await waitForPause();
                    }
                    const encryptedBuffer = await api.v3.file.download.chunk.buffer.fetch({
                      uuid,
                      bucket,
                      region,
                      chunk: index,
                      abortSignal
                    });
                    if (abortSignal && abortSignal.aborted || writerStopped) {
                      throw new Error("Aborted");
                    }
                    if (pauseSignal && pauseSignal.isPaused()) {
                      await waitForPause();
                    }
                    const decryptedBuffer = await crypto2.decrypt.data({
                      data: encryptedBuffer,
                      key,
                      version
                    });
                    if (abortSignal && abortSignal.aborted || writerStopped) {
                      throw new Error("Aborted");
                    }
                    if (pauseSignal && pauseSignal.isPaused()) {
                      await waitForPause();
                    }
                    write({
                      index,
                      buffer: decryptedBuffer
                    }).catch((err) => {
                      writerStopped = true;
                      reject(err);
                    });
                    done += 1;
                    threadsSemaphore.release();
                    if (done >= chunksToDownload) {
                      resolve();
                    }
                  } catch (e) {
                    threadsSemaphore.release();
                    writersSemaphore.release();
                    writerStopped = true;
                    reject(e);
                  }
                })();
              }
            });
            await waitForWritesToBeDone();
          } catch (e) {
            if (onError) {
              onError(e);
            }
            if (!(e instanceof Error && e.message.toLowerCase().includes("aborted"))) {
              throw e;
            }
          } finally {
            if (downloadsSemaphoreAcquired && !downloadsSemaphoreReleased) {
              downloadsSemaphoreReleased = true;
              downloadsSemaphore.release();
            }
            try {
              controller.close();
            } catch {
            }
          }
          if (onFinished) {
            onFinished();
          }
        })();
      },
      pull() {
        currentPullIndex += 1;
        chunksPulled[currentPullIndex] = true;
      },
      cancel() {
        writerStopped = true;
        if (downloadsSemaphoreAcquired && !downloadsSemaphoreReleased) {
          downloadsSemaphoreReleased = true;
          downloadsSemaphore.release();
        }
      }
    }, {
      highWaterMark: 16,
      size() {
        return UPLOAD_CHUNK_SIZE;
      }
    });
  }
  /**
   * Build a recursive directory tree which includes sub-directories and sub-files.
   * @date 2/22/2024 - 1:45:28 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		type?: DirDownloadType
   * 		linkUUID?: string
   * 		linkHasPassword?: boolean
   * 		linkPassword?: string
   * 		linkSalt?: string
   * 		skipCache?: boolean
   * 	}} param0
   * @param {string} param0.uuid
   * @param {DirDownloadType} [param0.type="normal"]
   * @param {string} param0.linkUUID
   * @param {boolean} param0.linkHasPassword
   * @param {string} param0.linkPassword
   * @param {string} param0.linkSalt
   * @param {boolean} param0.skipCache
   * @returns {Promise<Record<string, CloudItemTree>>}
   */
  async getDirectoryTree({ uuid, type = "normal", linkUUID, linkHasPassword, linkPassword, linkSalt, skipCache, linkKey }) {
    const contents = await this.api.v3().dir().download({
      uuid,
      type,
      linkUUID,
      linkHasPassword,
      linkPassword,
      linkSalt,
      skipCache
    });
    const tree = {};
    const folderNames = { base: "/" };
    for (const folder of contents.folders) {
      try {
        const decrypted = type === "shared" ? await this.sdk.getWorker().crypto.decrypt.folderMetadataPrivate({ metadata: folder.name }) : type === "linked" && linkKey ? await this.sdk.getWorker().crypto.decrypt.folderMetadataLink({
          metadata: folder.name,
          linkKey
        }) : await this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: folder.name });
        const parentPath = folder.parent === "base" ? "" : `${folderNames[folder.parent]}`;
        const folderPath = folder.parent === "base" ? "/" : import_path5.default.posix.join(parentPath, decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`);
        folderNames[folder.uuid] = folderPath;
        tree[folderPath] = {
          type: "directory",
          uuid: folder.uuid,
          name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${folder.uuid}`,
          parent: folder.parent,
          size: 0,
          timestamp: typeof folder.timestamp === "number" ? convertTimestampToMs(folder.timestamp) : Date.now(),
          lastModified: typeof folder.timestamp === "number" ? convertTimestampToMs(folder.timestamp) : Date.now()
        };
      } catch {
        continue;
      }
    }
    if (Object.keys(folderNames).length === 0) {
      throw new Error("Could not build directory tree.");
    }
    const promises = [];
    for (const file of contents.files) {
      promises.push(new Promise((resolve, reject) => {
        const decryptPromise = type === "shared" ? this.sdk.getWorker().crypto.decrypt.fileMetadataPrivate({ metadata: file.metadata }) : type === "linked" && linkKey ? this.sdk.getWorker().crypto.decrypt.fileMetadataLink({
          metadata: file.metadata,
          linkKey
        }) : this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata });
        decryptPromise.then((decrypted) => {
          const parentPath = folderNames[file.parent];
          if (!parentPath) {
            resolve();
            return;
          }
          const filePath = import_path5.default.posix.join(parentPath, decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`);
          if (filePath.length === 0) {
            resolve();
            return;
          }
          tree[filePath] = {
            type: "file",
            uuid: file.uuid,
            name: decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${file.uuid}`,
            size: realFileSize({
              chunksSize: file.chunksSize,
              metadataDecrypted: decrypted
            }),
            mime: decrypted.name.length > 0 ? decrypted.mime : "application/octet-stream",
            lastModified: convertTimestampToMs(decrypted.name.length > 0 ? decrypted.lastModified : Date.now()),
            parent: file.parent,
            version: file.version,
            chunks: file.chunks,
            key: decrypted.name.length > 0 ? decrypted.key : "",
            bucket: file.bucket,
            region: file.region,
            creation: decrypted.name.length > 0 ? decrypted.creation : void 0,
            hash: decrypted.name.length > 0 ? decrypted.hash : void 0,
            timestamp: typeof file.timestamp === "number" ? convertTimestampToMs(file.timestamp) : Date.now()
          };
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return tree;
  }
  /**
   * Download a directory to path. Only available in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 		type?: DirDownloadType
   * 		linkUUID?: string
   * 		linkHasPassword?: boolean
   * 		linkPassword?: string
   * 		linkSalt?: string
   * 		linkKey?: string
   * 		to?: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 	}} param0
   * @param {string} param0.uuid
   * @param {DirDownloadType} [param0.type="normal"]
   * @param {string} param0.linkUUID
   * @param {boolean} param0.linkHasPassword
   * @param {string} param0.linkPassword
   * @param {string} param0.linkSalt
   * @param {string} param0.to
   * @param {AbortSignal} param0.abortSignal
   * @param {PauseSignal} param0.pauseSignal
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {string} param0.linkKey
   * @returns {Promise<string>}
   */
  async downloadDirectoryToLocal({ uuid, type = "normal", linkUUID, linkHasPassword, linkPassword, linkSalt, to, abortSignal, pauseSignal, onQueued, onStarted, onError, onFinished, onProgress, onProgressId, linkKey }) {
    if (environment !== "node") {
      throw new Error(`cloud.downloadDirectoryToLocal is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.directoryDownloads.acquire();
    let destinationPath = null;
    try {
      if (onStarted) {
        onStarted();
      }
      const tmpDir = this.sdkConfig.tmpPath ? this.sdkConfig.tmpPath : import_os3.default.tmpdir();
      destinationPath = normalizePath(to ? to : import_path5.default.join(tmpDir, "filen-sdk", await uuidv4()));
      await import_fs_extra9.default.rm(destinationPath, {
        force: true,
        maxRetries: 60 * 10,
        recursive: true,
        retryDelay: 100
      });
      await import_fs_extra9.default.mkdir(destinationPath, {
        recursive: true
      });
      const tree = await this.getDirectoryTree({
        uuid,
        type,
        linkUUID,
        linkHasPassword,
        linkPassword,
        linkSalt,
        linkKey
      });
      const promises = [];
      for (const path in tree) {
        const item = tree[path];
        if (!item || item.type !== "file" || item.key.length === 0) {
          continue;
        }
        const filePath = import_path5.default.join(destinationPath, path);
        promises.push(new Promise((resolve, reject) => {
          this.downloadFileToLocal({
            uuid: item.uuid,
            bucket: item.bucket,
            region: item.region,
            chunks: item.chunks,
            version: item.version,
            key: item.key,
            abortSignal,
            pauseSignal,
            to: filePath,
            onProgress,
            onProgressId,
            size: item.size
          }).then(() => resolve()).catch(reject);
        }));
      }
      await promiseAllChunked(promises);
      if (onFinished) {
        onFinished();
      }
      return destinationPath;
    } catch (e) {
      if (destinationPath) {
        await import_fs_extra9.default.rm(destinationPath, {
          force: true,
          maxRetries: 60 * 10,
          recursive: true,
          retryDelay: 100
        });
      }
      if (onError) {
        onError(e);
      }
      throw e;
    } finally {
      this._semaphores.directoryDownloads.release();
    }
  }
  /**
   * Upload a local file. Only available in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		source: string
   * 		parent: string
   * 		name?: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 		onUploaded?: (item: CloudItem) => Promise<void>
   * 	}} param0
   * @param {string} param0.source
   * @param {string} param0.parent
   * @param {string} param0.name
   * @param {PauseSignal} param0.pauseSignal
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {(item: CloudItem) => Promise<void>} param0.onUploaded
   * @returns {Promise<CloudItem>}
   */
  async uploadLocalFile({ source, parent, name, pauseSignal, abortSignal, onProgress, onProgressId, onQueued, onStarted, onError, onFinished, onUploaded }) {
    if (environment !== "node") {
      throw new Error(`cloud.uploadFileFromLocal is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.uploads.acquire();
    try {
      if (onStarted) {
        onStarted();
      }
      source = normalizePath(source);
      if (!await import_fs_extra9.default.exists(source)) {
        throw new Error(`Could not find source file at path ${source}.`);
      }
      const fileName = name ? name : import_path5.default.basename(source);
      if (fileName === "." || fileName === "/" || fileName.length <= 0) {
        throw new Error(`Invalid source file at path ${source}. Could not parse file name.`);
      }
      const mimeType = import_mime_types2.default.lookup(fileName) || "application/octet-stream";
      const fileStats = await import_fs_extra9.default.stat(source);
      if (!fileStats.isFile() || fileStats.isDirectory() || fileStats.isSymbolicLink() || fileStats.isSocket() || fileStats.isBlockDevice() || fileStats.isCharacterDevice()) {
        throw new Error(`Invalid source file at path ${source}. Not a file.`);
      }
      if (fileStats.size <= 0) {
        throw new Error(`Invalid source file at path ${source}. 0 bytes.`);
      }
      const fileSize = fileStats.size;
      let fileChunks = Math.ceil(fileSize / UPLOAD_CHUNK_SIZE);
      const lastModified = parseInt(fileStats.mtimeMs.toString());
      const creation = parseInt(fileStats.birthtimeMs.toString());
      let bucket = DEFAULT_UPLOAD_BUCKET;
      let region = DEFAULT_UPLOAD_REGION;
      const uploadThreads = new Semaphore(MAX_UPLOAD_THREADS);
      let aborted = false;
      const [uuid, key, rm, uploadKey] = await Promise.all([
        uuidv4(),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 }),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 }),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 })
      ]);
      const [nameEncrypted, mimeEncrypted, sizeEncrypted, metadata, nameHashed] = await Promise.all([
        this.sdk.getWorker().crypto.encrypt.metadata({ metadata: fileName, key }),
        this.sdk.getWorker().crypto.encrypt.metadata({ metadata: mimeType, key }),
        this.sdk.getWorker().crypto.encrypt.metadata({ metadata: fileSize.toString(), key }),
        this.sdk.getWorker().crypto.encrypt.metadata({
          metadata: JSON.stringify({
            name: fileName,
            size: fileSize,
            mime: mimeType,
            key,
            lastModified,
            creation
          })
        }),
        this.sdk.getWorker().crypto.utils.hashFn({ input: fileName.toLowerCase() })
      ]);
      const waitForPause = async () => {
        if (!pauseSignal || !pauseSignal.isPaused() || (abortSignal == null ? void 0 : abortSignal.aborted) || aborted) {
          return;
        }
        await new Promise((resolve) => {
          const wait = setInterval(() => {
            if (!pauseSignal.isPaused() || (abortSignal == null ? void 0 : abortSignal.aborted) || aborted) {
              clearInterval(wait);
              resolve();
            }
          }, 10);
        });
      };
      await new Promise((resolve, reject) => {
        let done2 = 0;
        for (let i = 0; i < fileChunks; i++) {
          const index = i;
          (async () => {
            await uploadThreads.acquire();
            try {
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (abortSignal && abortSignal.aborted) {
                reject(new Error("Aborted"));
                return;
              }
              const chunkBuffer = await utils_default3.readLocalFileChunk({
                path: source,
                offset: index * UPLOAD_CHUNK_SIZE,
                length: UPLOAD_CHUNK_SIZE
              });
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (abortSignal && abortSignal.aborted) {
                reject(new Error("Aborted"));
                return;
              }
              const encryptedChunkBuffer = await this.sdk.getWorker().crypto.encrypt.data({
                data: chunkBuffer,
                key
              });
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (abortSignal && abortSignal.aborted) {
                reject(new Error("Aborted"));
                return;
              }
              const uploadResponse = await this.sdk.getWorker().api.v3.file.upload.chunk.buffer.fetch({
                uuid,
                index,
                parent,
                uploadKey,
                abortSignal,
                buffer: encryptedChunkBuffer,
                onProgress,
                onProgressId
              });
              bucket = uploadResponse.bucket;
              region = uploadResponse.region;
              done2 += 1;
              uploadThreads.release();
              if (done2 >= fileChunks) {
                resolve();
              }
            } catch (e) {
              aborted = true;
              uploadThreads.release();
              throw e;
            }
          })().catch((err) => {
            aborted = true;
            reject(err);
          });
        }
      });
      const done = await this.api.v3().upload().done({
        uuid,
        name: nameEncrypted,
        nameHashed,
        size: sizeEncrypted,
        chunks: fileChunks,
        mime: mimeEncrypted,
        rm,
        metadata,
        version: CURRENT_FILE_ENCRYPTION_VERSION,
        uploadKey
      });
      fileChunks = done.chunks;
      const item = {
        type: "file",
        uuid,
        name: fileName,
        size: fileSize,
        mime: mimeType,
        lastModified,
        timestamp: Date.now(),
        parent,
        rm,
        version: CURRENT_FILE_ENCRYPTION_VERSION,
        chunks: fileChunks,
        favorited: false,
        key,
        bucket,
        region,
        creation
      };
      await this.checkIfItemParentIsShared({
        type: "file",
        parent,
        uuid,
        itemMetadata: {
          name: fileName,
          size: fileSize,
          mime: mimeType,
          lastModified,
          creation,
          key
        }
      });
      if (onUploaded) {
        await onUploaded.call(void 0, item);
      }
      if (onFinished) {
        onFinished();
      }
      return item;
    } catch (e) {
      if (onError) {
        onError(e);
      }
      throw e;
    } finally {
      this._semaphores.uploads.release();
    }
  }
  /**
   * Upload a file using Node.JS streams. It's not as fast as the normal uploadFile function since it's not completely multithreaded.
   * Only available in a Node.JS environment.
   * @public
   * @async
   * @param {{
   * 		source: NodeJS.ReadableStream
   * 		parent: string
   * 		name: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 		onUploaded?: (item: CloudItem) => Promise<void>
   * 		lastModified?: number
   * 		creation?: number
   * 	}} param0
   * @param {NodeJS.ReadableStream} param0.source
   * @param {string} param0.parent
   * @param {string} param0.name
   * @param {PauseSignal} param0.pauseSignal
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {(item: CloudItem) => Promise<void>} param0.onUploaded
   * @param {number} param0.lastModified
   * @param {number} param0.creation
   * @returns {Promise<CloudItem>}
   */
  async uploadLocalFileStream({ source, parent, name, pauseSignal, abortSignal, onProgress, onProgressId, onQueued, onStarted, onError, onFinished, onUploaded, lastModified, creation }) {
    if (environment !== "node") {
      throw new Error(`cloud.uploadLocalFileStream is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.uploads.acquire();
    try {
      if (onStarted) {
        onStarted();
      }
      if (name === "." || name === "/" || name.length <= 0) {
        throw new Error("Invalid source file name. ");
      }
      let aborted = false;
      let closed = false;
      const [uuid, key, uploadKey] = await Promise.all([
        uuidv4(),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 }),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 })
      ]);
      const waitForPause = async () => {
        if (!pauseSignal || !pauseSignal.isPaused() || (abortSignal == null ? void 0 : abortSignal.aborted) || aborted || closed) {
          return;
        }
        return await new Promise((resolve) => {
          const wait = setInterval(() => {
            if (!pauseSignal.isPaused() || (abortSignal == null ? void 0 : abortSignal.aborted) || aborted || closed) {
              clearInterval(wait);
              resolve();
            }
          }, 10);
        });
      };
      const item = await new Promise((resolve, reject) => {
        const transformer = new import_stream8.Transform({
          transform(chunk, _, callback) {
            waitForPause().then(() => {
              callback(null, chunk);
            }).catch((err) => {
              callback(err);
            });
          }
        });
        const writeStream = new ChunkedUploadWriter({
          options: {
            highWaterMark: BUFFER_SIZE
          },
          sdk: this.sdk,
          uuid,
          key,
          uploadKey,
          name,
          parent,
          onProgress,
          onProgressId,
          lastModified,
          creation
        });
        const cleanup = () => {
          try {
            if (!writeStream.destroyed || !writeStream.closed || !writeStream.errored) {
              writeStream.destroy();
            }
            if (!transformer.destroyed || !transformer.closed || !transformer.errored) {
              transformer.destroy();
            }
          } catch {
          }
        };
        writeStream.once("uploaded", (item2) => {
          resolve({
            type: "file",
            uuid,
            name: item2.metadata.name,
            size: item2.type === "directory" ? 0 : item2.metadata.size,
            mime: item2.type === "directory" ? "application/octet-stream" : item2.metadata.mime,
            lastModified: item2.type === "directory" ? Date.now() : item2.metadata.lastModified,
            timestamp: Date.now(),
            parent,
            rm: "",
            version: CURRENT_FILE_ENCRYPTION_VERSION,
            chunks: item2.type === "directory" ? 0 : item2.metadata.chunks,
            favorited: false,
            key,
            bucket: item2.type === "directory" ? "" : item2.metadata.bucket,
            region: item2.type === "directory" ? "" : item2.metadata.region,
            creation: item2.type === "directory" ? void 0 : item2.metadata.creation
          });
        });
        writeStream.once("close", () => {
          closed = true;
        });
        writeStream.once("finish", () => {
          closed = true;
        });
        transformer.once("close", () => {
          closed = true;
        });
        transformer.once("finish", () => {
          closed = true;
        });
        source.once("close", () => {
          closed = true;
        });
        source.once("finish", () => {
          closed = true;
        });
        pipelineAsync6(source, transformer, writeStream, { signal: abortSignal }).then(() => {
          closed = true;
        }).catch((err) => {
          aborted = true;
          setTimeout(cleanup, 3e3);
          reject(err);
        });
      });
      if (onUploaded) {
        await onUploaded.call(void 0, item);
      }
      if (onFinished) {
        onFinished();
      }
      return item;
    } catch (e) {
      if (onError) {
        onError(e);
      }
      throw e;
    } finally {
      this._semaphores.uploads.release();
    }
  }
  /**
   * Upload a web-based file, such as from an <input /> field. Only works in a browser environment.
   *
   * @public
   * @async
   * @param {{
   * 		file: File
   * 		parent: string
   * 		name?: string
   * 		uuid?: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 		onUploaded?: (item: CloudItem) => Promise<void>
   * 	}} param0
   * @param {File} param0.file
   * @param {string} param0.parent
   * @param {string} param0.name
   * @param {string} param0.uuid
   * @param {PauseSignal} param0.pauseSignal
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {(item: CloudItem) => Promise<void>} param0.onUploaded
   * @returns {Promise<CloudItem>}
   */
  async uploadWebFile({ file, parent, name, uuid, pauseSignal, abortSignal, onProgress, onProgressId, onQueued, onStarted, onError, onFinished, onUploaded }) {
    if (environment !== "browser") {
      throw new Error(`cloud.uploadWebFile is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.uploads.acquire();
    try {
      if (onStarted) {
        onStarted();
      }
      const fileName = name ? name : file.name;
      const mimeType = import_mime_types2.default.lookup(fileName) || "application/octet-stream";
      const fileSize = file.size;
      if (fileSize <= 0) {
        throw new Error("Empty files are not supported.");
      }
      let fileChunks = Math.ceil(fileSize / UPLOAD_CHUNK_SIZE);
      const lastModified = file.lastModified;
      let bucket = DEFAULT_UPLOAD_BUCKET;
      let region = DEFAULT_UPLOAD_REGION;
      const uploadThreads = new Semaphore(MAX_UPLOAD_THREADS);
      let aborted = false;
      const [fileUUID, key, rm, uploadKey] = await Promise.all([
        uuid ? Promise.resolve(uuid) : uuidv4(),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 }),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 }),
        this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 })
      ]);
      const [nameEncrypted, mimeEncrypted, sizeEncrypted, metadata, nameHashed] = await Promise.all([
        this.sdk.getWorker().crypto.encrypt.metadata({ metadata: fileName, key }),
        this.sdk.getWorker().crypto.encrypt.metadata({ metadata: mimeType, key }),
        this.sdk.getWorker().crypto.encrypt.metadata({ metadata: fileSize.toString(), key }),
        this.sdk.getWorker().crypto.encrypt.metadata({
          metadata: JSON.stringify({
            name: fileName,
            size: fileSize,
            mime: mimeType,
            key,
            lastModified
          })
        }),
        this.sdk.getWorker().crypto.utils.hashFn({ input: fileName.toLowerCase() })
      ]);
      const waitForPause = async () => {
        if (!pauseSignal || !pauseSignal.isPaused() || (abortSignal == null ? void 0 : abortSignal.aborted) || aborted) {
          return;
        }
        await new Promise((resolve) => {
          const wait = setInterval(() => {
            if (!pauseSignal.isPaused() || (abortSignal == null ? void 0 : abortSignal.aborted) || aborted) {
              clearInterval(wait);
              resolve();
            }
          }, 10);
        });
      };
      await new Promise((resolve, reject) => {
        let done2 = 0;
        for (let i = 0; i < fileChunks; i++) {
          const index = i;
          (async () => {
            await uploadThreads.acquire();
            try {
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (abortSignal && abortSignal.aborted) {
                reject(new Error("Aborted"));
                return;
              }
              const chunkBuffer = await utils_default3.readWebFileChunk({
                file,
                index,
                length: UPLOAD_CHUNK_SIZE
              });
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (abortSignal && abortSignal.aborted) {
                reject(new Error("Aborted"));
                return;
              }
              const encryptedChunkBuffer = await this.sdk.getWorker().crypto.encrypt.data({
                data: chunkBuffer,
                key
              });
              if (pauseSignal && pauseSignal.isPaused()) {
                await waitForPause();
              }
              if (abortSignal && abortSignal.aborted) {
                reject(new Error("Aborted"));
                return;
              }
              const uploadResponse = await this.sdk.getWorker().api.v3.file.upload.chunk.buffer.fetch({
                uuid: fileUUID,
                index,
                parent,
                uploadKey,
                abortSignal,
                buffer: encryptedChunkBuffer,
                onProgress,
                onProgressId
              });
              bucket = uploadResponse.bucket;
              region = uploadResponse.region;
              done2 += 1;
              uploadThreads.release();
              if (done2 >= fileChunks) {
                resolve();
              }
            } catch (e) {
              aborted = true;
              uploadThreads.release();
              throw e;
            }
          })().catch((err) => {
            aborted = true;
            reject(err);
          });
        }
      });
      const done = await this.api.v3().upload().done({
        uuid: fileUUID,
        name: nameEncrypted,
        nameHashed,
        size: sizeEncrypted,
        chunks: fileChunks,
        mime: mimeEncrypted,
        rm,
        metadata,
        version: CURRENT_FILE_ENCRYPTION_VERSION,
        uploadKey
      });
      fileChunks = done.chunks;
      const item = {
        type: "file",
        uuid: fileUUID,
        name: fileName,
        size: fileSize,
        mime: mimeType,
        lastModified,
        timestamp: Date.now(),
        parent,
        rm,
        version: CURRENT_FILE_ENCRYPTION_VERSION,
        chunks: fileChunks,
        favorited: false,
        key,
        bucket,
        region
      };
      await this.checkIfItemParentIsShared({
        type: "file",
        parent,
        uuid: fileUUID,
        itemMetadata: {
          name: fileName,
          size: fileSize,
          mime: mimeType,
          lastModified,
          key
        }
      });
      if (onUploaded) {
        await onUploaded.call(void 0, item);
      }
      if (onFinished) {
        onFinished();
      }
      return item;
    } catch (e) {
      if (onError) {
        onError(e);
      }
      throw e;
    } finally {
      this._semaphores.uploads.release();
    }
  }
  /**
   * Upload a local file at path. Only works in a Node.JS environment.
   *
   * @public
   * @async
   * @param {{
   * 		source: string
   * 		parent: string
   * 		name?: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 		onUploaded?: (item: CloudItem) => Promise<void>
   * 		onDirectoryCreated?: (item: CloudItem) => void,
   * 		throwOnSingleFileUploadError?: boolean
   * 	}} param0
   * @param {string} param0.source
   * @param {string} param0.parent
   * @param {string} param0.name
   * @param {PauseSignal} param0.pauseSignal
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {(item: CloudItem) => Promise<void>} param0.onUploaded
   * @param {(item: CloudItem) => void} param0.onDirectoryCreated
   * @param {boolean} param0.throwOnSingleFileUploadError
   * @returns {Promise<void>}
   */
  async uploadLocalDirectory({ source, parent, name, pauseSignal, abortSignal, onProgress, onProgressId, onQueued, onStarted, onError, onFinished, onUploaded, onDirectoryCreated, throwOnSingleFileUploadError }) {
    if (environment !== "node") {
      throw new Error(`cloud.uploadLocalDirectory is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.directoryUploads.acquire();
    try {
      if (onStarted) {
        onStarted();
      }
      source = normalizePath(source);
      if (!await import_fs_extra9.default.exists(source)) {
        throw new Error(`Could not find source directory at path ${source}.`);
      }
      const baseDirectoryName = name ? name : import_path5.default.basename(source);
      if (baseDirectoryName === "." || baseDirectoryName === "/" || baseDirectoryName.length <= 0) {
        throw new Error(`Invalid source directory at path ${source}. Could not parse directory name.`);
      }
      parent = await this.createDirectory({
        name: baseDirectoryName,
        parent
      });
      const content = import_path5.default.sep === "\\" ? (await import_fs_extra9.default.readdir(source, {
        recursive: true
      })).map((entry) => entry.split("\\").join("/")) : await import_fs_extra9.default.readdir(source, {
        recursive: true
      });
      const sortedBySeparatorLength = content.sort((a, b) => a.split("/").length - b.split("/").length);
      const statPromises = [];
      const entryStats = {};
      const pathsToUUIDs = {};
      for (const entry of content) {
        statPromises.push(new Promise((resolve, reject) => {
          import_fs_extra9.default.stat(import_path5.default.join(source, entry)).then((stats) => {
            entryStats[entry] = stats;
            resolve();
          }).catch(reject);
        }));
      }
      await promiseAllChunked(statPromises);
      for (const entry of sortedBySeparatorLength) {
        if (pathsToUUIDs[entry]) {
          continue;
        }
        const stats = entryStats[entry];
        if (!stats || !stats.isDirectory() || stats.isSymbolicLink() || stats.isBlockDevice() || stats.isCharacterDevice() || stats.isSocket()) {
          continue;
        }
        const parentPath = import_path5.default.posix.dirname(entry);
        const directoryParent = parentPath === "." || parentPath === "/" || parentPath.length <= 0 ? parent : pathsToUUIDs[parentPath] ?? "";
        if (directoryParent.length <= 16) {
          continue;
        }
        const directoryName = import_path5.default.posix.basename(entry);
        if (directoryName.length <= 0) {
          continue;
        }
        const uuid = await this.createDirectory({
          name: directoryName,
          parent: directoryParent
        });
        pathsToUUIDs[entry] = uuid;
        if (onDirectoryCreated) {
          onDirectoryCreated({
            type: "directory",
            uuid,
            name: directoryName,
            timestamp: Date.now(),
            parent: directoryParent,
            lastModified: Date.now(),
            favorited: false,
            color: null,
            size: 0
          });
        }
      }
      const uploadPromises = [];
      for (const entry of sortedBySeparatorLength) {
        const stats = entryStats[entry];
        if (!stats || !stats.isFile() || stats.size <= 0 || stats.isSymbolicLink() || stats.isBlockDevice() || stats.isCharacterDevice() || stats.isSocket()) {
          continue;
        }
        const parentPath = import_path5.default.posix.dirname(entry);
        const fileParent = parentPath === "." || parentPath === "/" || parentPath.length <= 0 ? parent : pathsToUUIDs[parentPath] ?? "";
        if (fileParent.length <= 16) {
          continue;
        }
        uploadPromises.push(this.uploadLocalFile({
          source: import_path5.default.join(source, entry),
          parent: fileParent,
          abortSignal,
          pauseSignal,
          onProgress,
          onProgressId,
          onUploaded
        }));
      }
      if (throwOnSingleFileUploadError) {
        await promiseAllChunked(uploadPromises);
      } else {
        await promiseAllSettledChunked(uploadPromises);
      }
      if (onFinished) {
        onFinished();
      }
    } catch (e) {
      if (onError) {
        onError(e);
      }
      throw e;
    } finally {
      this._semaphores.directoryUploads.release();
    }
  }
  /**
   * Upload a web-based directory, such as from an <input /> field. Only works in a browser environment.
   *
   * @public
   * @async
   * @param {{
   * 		files: { file: File; path: string }[]
   * 		parent: string
   * 		name?: string
   * 		abortSignal?: AbortSignal
   * 		pauseSignal?: PauseSignal
   * 		onProgress?: ProgressCallback
   * 		onProgressId?: string
   * 		onQueued?: () => void
   * 		onStarted?: () => void
   * 		onError?: (err: Error) => void
   * 		onFinished?: () => void
   * 		onUploaded?: (item: CloudItem) => Promise<void>
   * 		onDirectoryCreated?: (item: CloudItem) => void
   * 		throwOnSingleFileUploadError?: boolean
   * 	}} param0
   * @param {{}} param0.files
   * @param {string} param0.parent
   * @param {string} param0.name
   * @param {PauseSignal} param0.pauseSignal
   * @param {AbortSignal} param0.abortSignal
   * @param {ProgressCallback} param0.onProgress
   * @param {string} param0.onProgressId
   * @param {() => void} param0.onQueued
   * @param {() => void} param0.onStarted
   * @param {(err: Error) => void} param0.onError
   * @param {() => void} param0.onFinished
   * @param {(item: CloudItem) => Promise<void>} param0.onUploaded
   * @param {(item: CloudItem) => void} param0.onDirectoryCreated
   * @param {boolean} param0.throwOnSingleFileUploadError
   * @returns {Promise<void>}
   */
  async uploadDirectoryFromWeb({ files, parent, name, pauseSignal, abortSignal, onProgress, onProgressId, onQueued, onStarted, onError, onFinished, onUploaded, onDirectoryCreated, throwOnSingleFileUploadError }) {
    if (environment !== "browser") {
      throw new Error(`cloud.uploadDirectoryFromWeb is not implemented for ${environment}`);
    }
    if (onQueued) {
      onQueued();
    }
    await this._semaphores.directoryUploads.acquire();
    try {
      if (onStarted) {
        onStarted();
      }
      let baseDirectoryName = name ? name : null;
      const pathsToUUIDs = {};
      const directoryPaths = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (!file || file.path.length <= 0 || file.file.size <= 0) {
          continue;
        }
        const ex = file.path.split("/");
        if (!name && ex[0] && ex[0].length > 0) {
          baseDirectoryName = ex[0].trim();
        }
        const parentPath = import_path5.default.posix.dirname(file.path);
        if (!directoryPaths.includes(parentPath)) {
          directoryPaths.push(parentPath);
        }
      }
      if (!baseDirectoryName) {
        throw new Error(`Can not upload directory to parent directory ${parent}. Could not parse base directory name.`);
      }
      for (const path of directoryPaths) {
        const possiblePaths = getEveryPossibleDirectoryPath(path);
        for (const possiblePath of possiblePaths) {
          if (!directoryPaths.includes(possiblePath)) {
            directoryPaths.push(possiblePath);
          }
        }
      }
      const directoryPathsSorted = directoryPaths.sort((a, b) => a.split("/").length - b.split("/").length);
      for (const path of directoryPathsSorted) {
        if (pathsToUUIDs[path]) {
          continue;
        }
        const parentPath = import_path5.default.posix.dirname(path);
        const directoryParent = parentPath === "." || parentPath === "/" || parentPath.length <= 0 ? parent : pathsToUUIDs[parentPath] ?? "";
        if (directoryParent.length <= 16) {
          continue;
        }
        const directoryName = import_path5.default.posix.basename(path);
        if (directoryName === "." || directoryName.length <= 0 || directoryName === "/") {
          continue;
        }
        const uuid = await this.createDirectory({
          name: directoryName,
          parent: directoryParent
        });
        pathsToUUIDs[path] = uuid;
        if (onDirectoryCreated) {
          onDirectoryCreated({
            type: "directory",
            uuid,
            name: directoryName,
            timestamp: Date.now(),
            parent: directoryParent,
            lastModified: Date.now(),
            favorited: false,
            color: null,
            size: 0
          });
        }
      }
      const uploadPromises = [];
      for (let i = 0; i < files.length; i++) {
        const file = files[i];
        if (!file) {
          continue;
        }
        const parentPath = import_path5.default.posix.dirname(file.path);
        const fileParent = parentPath === "." || parentPath === "/" || parentPath.length <= 0 ? parent : pathsToUUIDs[parentPath] ?? "";
        if (fileParent.length <= 16 || file.file.size <= 0) {
          continue;
        }
        uploadPromises.push(this.uploadWebFile({
          file: file.file,
          parent: fileParent,
          abortSignal,
          pauseSignal,
          onProgress,
          onProgressId,
          onUploaded
        }));
      }
      if (throwOnSingleFileUploadError) {
        await promiseAllChunked(uploadPromises);
      } else {
        await promiseAllSettledChunked(uploadPromises);
      }
      if (onFinished) {
        onFinished();
      }
    } catch (e) {
      if (onError) {
        onError(e);
      }
      throw e;
    } finally {
      this._semaphores.directoryUploads.release();
    }
  }
  /**
   * Empty the trash.
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async emptyTrash() {
    return await this.api.v3().trash().empty();
  }
  /**
   * Recursively find the full path of a file using it's UUID.
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<string>}
   */
  async fileUUIDToPath({ uuid }) {
    const pathParts = [];
    const file = await this.api.v3().file().get({ uuid });
    let nextParent = file.parent;
    const fileMetadataDecrypted = await this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata });
    pathParts.push(fileMetadataDecrypted.name.length > 0 ? fileMetadataDecrypted.name : `CANNOT_DECRYPT_NAME_${uuid}`);
    while (nextParent !== this.sdkConfig.baseFolderUUID) {
      const dir = await this.api.v3().dir().get({ uuid: nextParent });
      const decrypted = await this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: dir.nameEncrypted });
      pathParts.push(decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${dir.uuid}`);
      nextParent = dir.parent;
    }
    return `/${import_path5.default.posix.join(...pathParts.reverse())}`;
  }
  /**
   * Recursively find the full path of a file using it's UUID.
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<string>}
   */
  async directoryUUIDToPath({ uuid }) {
    const pathParts = [];
    const firstDir = await this.api.v3().dir().get({ uuid });
    let nextParent = firstDir.parent;
    const firstDirMetadataDecrypted = await this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: firstDir.nameEncrypted });
    pathParts.push(firstDirMetadataDecrypted.name.length > 0 ? firstDirMetadataDecrypted.name : `CANNOT_DECRYPT_NAME_${uuid}`);
    while (nextParent !== this.sdkConfig.baseFolderUUID) {
      const dir = await this.api.v3().dir().get({ uuid: nextParent });
      const decrypted = await this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: dir.nameEncrypted });
      pathParts.push(decrypted.name.length > 0 ? decrypted.name : `CANNOT_DECRYPT_NAME_${dir.uuid}`);
      nextParent = dir.parent;
    }
    return `/${import_path5.default.posix.join(...pathParts.reverse())}`;
  }
  /**
   * Get info about a file and decrypt its metadata.
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<GetFileResult>}
   */
  async getFile({ uuid }) {
    const file = await this.api.v3().file().get({ uuid });
    const fileMetadataDecrypted = await this.sdk.getWorker().crypto.decrypt.fileMetadata({ metadata: file.metadata });
    return {
      ...file,
      metadataDecrypted: fileMetadataDecrypted,
      chunks: Math.ceil(file.size / UPLOAD_CHUNK_SIZE)
    };
  }
  /**
   * Get info about a directory and decrypt its metadata.
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<GetDirResult>}
   */
  async getDirectory({ uuid }) {
    const dir = await this.api.v3().dir().get({ uuid });
    const dirMetadataDecrypted = await this.sdk.getWorker().crypto.decrypt.folderMetadata({ metadata: dir.nameEncrypted });
    return {
      ...dir,
      metadataDecrypted: dirMetadataDecrypted
    };
  }
};
var cloud_default = Cloud;

// node_modules/@filen/sdk/dist/browser/index.js
var import_path6 = __toESM(require_path());

// node_modules/@filen/sdk/dist/browser/chats/index.js
var Chats = class {
  /**
   * Creates an instance of Chats.
   * @date 2/9/2024 - 5:54:11 AM
   *
   * @constructor
   * @public
   * @param {ChatsConfig} params
   */
  constructor(params) {
    __publicField(this, "api");
    __publicField(this, "sdkConfig");
    __publicField(this, "_chatKeyCache", /* @__PURE__ */ new Map());
    __publicField(this, "sdk");
    this.api = params.api;
    this.sdkConfig = params.sdkConfig;
    this.sdk = params.sdk;
  }
  /**
   * Get the encryption key of a chat.
   * @date 2/20/2024 - 6:05:30 AM
   *
   * @public
   * @async
   * @param {{ conversation: string }} param0
   * @param {string} param0.conversation
   * @returns {Promise<string>}
   */
  async chatKey({ conversation }) {
    if (this._chatKeyCache.has(conversation)) {
      return this._chatKeyCache.get(conversation);
    }
    const all = await this.api.v3().chat().conversations();
    const chat = all.filter((chat2) => chat2.uuid === conversation);
    if (chat.length === 0 || !chat[0]) {
      throw new Error(`Could not find chat ${conversation}.`);
    }
    if (chat[0].ownerId === this.sdkConfig.userId && chat[0].ownerMetadata) {
      const decryptedChatKey2 = await this.sdk.getWorker().crypto.decrypt.chatKeyOwner({ metadata: chat[0].ownerMetadata });
      this._chatKeyCache.set(conversation, decryptedChatKey2);
      return decryptedChatKey2;
    }
    const participant = chat[0].participants.filter((participant2) => participant2.userId === this.sdkConfig.userId);
    if (participant.length === 0 || !participant[0]) {
      throw new Error(`Could not find participant metadata for chat ${conversation}.`);
    }
    const decryptedChatKey = await this.sdk.getWorker().crypto.decrypt.chatKeyParticipant({ metadata: participant[0].metadata, privateKey: this.sdkConfig.privateKey });
    this._chatKeyCache.set(conversation, decryptedChatKey);
    return decryptedChatKey;
  }
  /**
   * Fetch all chat conversations.
   * @date 2/20/2024 - 5:35:54 AM
   *
   * @public
   * @async
   * @returns {Promise<ChatConversation[]>}
   */
  async conversations() {
    const convos = await this.api.v3().chat().conversations();
    const chatConversations = [];
    const promises = [];
    for (const convo of convos) {
      promises.push(new Promise((resolve, reject) => {
        const metadata = convo.participants.filter((p) => p.userId === this.sdkConfig.userId);
        if (metadata.length === 0 || !metadata[0]) {
          reject(new Error("Conversation metadata not found."));
          return;
        }
        const keyPromise = this._chatKeyCache.has(convo.uuid) ? Promise.resolve(this._chatKeyCache.get(convo.uuid)) : this.chatKey({ conversation: convo.uuid });
        keyPromise.then((decryptedChatKey) => {
          this._chatKeyCache.set(convo.uuid, decryptedChatKey);
          const namePromise = typeof convo.name === "string" && convo.name.length > 0 ? this.sdk.getWorker().crypto.decrypt.chatConversationName({
            name: convo.name,
            key: decryptedChatKey
          }) : Promise.resolve("");
          const messagePromise = typeof convo.lastMessage === "string" && convo.lastMessage.length > 0 ? this.sdk.getWorker().crypto.decrypt.chatMessage({
            message: convo.lastMessage,
            key: decryptedChatKey
          }) : Promise.resolve("");
          Promise.all([namePromise, messagePromise]).then(([nameDecrypted, lastMessageDecrypted]) => {
            chatConversations.push({
              ...convo,
              lastMessage: lastMessageDecrypted,
              name: nameDecrypted
            });
            resolve();
          }).catch(reject);
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return chatConversations;
  }
  /**
   * Fetch all recent chat conversations.
   * @date 2/20/2024 - 5:37:59 AM
   *
   * @public
   * @async
   * @returns {Promise<ChatConversation[]>}
   */
  async conversationsRecents() {
    const convos = await this.conversations();
    return convos.sort((a, b) => b.lastMessageTimestamp - a.lastMessageTimestamp);
  }
  /**
   * Fetch a chat conversation.
   * @date 2/20/2024 - 5:39:11 AM
   *
   * @public
   * @async
   * @param {{conversation: string}} param0
   * @param {string} param0.conversation
   * @returns {Promise<ChatConversation>}
   */
  async get({ conversation }) {
    const convos = await this.conversations();
    const chat = convos.filter((convo) => convo.uuid === conversation);
    if (chat.length === 0) {
      throw new Error(`Chat conversation ${conversation} not found.`);
    }
    if (!chat[0]) {
      throw new Error("Chat not found");
    }
    return chat[0];
  }
  /**
   * Create a chat conversation. Optionally add participants to it.
   * @date 2/20/2024 - 5:48:07 AM
   *
   * @public
   * @async
   * @param {{ uuid?: string; contacts?: Contact[] }} param0
   * @param {string} param0.uuid
   * @param {{}} param0.contacts
   * @returns {Promise<string>}
   */
  async create({ uuid, contacts }) {
    const [uuidToUse, key] = await Promise.all([
      uuid ? Promise.resolve(uuid) : await uuidv4(),
      this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 })
    ]);
    const [metadata, ownerMetadata] = await Promise.all([
      this.sdk.getWorker().crypto.encrypt.metadataPublic({
        metadata: JSON.stringify({ key }),
        publicKey: this.sdkConfig.publicKey
      }),
      this.sdk.getWorker().crypto.encrypt.metadata({ metadata: JSON.stringify({ key }) })
    ]);
    await this.api.v3().chat().conversationsCreate({
      uuid: uuidToUse,
      metadata,
      ownerMetadata
    });
    this._chatKeyCache.set(uuidToUse, key);
    if (contacts) {
      await promiseAllChunked(contacts.map((contact) => this.addParticipant({
        conversation: uuidToUse,
        contact
      })));
    }
    return uuidToUse;
  }
  /**
   * Delete a chat message.
   * @date 2/20/2024 - 5:52:09 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async deleteMessage({ uuid }) {
    await this.api.v3().chat().delete({ uuid });
  }
  /**
   * Delete a chat conversation.
   * @date 2/20/2024 - 6:15:57 AM
   *
   * @public
   * @async
   * @param {{conversation: string}} param0
   * @param {string} param0.conversation
   * @returns {Promise<void>}
   */
  async delete({ conversation }) {
    await this.api.v3().chat().conversationsDelete({ uuid: conversation });
  }
  /**
   * Edit a conversation name.
   * @date 2/20/2024 - 6:03:14 AM
   *
   * @public
   * @async
   * @param {{conversation: string, name: string}} param0
   * @param {string} param0.conversation
   * @param {string} param0.name
   * @returns {Promise<void>}
   */
  async editConversationName({ conversation, name }) {
    const key = await this.chatKey({ conversation });
    const nameEncrypted = await this.sdk.getWorker().crypto.encrypt.chatConversationName({
      name,
      key
    });
    await this.api.v3().chat().conversationsName().edit({
      uuid: conversation,
      name: nameEncrypted
    });
  }
  /**
   * Edit a chat message.
   * @date 2/20/2024 - 5:52:16 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; conversation: string; message: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.conversation
   * @param {string} param0.message
   * @returns {Promise<void>}
   */
  async editMessage({ uuid, conversation, message }) {
    const key = await this.chatKey({ conversation });
    const messageEncrypted = await this.sdk.getWorker().crypto.encrypt.chatMessage({
      message,
      key
    });
    if (messageEncrypted.length >= MAX_CHAT_SIZE) {
      throw new Error(`Maximum encrypted message size is ${MAX_CHAT_SIZE} characters.`);
    }
    await this.api.v3().chat().edit({
      uuid,
      conversation,
      message: messageEncrypted
    });
  }
  /**
   * Send a message.
   * @date 2/20/2024 - 5:54:24 AM
   *
   * @public
   * @async
   * @param {{ uuid?: string; conversation: string; message: string, replyTo: string }} param0
   * @param {string} param0.uuid
   * @param {string} param0.conversation
   * @param {string} param0.message
   * @param {string} param0.replyTo
   * @returns {Promise<string>}
   */
  async sendMessage({ uuid, conversation, message, replyTo }) {
    const [key, uuidToUse] = await Promise.all([this.chatKey({ conversation }), uuid ? Promise.resolve(uuid) : uuidv4()]);
    const messageEncrypted = await this.sdk.getWorker().crypto.encrypt.chatMessage({
      message,
      key
    });
    if (messageEncrypted.length >= MAX_CHAT_SIZE) {
      throw new Error(`Maximum encrypted message size is ${MAX_CHAT_SIZE} characters.`);
    }
    await this.api.v3().chat().send({
      uuid: uuidToUse,
      conversation,
      message: messageEncrypted,
      replyTo
    });
    return uuidToUse;
  }
  /**
   * Send a typing event.
   * @date 2/20/2024 - 5:55:20 AM
   *
   * @public
   * @async
   * @param {{conversation: string, type: ChatTypingType}} param0
   * @param {string} param0.conversation
   * @param {ChatTypingType} param0.type
   * @returns {Promise<void>}
   */
  async sendTyping({ conversation, type }) {
    await this.api.v3().chat().typing({
      conversation,
      type
    });
  }
  /**
   * Fetch chat messages from the given timestamp ordered DESC. Can be used for pagination.
   * @date 2/20/2024 - 6:00:37 AM
   *
   * @public
   * @async
   * @param {{ conversation: string; timestamp?: number }} param0
   * @param {string} param0.conversation
   * @param {number} param0.timestamp
   * @returns {Promise<ChatMessage[]>}
   */
  async messages({ conversation, timestamp }) {
    const [key, _messages] = await Promise.all([
      this.chatKey({ conversation }),
      this.api.v3().chat().messages({
        conversation,
        timestamp: timestamp ? timestamp : Date.now() + 36e5
      })
    ]);
    const chatMessages = [];
    const promises = [];
    for (const message of _messages) {
      promises.push(new Promise((resolve, reject) => {
        const replyToPromise = message.replyTo.uuid.length > 0 && message.replyTo.message.length > 0 ? this.sdk.getWorker().crypto.decrypt.chatMessage({
          message: message.replyTo.message,
          key
        }) : Promise.resolve("");
        Promise.all([
          this.sdk.getWorker().crypto.decrypt.chatMessage({
            message: message.message,
            key
          }),
          replyToPromise
        ]).then(([messageDecrypted, replyToDecrypted]) => {
          chatMessages.push({
            ...message,
            message: messageDecrypted.length > 0 ? messageDecrypted : `CANNOT_DECRYPT_MESSAGE_${message.uuid}`,
            replyTo: {
              ...message.replyTo,
              message: replyToDecrypted.length > 0 ? replyToDecrypted : `CANNOT_DECRYPT_REPLY_MESSAGE_${message.replyTo.uuid}`
            }
          });
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return chatMessages;
  }
  /**
   * Add a participant to a chat.
   * @date 2/20/2024 - 5:46:46 AM
   *
   * @public
   * @async
   * @param {{ conversation: string; contact: Contact }} param0
   * @param {string} param0.conversation
   * @param {Contact} param0.contact
   * @returns {Promise<void>}
   */
  async addParticipant({ conversation, contact }) {
    const key = await this.chatKey({ conversation });
    const publicKey = (await this.api.v3().user().publicKey({ email: contact.email })).publicKey;
    const metadata = await this.sdk.getWorker().crypto.encrypt.metadataPublic({
      metadata: JSON.stringify({ key }),
      publicKey
    });
    await this.api.v3().chat().conversationsParticipants().add({
      uuid: conversation,
      contactUUID: contact.uuid,
      metadata
    });
  }
  /**
   * Remove a participant from a chat.
   * @date 2/20/2024 - 5:49:45 AM
   *
   * @public
   * @async
   * @param {{conversation: string, userId: number}} param0
   * @param {string} param0.conversation
   * @param {number} param0.userId
   * @returns {Promise<void>}
   */
  async removeParticipant({ conversation, userId }) {
    await this.api.v3().chat().conversationsParticipants().remove({
      uuid: conversation,
      userId
    });
  }
  /**
   * Mark a conversation as read.
   * @date 2/20/2024 - 6:06:21 AM
   *
   * @public
   * @async
   * @param {{conversation: string}} param0
   * @param {string} param0.conversation
   * @returns {Promise<void>}
   */
  async markConversationAsRead({ conversation }) {
    await this.api.v3().chat().conversationsRead({ uuid: conversation });
  }
  /**
   * Get the notification count for a conversation.
   * @date 2/20/2024 - 6:07:24 AM
   *
   * @public
   * @async
   * @param {{conversation: string}} param0
   * @param {string} param0.conversation
   * @returns {Promise<number>}
   */
  async conversationUnreadCount({ conversation }) {
    return (await this.api.v3().chat().conversationsUnread({ uuid: conversation })).unread;
  }
  /**
   * Get the unread notification count (includes all conversations).
   * @date 2/20/2024 - 6:08:07 AM
   *
   * @public
   * @async
   * @returns {Promise<number>}
   */
  async unread() {
    return (await this.api.v3().chat().unread()).unread;
  }
  /**
   * Get the online status of each participant in a conversation.
   * @date 2/20/2024 - 6:09:47 AM
   *
   * @public
   * @async
   * @param {{ conversation: string }} param0
   * @param {string} param0.conversation
   * @returns {Promise<ChatConversationsOnlineUser[]>}
   */
  async conversationOnline({ conversation }) {
    return await this.api.v3().chat().conversationsOnline({ conversation });
  }
  /**
   * Disable a message embed.
   * @date 2/20/2024 - 6:10:38 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async disableMessageEmbed({ uuid }) {
    await this.api.v3().chat().message().embed().disable({ uuid });
  }
  /**
   * Leave a conversation. Only works if you are not the owner.
   * @date 2/20/2024 - 6:14:36 AM
   *
   * @public
   * @async
   * @param {{conversation: string}} param0
   * @param {string} param0.conversation
   * @returns {Promise<void>}
   */
  async leave({ conversation }) {
    await this.api.v3().chat().conversationsLeave({ uuid: conversation });
  }
  /**
   * Fetch last focus.
   * @date 2/20/2024 - 6:22:46 AM
   *
   * @public
   * @async
   * @returns {Promise<ChatLastFocusValues[]>}
   */
  async lastFocus() {
    return await this.api.v3().chat().lastFocus();
  }
  /**
   * Update last focus.
   * @date 2/20/2024 - 6:22:37 AM
   *
   * @public
   * @async
   * @param {{values: ChatLastFocusValues[]}} param0
   * @param {{}} param0.values
   * @returns {Promise<void>}
   */
  async updateLastFocus({ values }) {
    await this.api.v3().chat().lastFocusUpdate({ conversations: values });
  }
};
var chats_default = Chats;

// node_modules/@filen/sdk/dist/browser/notes/utils.js
var import_striptags = __toESM(require_striptags());
function createNotePreviewFromContentText({ content, type }) {
  try {
    if (content.length === 0) {
      return "";
    }
    if (type === "rich") {
      if (content.indexOf("<p><br></p>") === -1) {
        return (0, import_striptags.default)(content.split("\n")[0] ?? "").slice(0, 128);
      }
      return (0, import_striptags.default)(content.split("<p><br></p>")[0] ?? "").slice(0, 128);
    }
    if (type === "checklist") {
      const ex = content.split('<ul data-checked="false">').join("").split('<ul data-checked="true">').join("").split("\n").join("").split("<li>");
      for (const listPoint of ex) {
        const listPointEx = listPoint.split("</li>");
        if (!listPointEx[0]) {
          continue;
        }
        if (listPointEx[0].trim().length > 0) {
          return (0, import_striptags.default)(listPointEx[0].trim());
        }
      }
      return "";
    }
    return (0, import_striptags.default)(content.split("\n")[0].slice(0, 128));
  } catch {
    return "";
  }
}

// node_modules/@filen/sdk/dist/browser/notes/index.js
var import_striptags2 = __toESM(require_striptags());
var Notes2 = class {
  /**
   * Creates an instance of Notes.
   * @date 2/9/2024 - 5:54:11 AM
   *
   * @constructor
   * @public
   * @param {NotesConfig} params
   */
  constructor(params) {
    __publicField(this, "api");
    __publicField(this, "sdkConfig");
    __publicField(this, "_noteKeyCache", /* @__PURE__ */ new Map());
    __publicField(this, "sdk");
    this.api = params.api;
    this.sdkConfig = params.sdkConfig;
    this.sdk = params.sdk;
  }
  /**
   * Decrypt all tags of a note.
   * @date 2/20/2024 - 12:26:37 AM
   *
   * @public
   * @async
   * @param {{ tags: NoteTag[] }} param0
   * @param {{}} param0.tags
   * @returns {Promise<NoteTag[]>}
   */
  async allTags({ tags }) {
    const decryptedTags = [];
    const promises = [];
    for (const tag of tags) {
      promises.push(new Promise((resolve, reject) => {
        this.sdk.getWorker().crypto.decrypt.noteTagName({ name: tag.name }).then((decryptedTagName) => {
          decryptedTags.push({
            ...tag,
            name: decryptedTagName.length > 0 ? decryptedTagName : `CANNOT_DECRYPT_NAME_${tag.uuid}`
          });
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return decryptedTags;
  }
  /**
   * Fetch all notes.
   * @date 2/20/2024 - 12:26:30 AM
   *
   * @public
   * @async
   * @returns {Promise<Note[]>}
   */
  async all() {
    const allNotes = await this.api.v3().notes().all();
    const notes = [];
    const promises = [];
    for (const note of allNotes) {
      promises.push(new Promise((resolve, reject) => {
        const participantMetadata = note.participants.filter((participant) => participant.userId === this.sdkConfig.userId);
        if (participantMetadata.length === 0 || !participantMetadata[0]) {
          reject(new Error("Could not find user as a participant."));
          return;
        }
        const decryptKeyPromise = this._noteKeyCache.has(note.uuid) ? Promise.resolve(this._noteKeyCache.get(note.uuid)) : this.noteKey({ uuid: note.uuid });
        decryptKeyPromise.then((decryptedNoteKey) => {
          this._noteKeyCache.set(note.uuid, decryptedNoteKey);
          this.sdk.getWorker().crypto.decrypt.noteTitle({
            title: note.title,
            key: decryptedNoteKey
          }).then((decryptedNoteTitle) => {
            Promise.all([
              note.preview.length === 0 ? Promise.resolve(decryptedNoteTitle) : this.sdk.getWorker().crypto.decrypt.notePreview({
                preview: note.preview,
                key: decryptedNoteKey
              }),
              this.allTags({ tags: note.tags })
            ]).then(([decryptedNotePreview, decryptedNoteTags]) => {
              notes.push({
                ...note,
                title: decryptedNoteTitle,
                preview: decryptedNotePreview,
                tags: decryptedNoteTags
              });
              resolve();
            }).catch(reject);
          }).catch(reject);
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return notes;
  }
  /**
   * Fetch a note.
   * @date 2/20/2024 - 2:07:16 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<Note>}
   */
  async get({ uuid }) {
    const all = await this.all();
    const note = all.filter((note2) => note2.uuid === uuid);
    if (note.length === 0 || !note[0]) {
      throw new Error(`Note ${uuid} not found.`);
    }
    return note[0];
  }
  /**
   * Fetch all archived notes.
   * @date 2/20/2024 - 12:50:24 AM
   *
   * @public
   * @async
   * @returns {Promise<Note[]>}
   */
  async archived() {
    const all = await this.all();
    return all.filter((note) => note.archive);
  }
  /**
   * Fetch all trashed notes.
   * @date 2/20/2024 - 12:50:33 AM
   *
   * @public
   * @async
   * @returns {Promise<Note[]>}
   */
  async trashed() {
    const all = await this.all();
    return all.filter((note) => note.trash);
  }
  /**
   * Fetch all favorited notes.
   * @date 2/20/2024 - 12:50:40 AM
   *
   * @public
   * @async
   * @returns {Promise<Note[]>}
   */
  async favorited() {
    const all = await this.all();
    return all.filter((note) => note.favorite);
  }
  /**
   * Fetch all pinned notes.
   * @date 2/20/2024 - 12:53:55 AM
   *
   * @public
   * @async
   * @returns {Promise<Note[]>}
   */
  async pinned() {
    const all = await this.all();
    return all.filter((note) => note.pinned);
  }
  /**
   * Fetch all notes ordered by last edit timestamp.
   * @date 2/20/2024 - 12:51:06 AM
   *
   * @public
   * @async
   * @returns {Promise<Note[]>}
   */
  async recents() {
    const all = await this.all();
    return all.sort((a, b) => b.editedTimestamp - a.editedTimestamp);
  }
  /**
   * Get the note encryption key from owner metadata.
   * @date 2/20/2024 - 12:26:15 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<string>}
   */
  async noteKey({ uuid }) {
    if (this._noteKeyCache.has(uuid)) {
      return this._noteKeyCache.get(uuid);
    }
    const all = await this.api.v3().notes().all();
    const note = all.filter((note2) => note2.uuid === uuid);
    if (note.length === 0 || !note[0]) {
      throw new Error(`Could not find note ${uuid}.`);
    }
    if (note[0].ownerId === this.sdkConfig.userId) {
      const decryptedNoteKey2 = await this.sdk.getWorker().crypto.decrypt.noteKeyOwner({ metadata: note[0].metadata });
      this._noteKeyCache.set(uuid, decryptedNoteKey2);
      return decryptedNoteKey2;
    }
    const participant = note[0].participants.filter((participant2) => participant2.userId === this.sdkConfig.userId);
    if (participant.length === 0 || !participant[0]) {
      throw new Error(`Could not find participant metadata for note ${uuid}.`);
    }
    const decryptedNoteKey = await this.sdk.getWorker().crypto.decrypt.noteKeyParticipant({
      metadata: participant[0].metadata,
      privateKey: this.sdkConfig.privateKey
    });
    this._noteKeyCache.set(uuid, decryptedNoteKey);
    return decryptedNoteKey;
  }
  /**
   * Add a participant.
   * @date 2/20/2024 - 1:39:20 AM
   *
   * @public
   * @async
   * @param {{uuid: string, contactUUID: string, permissionsWrite: boolean, publicKey: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.contactUUID
   * @param {boolean} param0.permissionsWrite
   * @param {string} param0.publicKey
   * @returns {Promise<void>}
   */
  async addParticipant({ uuid, contactUUID, permissionsWrite, publicKey }) {
    const decryptedNoteKey = await this.noteKey({ uuid });
    const metadata = await this.sdk.getWorker().crypto.encrypt.metadataPublic({
      metadata: JSON.stringify({ key: decryptedNoteKey }),
      publicKey
    });
    await this.api.v3().notes().participantsAdd({
      uuid,
      metadata,
      contactUUID,
      permissionsWrite
    });
  }
  /**
   * Remove a participant.
   * @date 2/20/2024 - 4:03:59 AM
   *
   * @public
   * @async
   * @param {{uuid: string, userId: number}} param0
   * @param {string} param0.uuid
   * @param {number} param0.userId
   * @returns {Promise<void>}
   */
  async removeParticipant({ uuid, userId }) {
    await this.api.v3().notes().participantsRemove({
      uuid,
      userId
    });
  }
  /**
   * Set permissions for a participant.
   * @date 2/20/2024 - 4:05:31 AM
   *
   * @public
   * @async
   * @param {{uuid: string, permissionsWrite: boolean, userId:number}} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.permissionsWrite
   * @param {number} param0.userId
   * @returns {Promise<void>}
   */
  async participantPermissions({ uuid, permissionsWrite, userId }) {
    await this.api.v3().notes().participantsPermissions({ uuid, userId, permissionsWrite });
  }
  /**
   * Create an empty note.
   * @date 2/19/2024 - 11:55:14 PM
   *
   * @public
   * @async
   * @param {{uuid?: string, title?: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.title
   * @returns {Promise<string>}
   */
  async create({ uuid, title }) {
    const uuidToUse = uuid ? uuid : await uuidv4();
    const titleToUse = title ? title : simpleDate(Date.now());
    const key = await this.sdk.getWorker().crypto.utils.generateRandomString({ length: 32 });
    const [metadataEncrypted, titleEncrypted] = await Promise.all([
      this.sdk.getWorker().crypto.encrypt.metadata({ metadata: JSON.stringify({ key }) }),
      this.sdk.getWorker().crypto.encrypt.noteTitle({
        title: titleToUse,
        key
      })
    ]);
    await this.api.v3().notes().create({
      uuid: uuidToUse,
      title: titleEncrypted,
      metadata: metadataEncrypted
    });
    this._noteKeyCache.set(uuidToUse, key);
    await this.addParticipant({
      uuid: uuidToUse,
      contactUUID: "owner",
      permissionsWrite: true,
      publicKey: this.sdkConfig.publicKey
    });
    return uuidToUse;
  }
  /**
   * Fetch note content.
   * @date 2/20/2024 - 12:32:49 AM
   *
   * @public
   * @async
   * @param {{
   * 		uuid: string
   * 	}} param0
   * @param {string} param0.uuid
   * @returns {Promise<{ content: string; type: NoteType; editedTimestamp: number; editorId: number; preview: string }>}
   */
  async content({ uuid }) {
    const contentEncrypted = await this.api.v3().notes().content({ uuid });
    let content = "";
    if (contentEncrypted.content.length === 0) {
      if (contentEncrypted.type === "checklist") {
        content = '<ul data-checked="false"><li><br></li></ul>';
      } else {
        content = "";
      }
      return {
        content,
        type: contentEncrypted.type,
        editedTimestamp: contentEncrypted.editedTimestamp,
        editorId: contentEncrypted.editorId,
        preview: ""
      };
    }
    const decryptedNoteKey = await this.noteKey({ uuid });
    const notePreviewPromise = contentEncrypted.preview.length === 0 ? Promise.resolve("") : this.sdk.getWorker().crypto.decrypt.notePreview({
      preview: contentEncrypted.preview,
      key: decryptedNoteKey
    });
    const [contentDecrypted, previewDecrypted] = await Promise.all([
      this.sdk.getWorker().crypto.decrypt.noteContent({
        content: contentEncrypted.content,
        key: decryptedNoteKey
      }),
      notePreviewPromise
    ]);
    if (contentEncrypted.type === "checklist" && (contentDecrypted === "" || contentDecrypted.indexOf("<ul data-checked") === -1 || contentDecrypted === "<p><br></p>")) {
      content = '<ul data-checked="false"><li><br></li></ul>';
    } else {
      content = contentDecrypted;
    }
    return {
      content,
      type: contentEncrypted.type,
      editedTimestamp: contentEncrypted.editedTimestamp,
      editorId: contentEncrypted.editorId,
      preview: previewDecrypted
    };
  }
  /**
   * Change note type.
   * @date 2/20/2024 - 12:39:02 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; newType: NoteType; }} param0
   * @param {string} param0.uuid
   * @param {NoteType} param0.newType
   * @returns {Promise<void>}
   */
  async changeType({ uuid, newType }) {
    const [decryptedNoteKey, decryptedNoteContent, noteInfo] = await Promise.all([
      this.noteKey({ uuid }),
      this.content({ uuid }),
      this.get({ uuid })
    ]);
    const strippedContent = (noteInfo.type === "checklist" || noteInfo.type === "rich") && decryptedNoteContent.content.length > 0 ? (0, import_striptags2.default)(decryptedNoteContent.content) : decryptedNoteContent.content;
    const [contentEncrypted, previewEncrypted] = await Promise.all([
      this.sdk.getWorker().crypto.encrypt.noteContent({
        content: strippedContent,
        key: decryptedNoteKey
      }),
      this.sdk.getWorker().crypto.encrypt.notePreview({
        preview: createNotePreviewFromContentText({
          content: strippedContent,
          type: newType
        }),
        key: decryptedNoteKey
      })
    ]);
    await this.api.v3().notes().typeChange({
      uuid,
      type: newType,
      preview: previewEncrypted,
      content: contentEncrypted
    });
  }
  /**
   * Edit a note.
   * @date 2/20/2024 - 12:43:56 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; content: string; type: NoteType }} param0
   * @param {string} param0.uuid
   * @param {string} param0.content
   * @param {NoteType} param0.type
   * @returns {Promise<void>}
   */
  async edit({ uuid, content, type }) {
    const decryptedNoteKey = await this.noteKey({ uuid });
    const preview = createNotePreviewFromContentText({ content, type });
    const [contentEncrypted, previewEncrypted] = await Promise.all([
      this.sdk.getWorker().crypto.encrypt.noteContent({
        content,
        key: decryptedNoteKey
      }),
      this.sdk.getWorker().crypto.encrypt.notePreview({
        preview,
        key: decryptedNoteKey
      })
    ]);
    if (contentEncrypted.length >= MAX_NOTE_SIZE) {
      throw new Error(`Encrypted note content size too big, maximum is ${MAX_NOTE_SIZE} bytes.`);
    }
    await this.api.v3().notes().contentEdit({
      uuid,
      preview: previewEncrypted,
      content: contentEncrypted,
      type
    });
  }
  /**
   * Edit a note's title.
   * @date 4/1/2024 - 5:46:41 PM
   *
   * @public
   * @async
   * @param {{uuid: string, title: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.title
   * @returns {Promise<void>}
   */
  async editTitle({ uuid, title }) {
    const decryptedNoteKey = await this.noteKey({ uuid });
    const titleEncrypted = await this.sdk.getWorker().crypto.encrypt.noteTitle({
      title,
      key: decryptedNoteKey
    });
    await this.api.v3().notes().titleEdit({
      uuid,
      title: titleEncrypted
    });
  }
  /**
   * Delete a note.
   * @date 2/20/2024 - 12:48:38 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async delete({ uuid }) {
    await this.api.v3().notes().delete({ uuid });
  }
  /**
   * Archive a note.
   * @date 2/20/2024 - 12:48:44 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async archive({ uuid }) {
    await this.api.v3().notes().archive({ uuid });
  }
  /**
   * Trash a note.
   * @date 2/20/2024 - 12:48:48 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async trash({ uuid }) {
    await this.api.v3().notes().trash({ uuid });
  }
  /**
   * Toggle the favorite status of a note.
   * @date 2/20/2024 - 12:52:30 AM
   *
   * @public
   * @async
   * @param {{uuid: string, favorite: boolean}} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async favorite({ uuid, favorite }) {
    await this.api.v3().notes().favorite({ uuid, favorite });
  }
  /**
   * Toggle the pinned status of a note.
   * @date 2/20/2024 - 12:53:31 AM
   *
   * @public
   * @async
   * @param {{ uuid: string; pin: boolean }} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.pin
   * @returns {Promise<void>}
   */
  async pin({ uuid, pin }) {
    await this.api.v3().notes().pinned({ uuid, pinned: pin });
  }
  /**
   * Restore a note from the archive or trash.
   * @date 2/20/2024 - 12:52:46 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async restore({ uuid }) {
    await this.api.v3().notes().restore({ uuid });
  }
  /**
   * Duplicate a note.
   * @date 2/20/2024 - 1:40:38 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<string>}
   */
  async duplicate({ uuid }) {
    const [contentDecrypted, allNotes] = await Promise.all([this.content({ uuid }), this.all()]);
    const note = allNotes.filter((note2) => note2.uuid === uuid);
    if (note.length === 0 || !note[0]) {
      throw new Error(`Could not find note ${uuid}.`);
    }
    const newUUID = await uuidv4();
    await this.create({ uuid: newUUID, title: note[0].title });
    await this.addParticipant({ uuid: newUUID, contactUUID: "owner", permissionsWrite: true, publicKey: this.sdkConfig.publicKey });
    await this.changeType({ uuid: newUUID, newType: contentDecrypted.type });
    await this.edit({ uuid: newUUID, content: contentDecrypted.content, type: contentDecrypted.type });
    return newUUID;
  }
  /**
   * Fetch a content history of a note.
   * @date 2/20/2024 - 2:03:38 AM
   *
   * @public
   * @async
   * @param {{ uuid: string }} param0
   * @param {string} param0.uuid
   * @returns {Promise<NoteHistory[]>}
   */
  async history({ uuid }) {
    const [_history, decryptedNoteKey] = await Promise.all([this.api.v3().notes().history({ uuid }), this.noteKey({ uuid })]);
    const notesHistory = [];
    const promises = [];
    for (const noteHistory of _history) {
      if (noteHistory.content.length === 0 || noteHistory.preview.length === 0) {
        continue;
      }
      promises.push(new Promise((resolve, reject) => {
        Promise.all([
          this.sdk.getWorker().crypto.decrypt.noteContent({
            content: noteHistory.content,
            key: decryptedNoteKey
          }),
          this.sdk.getWorker().crypto.decrypt.notePreview({
            preview: noteHistory.preview,
            key: decryptedNoteKey
          })
        ]).then(([noteHistoryContentDecrypted, noteHistoryPreviewDecrypted]) => {
          notesHistory.push({
            ...noteHistory,
            content: noteHistoryContentDecrypted,
            preview: noteHistoryPreviewDecrypted
          });
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return notesHistory;
  }
  /**
   * Restore a note from history.
   * @date 2/20/2024 - 4:46:26 AM
   *
   * @public
   * @async
   * @param {{uuid: string, id: number}} param0
   * @param {string} param0.uuid
   * @param {number} param0.id
   * @returns {Promise<void>}
   */
  async restoreHistory({ uuid, id }) {
    await this.api.v3().notes().historyRestore({ uuid, id });
  }
  /**
   * Add a tag to a note.
   * @date 2/20/2024 - 2:38:49 AM
   *
   * @public
   * @async
   * @param {{uuid: string, tag: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.tag
   * @returns {Promise<void>}
   */
  async tag({ uuid, tag }) {
    await this.api.v3().notes().tag({ uuid, tag });
  }
  /**
   * Remove a tag from a note.
   * @date 2/20/2024 - 2:38:54 AM
   *
   * @public
   * @async
   * @param {{uuid: string, tag: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.tag
   * @returns {Promise<void>}
   */
  async untag({ uuid, tag }) {
    await this.api.v3().notes().untag({ uuid, tag });
  }
  /**
   * Fetch all tags.
   * @date 2/20/2024 - 3:56:32 AM
   *
   * @public
   * @async
   * @returns {Promise<NoteTag[]>}
   */
  async tags() {
    const _tags = await this.api.v3().notes().tags();
    const notesTags = [];
    const promises = [];
    for (const tag of _tags) {
      promises.push(new Promise((resolve, reject) => {
        this.sdk.getWorker().crypto.decrypt.noteTagName({ name: tag.name }).then((decryptedTagName) => {
          notesTags.push({
            ...tag,
            name: decryptedTagName.length > 0 ? decryptedTagName : `CANNOT_DECRYPT_NAME_${tag.uuid}`
          });
          resolve();
        }).catch(reject);
      }));
    }
    await promiseAllChunked(promises);
    return notesTags;
  }
  /**
   * Fetch all favorited tags.
   * @date 2/20/2024 - 3:58:08 AM
   *
   * @public
   * @async
   * @returns {Promise<NoteTag[]>}
   */
  async tagsFavorited() {
    const allTags = await this.tags();
    return allTags.filter((tag) => tag.favorite);
  }
  /**
   * Fetch all tags sorted by edited timestamp.
   * @date 2/20/2024 - 3:58:15 AM
   *
   * @public
   * @async
   * @returns {Promise<NoteTag[]>}
   */
  async tagsRecents() {
    const allTags = await this.tags();
    return allTags.sort((a, b) => b.editedTimestamp - a.editedTimestamp);
  }
  /**
   * Create a tag.
   * @date 2/20/2024 - 3:21:37 AM
   *
   * @public
   * @async
   * @param {{name: string}} param0
   * @param {string} param0.name
   * @returns {Promise<string>}
   */
  async createTag({ name }) {
    const allTags = await this.tags();
    const filtered = allTags.filter((tag) => tag.name === name);
    if (filtered.length !== 0 && filtered[0]) {
      return filtered[0].uuid;
    }
    const nameEncrypted = await this.sdk.getWorker().crypto.encrypt.noteTagName({ name });
    const response = await this.api.v3().notes().tagsCreate({ name: nameEncrypted });
    return response.uuid;
  }
  /**
   * Rename a tag.
   * @date 2/20/2024 - 4:01:29 AM
   *
   * @public
   * @async
   * @param {{uuid: string, name: string}} param0
   * @param {string} param0.uuid
   * @param {string} param0.name
   * @returns {Promise<void>}
   */
  async renameTag({ uuid, name }) {
    const allTags = await this.tags();
    const filtered = allTags.filter((tag) => tag.name === name);
    if (filtered.length !== 0) {
      throw new Error(`Tag with name ${name} already exists.`);
    }
    const nameEncrypted = await this.sdk.getWorker().crypto.encrypt.noteTagName({ name });
    await this.api.v3().notes().tagsRename({
      uuid,
      name: nameEncrypted
    });
  }
  /**
   * Toggle the favorite status of a tag.
   * @date 2/20/2024 - 4:02:16 AM
   *
   * @public
   * @async
   * @param {{uuid: string, favorite: boolean}} param0
   * @param {string} param0.uuid
   * @param {boolean} param0.favorite
   * @returns {Promise<void>}
   */
  async tagFavorite({ uuid, favorite }) {
    await this.api.v3().notes().tagsFavorite({
      uuid,
      favorite
    });
  }
  /**
   * Delete a tag.
   * @date 2/20/2024 - 4:03:05 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async deleteTag({ uuid }) {
    await this.api.v3().notes().tagsDelete({ uuid });
  }
};
var notes_default2 = Notes2;

// node_modules/@filen/sdk/dist/browser/contacts/index.js
var Contacts2 = class {
  /**
   * Creates an instance of Contacts.
   * @date 2/9/2024 - 5:54:11 AM
   *
   * @constructor
   * @public
   * @param {ContactsConfig} params
   */
  constructor(params) {
    __publicField(this, "api");
    __publicField(this, "sdkConfig");
    this.api = params.api;
    this.sdkConfig = params.sdkConfig;
  }
  /**
   * Fetch all contacts.
   * @date 2/20/2024 - 6:28:41 AM
   *
   * @public
   * @async
   * @returns {Promise<Contact[]>}
   */
  async all() {
    return await this.api.v3().contacts().all();
  }
  /**
   * Fetch all incoming contact requests.
   * @date 2/20/2024 - 6:29:43 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactRequest[]>}
   */
  async incomingRequests() {
    return await this.api.v3().contacts().requestsIn();
  }
  /**
   * Fetch count of all incoming contact requests.
   * @date 2/20/2024 - 6:30:11 AM
   *
   * @public
   * @async
   * @returns {Promise<number>}
   */
  async incomingRequestsCount() {
    return await this.api.v3().contacts().requestsInCount();
  }
  /**
   * Fetch all outgoing contact requests.
   * @date 2/20/2024 - 6:29:43 AM
   *
   * @public
   * @async
   * @returns {Promise<ContactRequest[]>}
   */
  async outgoingRequests() {
    return await this.api.v3().contacts().requestsOut();
  }
  /**
   * Delete an outgoing contact request.
   * @date 2/20/2024 - 6:36:39 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async deleteOutgoingRequest({ uuid }) {
    await this.api.v3().contacts().requestsOutDelete({ uuid });
  }
  /**
   * Send a contact request.
   * @date 2/20/2024 - 6:36:33 AM
   *
   * @public
   * @async
   * @param {{email: string}} param0
   * @param {string} param0.email
   * @returns {Promise<void>}
   */
  async sendRequest({ email }) {
    await this.api.v3().contacts().requestsSend({ email });
  }
  /**
   * Accept incoming contact request.
   * @date 2/20/2024 - 6:36:26 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async acceptRequest({ uuid }) {
    await this.api.v3().contacts().requestsAccept({ uuid });
  }
  /**
   * Deny incoming contact request.
   * @date 2/20/2024 - 6:36:17 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async denyRequest({ uuid }) {
    await this.api.v3().contacts().requestsDeny({ uuid });
  }
  /**
   * Remove a contact.
   * @date 2/20/2024 - 6:34:24 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async remove({ uuid }) {
    await this.api.v3().contacts().delete({ uuid });
  }
  /**
   * Fetch all blocked contacts.
   * @date 2/20/2024 - 6:34:55 AM
   *
   * @public
   * @async
   * @returns {Promise<BlockedContact[]>}
   */
  async blocked() {
    return await this.api.v3().contacts().blocked();
  }
  /**
   * Block a user.
   * @date 2/20/2024 - 6:36:11 AM
   *
   * @public
   * @async
   * @param {{email: string}} param0
   * @param {string} param0.email
   * @returns {Promise<void>}
   */
  async block({ email }) {
    await this.api.v3().contacts().blockedAdd({ email });
  }
  /**
   * Unblock a contact.
   * @date 2/20/2024 - 6:36:05 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async unblock({ uuid }) {
    await this.api.v3().contacts().blockedDelete({ uuid });
  }
};
var contacts_default2 = Contacts2;

// node_modules/@filen/sdk/dist/browser/user/index.js
var User = class {
  /**
   * Creates an instance of User.
   * @date 2/9/2024 - 5:54:11 AM
   *
   * @constructor
   * @public
   * @param {UserConfig} params
   */
  constructor(params) {
    __publicField(this, "api");
    __publicField(this, "sdkConfig");
    __publicField(this, "sdk");
    this.api = params.api;
    this.sdkConfig = params.sdkConfig;
    this.sdk = params.sdk;
  }
  /**
   * Fetch the user's info.
   * @date 2/20/2024 - 6:39:47 AM
   *
   * @public
   * @async
   * @returns {Promise<UserInfoResponse>}
   */
  async info() {
    return await this.api.v3().user().info({ apiKey: void 0 });
  }
  /**
   * Fetch the user's base folder UUID.
   * @date 2/20/2024 - 6:40:17 AM
   *
   * @public
   * @async
   * @returns {Promise<string>}
   */
  async baseFolder() {
    return (await this.api.v3().user().baseFolder({ apiKey: void 0 })).uuid;
  }
  /**
   * Get a user's public key.
   * @date 2/20/2024 - 6:41:01 AM
   *
   * @public
   * @async
   * @param {{email: string}} param0
   * @param {string} param0.email
   * @returns {Promise<string>}
   */
  async publicKey({ email }) {
    return (await this.api.v3().user().publicKey({ email })).publicKey;
  }
  /**
   * Fetch the user's settings.
   * @date 2/20/2024 - 6:41:53 AM
   *
   * @public
   * @async
   * @returns {Promise<UserSettingsResponse>}
   */
  async settings() {
    return await this.api.v3().user().settings();
  }
  /**
   * Fetch user account.
   * @date 2/20/2024 - 6:42:45 AM
   *
   * @public
   * @async
   * @returns {Promise<UserAccountResponse>}
   */
  async account() {
    return await this.api.v3().user().account();
  }
  /**
   * Fetch GDPR info.
   * @date 2/20/2024 - 6:43:36 AM
   *
   * @public
   * @async
   * @returns {Promise<UserGDPRResponse>}
   */
  async gdpr() {
    return await this.api.v3().user().gdpr();
  }
  /**
   * Upload an avatar.
   * @date 2/20/2024 - 6:46:44 AM
   *
   * @public
   * @async
   * @param {{buffer: Buffer}} param0
   * @param {Buffer} param0.buffer
   * @returns {Promise<void>}
   */
  async uploadAvatar({ buffer }) {
    const base64 = buffer.toString("base64");
    const hash = await this.sdk.getWorker().crypto.utils.bufferToHash({
      buffer: Buffer.from(base64, "utf-8"),
      algorithm: "sha512"
    });
    await this.api.v3().user().avatar({
      base64,
      hash
    });
  }
  /**
   * Change email.
   * @date 2/20/2024 - 6:50:24 AM
   *
   * @public
   * @async
   * @param {{email: string, password: string}} param0
   * @param {string} param0.email
   * @param {string} param0.password
   * @returns {Promise<void>}
   */
  async changeEmail({ email, password }) {
    const authInfo = await this.api.v3().auth().info({ email: this.sdkConfig.email });
    const derived = await this.sdk.getWorker().crypto.utils.generatePasswordAndMasterKeyBasedOnAuthVersion({
      rawPassword: password,
      authVersion: this.sdkConfig.authVersion,
      salt: authInfo.salt
    });
    await this.api.v3().user().settingsEmail().change({ email, password: derived.derivedPassword, authVersion: this.sdkConfig.authVersion });
  }
  /**
   * Update personal information.
   * @date 2/20/2024 - 6:52:44 AM
   *
   * @public
   * @async
   * @param {{
   * 		city?: string
   * 		companyName?: string
   * 		country?: string
   * 		firstName?: string
   * 		lastName?: string
   * 		postalCode?: string
   * 		street?: string
   * 		streetNumber?: string
   * 		vatId?: string
   * 	}} param0
   * @param {string} [param0.city="__NONE__"]
   * @param {string} [param0.companyName="__NONE__"]
   * @param {string} [param0.country="__NONE__"]
   * @param {string} [param0.firstName="__NONE__"]
   * @param {string} [param0.lastName="__NONE__"]
   * @param {string} [param0.postalCode="__NONE__"]
   * @param {string} [param0.street="__NONE__"]
   * @param {string} [param0.streetNumber="__NONE__"]
   * @param {string} [param0.vatId="__NONE__"]
   * @returns {Promise<void>}
   */
  async updatePersonalInformation({ city = "__NONE__", companyName = "__NONE__", country = "__NONE__", firstName = "__NONE__", lastName = "__NONE__", postalCode = "__NONE__", street = "__NONE__", streetNumber = "__NONE__", vatId = "__NONE__" }) {
    if (city.length <= 0) {
      city = "__NONE__";
    }
    if (companyName.length <= 0) {
      companyName = "__NONE__";
    }
    if (country.length <= 0) {
      country = "__NONE__";
    }
    if (firstName.length <= 0) {
      firstName = "__NONE__";
    }
    if (lastName.length <= 0) {
      lastName = "__NONE__";
    }
    if (postalCode.length <= 0) {
      postalCode = "__NONE__";
    }
    if (street.length <= 0) {
      street = "__NONE__";
    }
    if (streetNumber.length <= 0) {
      streetNumber = "__NONE__";
    }
    if (vatId.length <= 0) {
      vatId = "__NONE__";
    }
    await this.api.v3().user().personal().change({ city, companyName, country, firstName, lastName, postalCode, street, streetNumber, vatId });
  }
  /**
   * Request account deletion.
   * @date 2/20/2024 - 6:54:22 AM
   *
   * @public
   * @async
   * @param {{ twoFactorCode?: string }} param0
   * @param {string} [param0.twoFactorCode="XXXXXX"]
   * @returns {Promise<void>}
   */
  async delete({ twoFactorCode = "XXXXXX" }) {
    await this.api.v3().user().delete({ twoFactorCode });
  }
  /**
   * Delete all versioned files.
   * @date 2/20/2024 - 6:54:57 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async deleteAllVersionedFiles() {
    await this.api.v3().user().deleteVersions();
  }
  /**
   * Delete all files and directories.
   * @date 2/20/2024 - 6:55:20 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async deleteEverything() {
    await this.api.v3().user().deleteAll();
  }
  /**
   * Change password.
   * @date 2/20/2024 - 7:03:26 AM
   *
   * @public
   * @async
   * @param {{ currentPassword: string; newPassword: string }} param0
   * @param {string} param0.currentPassword
   * @param {string} param0.newPassword
   * @returns {Promise<string>}
   */
  async changePassword({ currentPassword, newPassword }) {
    const authInfo = await this.api.v3().auth().info({ email: this.sdkConfig.email });
    const derivedCurrent = await this.sdk.getWorker().crypto.utils.generatePasswordAndMasterKeyBasedOnAuthVersion({
      rawPassword: currentPassword,
      authVersion: this.sdkConfig.authVersion,
      salt: authInfo.salt
    });
    const newSalt = await this.sdk.getWorker().crypto.utils.generateRandomString({ length: 256 });
    const derivedNew = await this.sdk.getWorker().crypto.utils.generatePasswordAndMasterKeyBasedOnAuthVersion({
      rawPassword: newPassword,
      authVersion: this.sdkConfig.authVersion,
      salt: newSalt
    });
    const newMasterKeys = [
      ...this.sdkConfig.masterKeys.filter((key) => key !== derivedNew.derivedMasterKeys),
      derivedNew.derivedMasterKeys
    ];
    const newMasterKeysEncrypted = await this.sdk.getWorker().crypto.encrypt.metadata({
      metadata: newMasterKeys.join("|"),
      key: derivedNew.derivedMasterKeys
    });
    const response = await this.api.v3().user().settingsPassword().change({
      password: derivedNew.derivedPassword,
      currentPassword: derivedCurrent.derivedPassword,
      authVersion: this.sdkConfig.authVersion,
      salt: newSalt,
      masterKeys: newMasterKeysEncrypted
    });
    return response.newAPIKey;
  }
  /**
   * Mark the current master keys as exported.
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async didExportMasterKeys() {
    return await this.api.v3().user().didExportMasterKeys();
  }
  /**
   * Check if the current API key is valid.
   *
   * @public
   * @async
   * @returns {Promise<boolean>}
   */
  async checkAPIKeyValidity() {
    try {
      await this.api.v3().user().account();
      return true;
    } catch (e) {
      if (e instanceof APIError && (e.code === "api_key_not_found" || e.code === "invalid_api_key")) {
        return false;
      }
      if (e instanceof Error && e.message.toLowerCase().includes("api") && e.message.toLowerCase().includes("key")) {
        return false;
      }
      throw e;
    }
  }
  /**
   * Enable two factor authentication. Returns the recovery keys.
   * @date 2/20/2024 - 7:04:35 AM
   *
   * @public
   * @async
   * @param {{twoFactorCode: string}} param0
   * @param {string} param0.twoFactorCode
   * @returns {Promise<string>}
   */
  async enableTwoFactorAuthentication({ twoFactorCode }) {
    return (await this.api.v3().user().twoFactorAuthentication().enable({ code: twoFactorCode })).recoveryKeys;
  }
  /**
   * Disable two factor authentication.
   * @date 2/20/2024 - 7:05:03 AM
   *
   * @public
   * @async
   * @param {{ twoFactorCode: string }} param0
   * @param {string} param0.twoFactorCode
   * @returns {Promise<void>}
   */
  async disableTwoFactorAuthentication({ twoFactorCode }) {
    return await this.api.v3().user().twoFactorAuthentication().disable({ code: twoFactorCode });
  }
  /**
   * Fetch events based on timestamp and filter. Timestamp can be used for pagination.
   *
   * @public
   * @async
   * @param {?{ timestamp?: number; filter?: "all" }} [params]
   * @returns {Promise<UserEvent[]>}
   */
  async events(params) {
    const result = await this.api.v3().user().events({
      lastTimestamp: params && params.timestamp ? params.timestamp : Math.floor(Date.now() / 1e3) + 60,
      filter: params && params.filter ? params.filter : "all"
    });
    return await Promise.all(result.map((event) => this.sdk.getWorker().crypto.decrypt.event({ event })));
  }
  /**
   * Fetch info about an event.
   * @date 2/20/2024 - 7:10:44 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<UserEventResponse>}
   */
  async event({ uuid }) {
    return await this.sdk.getWorker().crypto.decrypt.event({ event: await this.api.v3().user().event({ uuid }) });
  }
  /**
   * Cancel a subscription.
   * @date 2/20/2024 - 7:12:09 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<void>}
   */
  async cancelSubscription({ uuid }) {
    await this.api.v3().user().sub().cancel({ uuid });
  }
  /**
   * Create a subscription payment flow. Returns the payment gateway URL.
   * @date 2/20/2024 - 7:13:19 AM
   *
   * @public
   * @async
   * @param {{planId: number, paymentMethod: PaymentMethods}} param0
   * @param {number} param0.planId
   * @param {PaymentMethods} param0.paymentMethod
   * @returns {Promise<string>}
   */
  async createSubscription({ planId, paymentMethod }) {
    return (await this.api.v3().user().sub().create({ planId, method: paymentMethod })).url;
  }
  /**
   * Generate a PDF invoice. Returns PDF data as a Base64 encoded string.
   * @date 2/20/2024 - 7:14:22 AM
   *
   * @public
   * @async
   * @param {{uuid: string}} param0
   * @param {string} param0.uuid
   * @returns {Promise<string>}
   */
  async generateInvoice({ uuid }) {
    return await this.api.v3().user().invoice({ uuid });
  }
  /**
   * Request an affiliate payout.
   * @date 2/20/2024 - 7:15:26 AM
   *
   * @public
   * @async
   * @param {{method: string, address: string}} param0
   * @param {string} param0.method
   * @param {string} param0.address
   * @returns {Promise<void>}
   */
  async requestAffiliatePayout({ method, address }) {
    await this.api.v3().user().affiliate().payout({ address, method });
  }
  /**
   * Toggle file versioning on/off.
   * @date 2/20/2024 - 7:16:11 AM
   *
   * @public
   * @async
   * @param {{enabled: boolean}} param0
   * @param {boolean} param0.enabled
   * @returns {Promise<void>}
   */
  async versioning({ enabled }) {
    await this.api.v3().user().versioning({ enable: enabled });
  }
  /**
   * Toggle login alerts on/off.
   * @date 2/20/2024 - 7:16:54 AM
   *
   * @public
   * @async
   * @param {{enabled: boolean}} param0
   * @param {boolean} param0.enabled
   * @returns {Promise<void>}
   */
  async loginAlerts({ enabled }) {
    await this.api.v3().user().loginAlerts({ enable: enabled });
  }
  /**
   * Update account nickname.
   * @date 2/20/2024 - 7:17:43 AM
   *
   * @public
   * @async
   * @param {{nickname: string}} param0
   * @param {string} param0.nickname
   * @returns {Promise<void>}
   */
  async updateNickname({ nickname }) {
    await this.api.v3().user().nickname({ nickname });
  }
  /**
   * Toggle appear offline status on/off.
   * @date 2/20/2024 - 7:18:12 AM
   *
   * @public
   * @async
   * @param {{ enabled: boolean }} param0
   * @param {boolean} param0.enabled
   * @returns {Promise<void>}
   */
  async appearOffline({ enabled }) {
    await this.api.v3().user().appearOffline({ appearOffline: enabled });
  }
  /**
   * Fetch a user's public profile.
   * @date 2/20/2024 - 7:19:15 AM
   *
   * @public
   * @async
   * @param {{id: number}} param0
   * @param {number} param0.id
   * @returns {Promise<UserProfileResponse>}
   */
  async profile({ id }) {
    return await this.api.v3().user().profile({ id });
  }
  /**
   * Update desktop last active timestamp.
   * @date 2/20/2024 - 7:20:56 AM
   *
   * @public
   * @async
   * @param {{timestamp: number}} param0
   * @param {number} param0.timestamp
   * @returns {Promise<void>}
   */
  async updateDesktopLastActive({ timestamp }) {
    await this.api.v3().user().lastActive().desktop({ timestamp });
  }
  /**
   * Lock a resource.
   *
   * @public
   * @async
   * @param {{
   * 		resource: string
   * 		lockUUID: string
   * 		maxTries?: number
   * 		tryTimeout?: number
   * 	}} param0
   * @param {string} param0.resource
   * @param {string} param0.lockUUID
   * @param {number} [param0.maxTries=86400]
   * @param {number} [param0.tryTimeout=1000]
   * @returns {Promise<void>}
   */
  async acquireResourceLock({ resource, lockUUID, maxTries = 86400, tryTimeout = 1e3 }) {
    let tries = 0;
    while (tries < maxTries) {
      tries += 1;
      const response = await this.api.v3().user().lock({
        uuid: lockUUID,
        resource,
        type: "acquire"
      });
      if (response.acquired) {
        return;
      }
      await new Promise((resolve) => setTimeout(resolve, tryTimeout));
    }
    throw new Error(`Could not acquire lock for resource ${resource}. Max tries of ${maxTries} reached.`);
  }
  /**
   * Unlock a resource.
   *
   * @public
   * @async
   * @param {{ resource: string; lockUUID: string }} param0
   * @param {string} param0.resource
   * @param {string} param0.lockUUID
   * @returns {Promise<void>}
   */
  async releaseResourceLock({ resource, lockUUID }) {
    const response = await this.api.v3().user().lock({
      uuid: lockUUID,
      resource,
      type: "release"
    });
    if (!response.released) {
      throw new Error(`Could not release lock for resource ${resource} with lockUUID ${lockUUID}.`);
    }
  }
  /**
   * Refresh a resource lock.
   *
   * @public
   * @async
   * @param {{ resource: string; lockUUID: string }} param0
   * @param {string} param0.resource
   * @param {string} param0.lockUUID
   * @returns {Promise<void>}
   */
  async refreshResourceLock({ resource, lockUUID }) {
    const response = await this.api.v3().user().lock({
      uuid: lockUUID,
      resource,
      type: "refresh"
    });
    if (!response.refreshed) {
      throw new Error(`Could not refresh lock for resource ${resource} with lockUUID ${lockUUID}.`);
    }
  }
  /**
   * Fetch resource lock status.
   *
   * @public
   * @async
   * @param {{ resource: string }} param0
   * @param {string} param0.resource
   * @returns {Promise<UserLockStatus>}
   */
  async resourceLockStatus({ resource }) {
    const response = await this.api.v3().user().lock({
      uuid: v4_default(),
      resource,
      type: "status"
    });
    return response.status;
  }
};
var user_default = User;

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/@filen/sdk/dist/browser/events.js
var TypedEventEmitter = class {
  constructor() {
    __publicField(this, "emitter", new import_index.default());
  }
  subscribe(event, listener) {
    this.emitter.addListener(event, listener);
    return {
      remove: () => {
        this.emitter.removeListener(event, listener);
      }
    };
  }
  emit(event, payload) {
    return this.emitter.emit(event, payload);
  }
  on(event, listener) {
    this.emitter.on(event, listener);
    return this;
  }
  once(event, listener) {
    this.emitter.once(event, listener);
    return this;
  }
  off(event, listener) {
    this.emitter.off(event, listener);
    return this;
  }
};
var events_default2 = TypedEventEmitter;

// node_modules/@filen/sdk/dist/browser/index.js
var import_axios = __toESM(require_axios2());
var FilenSDK = class {
  /**
   * Creates an instance of FilenSDK.
   *
   * @constructor
   * @public
   * @param {?FilenSDKConfig} [params]
   * @param {?SDKWorker[]} [workers]
   * @param {?AxiosInstance} [axiosInstance]
   */
  constructor(params, workers, axiosInstance) {
    __publicField(this, "config");
    __publicField(this, "_api");
    __publicField(this, "_crypto");
    __publicField(this, "_fs");
    __publicField(this, "_cloud");
    __publicField(this, "_notes");
    __publicField(this, "_chats");
    __publicField(this, "_contacts");
    __publicField(this, "_user");
    __publicField(this, "socket", new socket_default());
    __publicField(this, "_updateKeyPairTries", 0);
    __publicField(this, "workers");
    __publicField(this, "currentWorkerWorkIndex", 0);
    __publicField(this, "events");
    __publicField(this, "axiosInstance");
    __publicField(this, "utils", {
      ...utils_default,
      crypto: utils_default2,
      streams: {
        append: append_default,
        decodeBase64: streamDecodeBase64,
        encodeBase64: streamEncodeBase64
      }
    });
    if (!params) {
      params = {};
    }
    this.config = params;
    this.workers = workers ? workers : null;
    this.events = new events_default2();
    this.axiosInstance = axiosInstance ? axiosInstance : import_axios.default.create();
    this._crypto = params.masterKeys && params.publicKey && params.privateKey ? new crypto_default({
      masterKeys: params.masterKeys,
      publicKey: params.publicKey,
      privateKey: params.privateKey,
      metadataCache: params.metadataCache ? params.metadataCache : false,
      tmpPath: environment === "browser" ? "/dev/null" : params.tmpPath ? utils_default.normalizePath(params.tmpPath) : utils_default.normalizePath(import_os4.default.tmpdir())
    }) : new crypto_default({
      masterKeys: [],
      publicKey: "",
      privateKey: "",
      metadataCache: params.metadataCache ? params.metadataCache : false,
      tmpPath: environment === "browser" ? "/dev/null" : params.tmpPath ? utils_default.normalizePath(params.tmpPath) : utils_default.normalizePath(import_os4.default.tmpdir())
    });
    this._api = params.apiKey ? new api_default({
      apiKey: params.apiKey,
      sdk: this
    }) : new api_default({
      apiKey: "anonymous",
      sdk: this
    });
    this._cloud = new cloud_default({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
    this._fs = new fs_default({
      sdkConfig: params,
      api: this._api,
      cloud: this._cloud,
      connectToSocket: params.connectToSocket
    });
    this._notes = new notes_default2({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
    this._chats = new chats_default({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
    this._contacts = new contacts_default2({
      sdkConfig: params,
      api: this._api
    });
    this._user = new user_default({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
  }
  /**
   * Update the SDK Worker pool.
   *
   * @public
   * @param {SDKWorker[]} sdkWorkers
   */
  setSDKWorkers(sdkWorkers) {
    this.workers = sdkWorkers;
  }
  getBaseWorker() {
    const baseWorker = {
      crypto: {
        encrypt: this.crypto().encrypt(),
        decrypt: this.crypto().decrypt(),
        utils: utils_default2
      },
      api: {
        v3: {
          file: {
            upload: {
              chunk: {
                buffer: {
                  fetch: (params) => {
                    return this._api.v3().file().upload().chunk().buffer(params);
                  }
                }
              }
            },
            download: {
              chunk: {
                buffer: {
                  fetch: (params) => {
                    return this._api.v3().file().download().chunk().buffer(params);
                  }
                }
              }
            }
          }
        }
      }
    };
    return baseWorker;
  }
  /**
   * Get a worker from the SDK Worker pool if set. Greatly improves performance.
   *
   * @public
   * @returns {SDKWorker}
   */
  getWorker() {
    const baseWorker = {
      crypto: {
        encrypt: this.crypto().encrypt(),
        decrypt: this.crypto().decrypt(),
        utils: utils_default2
      },
      api: {
        v3: {
          file: {
            upload: {
              chunk: {
                buffer: {
                  fetch: (params) => {
                    return this._api.v3().file().upload().chunk().buffer(params);
                  }
                }
              }
            },
            download: {
              chunk: {
                buffer: {
                  fetch: (params) => {
                    return this._api.v3().file().download().chunk().buffer(params);
                  }
                }
              }
            }
          }
        }
      }
    };
    if (!this.workers || this.workers.length === 0) {
      return baseWorker;
    }
    if (this.currentWorkerWorkIndex === void 0 || this.currentWorkerWorkIndex < 0 || this.currentWorkerWorkIndex >= this.workers.length) {
      this.currentWorkerWorkIndex = 0;
    }
    const workerToUse = this.workers[this.currentWorkerWorkIndex];
    this.currentWorkerWorkIndex = (this.currentWorkerWorkIndex + 1) % this.workers.length;
    return workerToUse || baseWorker;
  }
  /**
   * Initialize the SDK again (after logging in for example).
   * @date 2/1/2024 - 3:23:58 PM
   *
   * @public
   * @param {FilenSDKConfig} params
   */
  init(params) {
    this.config = params;
    this._crypto = params.masterKeys && params.publicKey && params.privateKey ? new crypto_default({
      masterKeys: params.masterKeys,
      publicKey: params.publicKey,
      privateKey: params.privateKey,
      metadataCache: params.metadataCache ? params.metadataCache : false,
      tmpPath: environment === "browser" ? "/dev/null" : params.tmpPath ? utils_default.normalizePath(params.tmpPath) : utils_default.normalizePath(import_os4.default.tmpdir())
    }) : new crypto_default({
      masterKeys: [],
      publicKey: "",
      privateKey: "",
      metadataCache: params.metadataCache ? params.metadataCache : false,
      tmpPath: environment === "browser" ? "/dev/null" : params.tmpPath ? utils_default.normalizePath(params.tmpPath) : utils_default.normalizePath(import_os4.default.tmpdir())
    });
    this._api = params.apiKey ? new api_default({
      apiKey: params.apiKey,
      sdk: this
    }) : new api_default({
      apiKey: "anonymous",
      sdk: this
    });
    this._cloud = new cloud_default({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
    this._fs = new fs_default({
      sdkConfig: params,
      api: this._api,
      cloud: this._cloud,
      connectToSocket: params.connectToSocket
    });
    this._notes = new notes_default2({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
    this._chats = new chats_default({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
    this._contacts = new contacts_default2({
      sdkConfig: params,
      api: this._api
    });
    this._user = new user_default({
      sdkConfig: params,
      api: this._api,
      sdk: this
    });
  }
  /**
   * Check if the SDK user is authenticated.
   * @date 1/31/2024 - 4:08:17 PM
   *
   * @private
   * @returns {boolean}
   */
  isLoggedIn() {
    return typeof this.config.apiKey !== "undefined" && typeof this.config.masterKeys !== "undefined" && typeof this.config.publicKey !== "undefined" && typeof this.config.privateKey !== "undefined" && typeof this.config.baseFolderUUID !== "undefined" && typeof this.config.authVersion !== "undefined" && typeof this.config.userId !== "undefined" && this.config.apiKey.length > 0 && this.config.masterKeys.length > 0 && this.config.publicKey.length > 0 && this.config.privateKey.length > 0 && this.config.baseFolderUUID.length > 0 && this.config.userId > 0 && [1, 2].includes(this.config.authVersion);
  }
  /**
   * Update keypair.
   * @date 2/20/2024 - 7:47:41 AM
   *
   * @private
   * @async
   * @param {{apiKey: string, publicKey: string, privateKey: string, masterKeys: string[]}} param0
   * @param {string} param0.apiKey
   * @param {string} param0.publicKey
   * @param {string} param0.privateKey
   * @param {{}} param0.masterKeys
   * @returns {Promise<void>}
   */
  async _updateKeyPair({ apiKey, publicKey, privateKey, masterKeys }) {
    const encryptedPrivateKey = await this.getWorker().crypto.encrypt.metadata({
      metadata: privateKey,
      key: masterKeys[masterKeys.length - 1]
    });
    await this._api.v3().user().keyPair().update({
      publicKey,
      encryptedPrivateKey,
      apiKey
    });
  }
  /**
   * Set keypair.
   * @date 2/20/2024 - 7:48:10 AM
   *
   * @private
   * @async
   * @param {{apiKey: string, publicKey: string, privateKey: string, masterKeys: string[]}} param0
   * @param {string} param0.apiKey
   * @param {string} param0.publicKey
   * @param {string} param0.privateKey
   * @param {{}} param0.masterKeys
   * @returns {Promise<void>}
   */
  async _setKeyPair({ apiKey, publicKey, privateKey, masterKeys }) {
    const encryptedPrivateKey = await this.getWorker().crypto.encrypt.metadata({
      metadata: privateKey,
      key: masterKeys[masterKeys.length - 1]
    });
    await this._api.v3().user().keyPair().set({
      publicKey,
      encryptedPrivateKey,
      apiKey
    });
  }
  async __updateKeyPair({ apiKey, masterKeys }) {
    const keyPairInfo = await this._api.v3().user().keyPair().info({ apiKey });
    if (typeof keyPairInfo.publicKey === "string" && typeof keyPairInfo.privateKey === "string" && keyPairInfo.publicKey.length > 0 && keyPairInfo.privateKey.length > 0) {
      let privateKey = null;
      for (const masterKey of masterKeys) {
        try {
          const decryptedPrivateKey = await this.getWorker().crypto.decrypt.metadata({
            metadata: keyPairInfo.privateKey,
            key: masterKey
          });
          if (typeof decryptedPrivateKey === "string" && decryptedPrivateKey.length > 16) {
            privateKey = decryptedPrivateKey;
            break;
          }
        } catch {
          continue;
        }
      }
      if (!privateKey) {
        if (this._updateKeyPairTries < 3) {
          this._updateKeyPairTries += 1;
          await new Promise((resolve) => setTimeout(resolve, 250));
          return await this.__updateKeyPair({
            apiKey,
            masterKeys
          });
        }
        const generatedKeyPair2 = await this.getWorker().crypto.utils.generateKeyPair();
        await this._updateKeyPair({
          apiKey,
          publicKey: generatedKeyPair2.publicKey,
          privateKey: generatedKeyPair2.privateKey,
          masterKeys
        });
        return {
          publicKey: generatedKeyPair2.publicKey,
          privateKey: generatedKeyPair2.privateKey
        };
      }
      await this._updateKeyPair({
        apiKey,
        publicKey: keyPairInfo.publicKey,
        privateKey,
        masterKeys
      });
      return {
        publicKey: keyPairInfo.publicKey,
        privateKey
      };
    }
    const generatedKeyPair = await this.getWorker().crypto.utils.generateKeyPair();
    await this._setKeyPair({
      apiKey,
      publicKey: generatedKeyPair.publicKey,
      privateKey: generatedKeyPair.privateKey,
      masterKeys
    });
    return {
      publicKey: generatedKeyPair.publicKey,
      privateKey: generatedKeyPair.privateKey
    };
  }
  async _updateKeys({ apiKey, masterKeys }) {
    const currentLastMasterKey = masterKeys[masterKeys.length - 1];
    if (!currentLastMasterKey || currentLastMasterKey.length < 16) {
      throw new Error("Invalid current master key.");
    }
    const encryptedMasterKeys = await this.getWorker().crypto.encrypt.metadata({
      metadata: masterKeys.join("|"),
      key: currentLastMasterKey
    });
    const masterKeysResponse = await this._api.v3().user().masterKeys({
      encryptedMasterKeys,
      apiKey
    });
    const newMasterKeys = [...masterKeys];
    for (const masterKey of masterKeys) {
      try {
        const decryptedMasterKeys = await this.getWorker().crypto.decrypt.metadata({
          metadata: masterKeysResponse.keys,
          key: masterKey
        });
        if (typeof decryptedMasterKeys === "string" && decryptedMasterKeys.length > 16 && decryptedMasterKeys.includes("|")) {
          for (const key of decryptedMasterKeys.split("|")) {
            if (key.length > 0 && !newMasterKeys.includes(key)) {
              newMasterKeys.push(key);
            }
          }
          break;
        }
      } catch {
        continue;
      }
    }
    if (newMasterKeys.length === 0) {
      throw new Error("Could not decrypt master keys.");
    }
    const { publicKey, privateKey } = await this.__updateKeyPair({
      apiKey,
      masterKeys: newMasterKeys
    });
    return {
      masterKeys: newMasterKeys,
      publicKey,
      privateKey
    };
  }
  /**
   * Authenticate.
   * @date 2/20/2024 - 7:24:10 AM
   *
   * @public
   * @async
   * @param {{email?: string, password?: string, twoFactorCode?: string}} param0
   * @param {string} param0.email
   * @param {string} param0.password
   * @param {string} param0.twoFactorCode
   * @returns {Promise<void>}
   */
  async login({ email, password, twoFactorCode }) {
    const emailToUse = email ? email : this.config.email ? this.config.email : "";
    const passwordToUse = password ? password : this.config.password ? this.config.password : "";
    const twoFactorCodeToUse = twoFactorCode ? twoFactorCode : this.config.twoFactorCode ? this.config.twoFactorCode : "XXXXXX";
    if (emailToUse.length === 0 || passwordToUse.length === 0 || twoFactorCodeToUse.length === 0) {
      throw new Error("Empty email, password or twoFactorCode");
    }
    const authInfo = await this._api.v3().auth().info({ email: emailToUse });
    const authVersion = authInfo.authVersion;
    const derived = await this.getWorker().crypto.utils.generatePasswordAndMasterKeyBasedOnAuthVersion({
      rawPassword: passwordToUse,
      authVersion: authInfo.authVersion,
      salt: authInfo.salt
    });
    const loginResponse = await this._api.v3().login({
      email: emailToUse,
      password: derived.derivedPassword,
      twoFactorCode: twoFactorCodeToUse,
      authVersion
    });
    const [infoResponse, baseFolderResponse] = await Promise.all([
      this._api.v3().user().info({ apiKey: loginResponse.apiKey }),
      this._api.v3().user().baseFolder({ apiKey: loginResponse.apiKey })
    ]);
    const updateKeys = await this._updateKeys({
      apiKey: loginResponse.apiKey,
      masterKeys: [derived.derivedMasterKeys]
    });
    this.init({
      ...this.config,
      email: emailToUse,
      password: passwordToUse,
      twoFactorCode: twoFactorCodeToUse,
      masterKeys: updateKeys.masterKeys,
      apiKey: loginResponse.apiKey,
      publicKey: updateKeys.publicKey,
      privateKey: updateKeys.privateKey,
      authVersion,
      baseFolderUUID: baseFolderResponse.uuid,
      userId: infoResponse.id
    });
  }
  /**
   * Logout.
   * @date 2/9/2024 - 5:48:28 AM
   *
   * @public
   */
  logout() {
    this.init({
      ...this.config,
      email: void 0,
      password: void 0,
      twoFactorCode: void 0,
      masterKeys: void 0,
      apiKey: void 0,
      publicKey: void 0,
      privateKey: void 0,
      authVersion: void 0,
      baseFolderUUID: void 0,
      userId: void 0
    });
  }
  api(version) {
    if (version === 3) {
      return this._api.v3();
    }
    throw new Error(`API version ${version} does not exist`);
  }
  /**
   * Returns an instance of Crypto.
   * @date 1/31/2024 - 4:29:49 PM
   *
   * @public
   * @returns {Crypto}
   */
  crypto() {
    return this._crypto;
  }
  /**
   * Returns an instance of FS.
   * @date 2/17/2024 - 1:52:12 AM
   *
   * @public
   * @returns {FS}
   */
  fs() {
    if (!this.isLoggedIn()) {
      throw new Error("Not authenticated, please call login() first");
    }
    return this._fs;
  }
  /**
   * Returns an instance of Cloud.
   * @date 2/17/2024 - 1:52:05 AM
   *
   * @public
   * @returns {Cloud}
   */
  cloud() {
    if (!this.isLoggedIn()) {
      throw new Error("Not authenticated, please call login() first");
    }
    return this._cloud;
  }
  /**
   * Returns an instance of Notes.
   * @date 2/19/2024 - 6:32:35 AM
   *
   * @public
   * @returns {Notes}
   */
  notes() {
    if (!this.isLoggedIn()) {
      throw new Error("Not authenticated, please call login() first");
    }
    return this._notes;
  }
  /**
   * Returns an instance of Chats.
   * @date 2/19/2024 - 6:32:35 AM
   *
   * @public
   * @returns {Chats}
   */
  chats() {
    if (!this.isLoggedIn()) {
      throw new Error("Not authenticated, please call login() first");
    }
    return this._chats;
  }
  /**
   * Returns an instance of Contacts.
   * @date 2/20/2024 - 6:27:05 AM
   *
   * @public
   * @returns {Contacts}
   */
  contacts() {
    if (!this.isLoggedIn()) {
      throw new Error("Not authenticated, please call login() first");
    }
    return this._contacts;
  }
  /**
   * Return an instance of User.
   * @date 2/20/2024 - 6:27:17 AM
   *
   * @public
   * @returns {User}
   */
  user() {
    if (!this.isLoggedIn()) {
      throw new Error("Not authenticated, please call login() first");
    }
    return this._user;
  }
  /**
   * Clear the temporary directory. Only available in a Node.JS environment.
   * @date 2/17/2024 - 1:51:39 AM
   *
   * @public
   * @async
   * @returns {Promise<void>}
   */
  async clearTemporaryDirectory() {
    if (environment !== "node") {
      return;
    }
    const tmpDir = utils_default.normalizePath(import_path6.default.join(this.config.tmpPath ? this.config.tmpPath : import_os4.default.tmpdir(), "filen-sdk"));
    await utils_default.clearTempDirectory({ tmpDir });
  }
};
var browser_default = FilenSDK;
export {
  APIError,
  BASE64_BUFFER_SIZE,
  BUFFER_SIZE,
  CHUNK_SIZE,
  CURRENT_FILE_ENCRYPTION_VERSION,
  ChunkedUploadWriter,
  DEFAULT_UPLOAD_BUCKET,
  DEFAULT_UPLOAD_REGION,
  FilenSDK,
  MAX_CHAT_SIZE,
  MAX_CONCURRENT_DIRECTORY_DOWNLOADS,
  MAX_CONCURRENT_DIRECTORY_UPLOADS,
  MAX_CONCURRENT_DOWNLOADS,
  MAX_CONCURRENT_LISTING_OPS,
  MAX_CONCURRENT_SHARES,
  MAX_CONCURRENT_UPLOADS,
  MAX_DOWNLOAD_THREADS,
  MAX_DOWNLOAD_WRITERS,
  MAX_NOTE_SIZE,
  MAX_UPLOAD_THREADS,
  PauseSignal,
  UPLOAD_CHUNK_SIZE,
  browser_default as default,
  environment,
  isBrowser
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

crypto-js/ripemd160.js:
  (** @preserve
  	(c) 2012 by Cdric Mesnil. All rights reserved.
  
  	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
  
  	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
  	    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
  
  	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  	*)

crypto-js/mode-ctr-gladman.js:
  (** @preserve
   * Counter block mode compatible with  Dr Brian Gladman fileenc.c
   * derived from CryptoJS.mode.CTR
   * Jan Hruby jhruby.web@gmail.com
   *)

engine.io-parser/lib/utf8.js:
  (*! https://mths.be/utf8js v2.1.2 by @mathias *)

imurmurhash/imurmurhash.js:
  (**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   *)

mime-db/index.js:
  (*!
   * mime-db
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015-2022 Douglas Christopher Wilson
   * MIT Licensed
   *)

mime-types/index.js:
  (*!
   * mime-types
   * Copyright(c) 2014 Jonathan Ong
   * Copyright(c) 2015 Douglas Christopher Wilson
   * MIT Licensed
   *)
*/
//# sourceMappingURL=@filen_sdk.js.map
